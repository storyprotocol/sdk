<!doctype html>
<html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Mochawesome Report</title><link rel="stylesheet" href="assets/app.css"/></head><body data-raw="{&quot;stats&quot;:{&quot;suites&quot;:62,&quot;tests&quot;:190,&quot;passes&quot;:190,&quot;pending&quot;:0,&quot;failures&quot;:0,&quot;start&quot;:&quot;2026-01-26T03:20:09.242Z&quot;,&quot;end&quot;:&quot;2026-01-26T04:07:01.017Z&quot;,&quot;duration&quot;:2811775,&quot;testsRegistered&quot;:190,&quot;passPercent&quot;:100,&quot;pendingPercent&quot;:0,&quot;other&quot;:0,&quot;hasOther&quot;:false,&quot;skipped&quot;:0,&quot;hasSkipped&quot;:false},&quot;results&quot;:[{&quot;uuid&quot;:&quot;0b0f7f05-abf3-41e9-a03d-28b62ea03ea2&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;1939b854-5620-4118-ada5-d37ca93a827e&quot;,&quot;title&quot;:&quot;Dispute Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/dispute.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Dispute Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions \&quot;before all\&quot; hook in \&quot;Dispute Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9168,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;clientA = (0, util_1.getStoryClient)();\nconst derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nclientB = derivedClient.clientB;\nminimumBond = await (0, oov3_1.getMinimumBond)(util_1.publicClient, new generated_1.ArbitrationPolicyUmaClient(util_1.publicClient, util_1.walletClient), src_1.WIP_TOKEN_ADDRESS);\nconst txData = await clientA.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nconst nftContract = txData.spgNftContract;\nipIdB = (await clientB.ipAsset.mintAndRegisterIp({\n    spgNftContract: nftContract,\n})).ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c94b3503-9403-4798-bb84-17a9053625ac&quot;,&quot;parentUUID&quot;:&quot;1939b854-5620-4118-ada5-d37ca93a827e&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;it should not cancel a dispute (yet)&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions it should not cancel a dispute (yet)&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9217,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const raiseResponse = await clientA.dispute.raiseDispute({\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 2592000,\n    bond: minimumBond,\n});\nawait (0, chai_1.expect)(clientA.dispute.cancelDispute({\n    disputeId: raiseResponse.disputeId,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;79683e13-142a-4f27-9300-93cca69be7c5&quot;,&quot;parentUUID&quot;:&quot;1939b854-5620-4118-ada5-d37ca93a827e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;7169ec0e-75ef-4b40-adfa-9b231ff73de1&quot;,&quot;title&quot;:&quot;raiseDispute and counter dispute&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/dispute.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should raise a dispute&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should raise a dispute&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9052,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const raiseDisputeRequest = {\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 2592000,\n    bond: minimumBond,\n};\nconst response = await clientA.dispute.raiseDispute(raiseDisputeRequest);\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.disputeId).to.be.a(\&quot;bigint\&quot;);\ndisputeId = response.disputeId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9693bae6-ca93-485b-bad5-3394917b51a9&quot;,&quot;parentUUID&quot;:&quot;7169ec0e-75ef-4b40-adfa-9b231ff73de1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should validate all enum values defined in DisputeTargetTag&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should validate all enum values defined in DisputeTargetTag&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:230,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const allTags = Object.values(src_1.DisputeTargetTag);\nfor (const tag of allTags) {\n    const tagHex = (0, viem_1.toHex)(tag, { size: 32 });\n    const { allowed } = await clientA.dispute.disputeModuleClient.isWhitelistedDisputeTag({\n        tag: tagHex,\n    });\n    if (tag === src_1.DisputeTargetTag.IN_DISPUTE) {\n        (0, chai_1.expect)(allowed).equal(false);\n    }\n    else {\n        (0, chai_1.expect)(allowed).equal(true);\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f370f7b6-dbe0-4835-8d4e-6d8aaa578088&quot;,&quot;parentUUID&quot;:&quot;7169ec0e-75ef-4b40-adfa-9b231ff73de1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should raise disputes with different DisputeTargetTag enum values&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should raise disputes with different DisputeTargetTag enum values&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:48644,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const allTags = Object.values(src_1.DisputeTargetTag);\nfor (const tag of allTags) {\n    const raiseDisputeRequest = {\n        targetIpId: ipIdB,\n        cid: await generateCID(),\n        targetTag: tag,\n        liveness: 2592000,\n        bond: minimumBond,\n    };\n    if (tag === src_1.DisputeTargetTag.IN_DISPUTE) {\n        await (0, chai_1.expect)(clientA.dispute.raiseDispute(raiseDisputeRequest)).to.be.rejectedWith(\&quot;The target tag IN_DISPUTE is not whitelisted\&quot;);\n    }\n    else {\n        const response = await clientA.dispute.raiseDispute(raiseDisputeRequest);\n        (0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n        (0, chai_1.expect)(response.disputeId).to.be.a(\&quot;bigint\&quot;);\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8a05e59d-9b04-4ae8-afef-13f96af1dfae&quot;,&quot;parentUUID&quot;:&quot;7169ec0e-75ef-4b40-adfa-9b231ff73de1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should reject a dispute with an invalid tag not defined in the enum&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should reject a dispute with an invalid tag not defined in the enum&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:194,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(clientA.dispute.raiseDispute({\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: \&quot;INVALID_TAG\&quot;,\n    liveness: 2592000,\n    bond: minimumBond,\n})).to.be.rejectedWith(\&quot;The target tag INVALID_TAG is not whitelisted\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7a9eb099-a611-467c-a81d-8bb3bc6b5478&quot;,&quot;parentUUID&quot;:&quot;7169ec0e-75ef-4b40-adfa-9b231ff73de1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should be able to counter existing dispute once&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should be able to counter existing dispute once&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17691,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const assertionId = await clientB.dispute.disputeIdToAssertionId(disputeId);\nconst counterEvidenceCID = await generateCID();\nconst ret = await clientB.dispute.disputeAssertion({\n    ipId: ipIdB,\n    assertionId,\n    counterEvidenceCID,\n});\n(0, chai_1.expect)(ret.txHash).to.be.a(\&quot;string\&quot;);\n// should throw error if attempting to dispute assertion again\nawait (0, chai_1.expect)(clientB.dispute.disputeAssertion({\n    ipId: ipIdB,\n    assertionId,\n    counterEvidenceCID,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3aa3cf36-bc46-474a-aaf2-c8c11b750d0f&quot;,&quot;parentUUID&quot;:&quot;7169ec0e-75ef-4b40-adfa-9b231ff73de1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;9693bae6-ca93-485b-bad5-3394917b51a9&quot;,&quot;f370f7b6-dbe0-4835-8d4e-6d8aaa578088&quot;,&quot;8a05e59d-9b04-4ae8-afef-13f96af1dfae&quot;,&quot;7a9eb099-a611-467c-a81d-8bb3bc6b5478&quot;,&quot;3aa3cf36-bc46-474a-aaf2-c8c11b750d0f&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:75811,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;5bbec603-bfa1-49af-b273-7de5fb6fb7e0&quot;,&quot;title&quot;:&quot;Dispute resolution&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/dispute.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before each\&quot; hook in \&quot;Dispute resolution\&quot;&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution \&quot;before each\&quot; hook in \&quot;Dispute resolution\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30925,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Setup NFT collection\nconst txData = await clientA.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\n// Get parent IP ID and license terms ID\nconst ipIdAndLicenseResponse = await clientA.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContract,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: src_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: generated_1.evenSplitGroupPoolAddress[util_1.aeneid],\n            },\n        },\n    ],\n});\nparentIpId = ipIdAndLicenseResponse.ipId;\nlicenseTermsId = ipIdAndLicenseResponse.licenseTermsIds[0];\n//Create a derivative ip\nconst derivativeIpIdResponse1 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\nchildIpId = derivativeIpIdResponse1.ipId;\n// Create a second derivative ip\nconst derivativeIpIdResponse2 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\nchildIpId2 = derivativeIpIdResponse2.ipId;\n// Raise a dispute\nconst response = await clientA.dispute.raiseDispute({\n    targetIpId: parentIpId,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 1,\n    bond: minimumBond,\n});\ndisputeId = response.disputeId;\n// This timeout guarantees that the assertion is expired\n// its intended to be longer than the current block time\n// so it won&#x27;t be included in the same block\nawait new Promise((resolve) =&gt; setTimeout(resolve, 3000));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ead1c9b7-1477-40dc-a9f6-770dee814a53&quot;,&quot;parentUUID&quot;:&quot;5bbec603-bfa1-49af-b273-7de5fb6fb7e0&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should tag infringing ip&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag infringing ip&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8738,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Tag derivative IP as infringing\nconst results = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: childIpId2,\n            disputeId: disputeId,\n        },\n    ],\n});\n(0, chai_1.expect)(results[0].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6077c6de-9fd3-43ec-b8f0-6ca0720c6502&quot;,&quot;parentUUID&quot;:&quot;5bbec603-bfa1-49af-b273-7de5fb6fb7e0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should tag a single IP as infringing without using multicall&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag a single IP as infringing without using multicall&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8778,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;/**\n * Test Flow:\n * 1. Set judgment on an existing dispute to mark it as valid (did in `before each` block)\n * 2. Verify the dispute state changed correctly after judgment\n * 3. Try to tag a derivative IP using the judged dispute\n */\n// Step 1: Set judgment on an existing dispute to mark it as valid\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Step 2: Verify dispute state\n// The disputes() function returns multiple values about the dispute:\n// - targetTag: the tag we wanted to apply when raising the dispute\n// - currentTag: the current state of the dispute after judgment\n// After a successful judgment, currentTag should equal targetTag\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag); // Verify judgment was recorded correctly\n// Step 3: Attempt to tag a derivative IP\n// This will fail if:\n// - The dispute is not in a valid state (still IN_DISPUTE or cleared)\n// - The IP we&#x27;re trying to tag is not actually a derivative of the disputed IP\n// - The dispute has already been used to tag this IP\nconst response = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId, // The derivative IP to tag\n            disputeId: disputeId, // Using the judged dispute as basis for tagging\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: false, // Force single transaction instead of batch\n    },\n});\n// Verify we got the expected response\n(0, chai_1.expect)(response).to.have.lengthOf(1);\n(0, chai_1.expect)(response[0].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0bec77da-cf2f-4e7f-8f4f-8318434c540a&quot;,&quot;parentUUID&quot;:&quot;5bbec603-bfa1-49af-b273-7de5fb6fb7e0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should tag multiple IPs as infringing using multicall&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag multiple IPs as infringing using multicall&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:25641,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const disputeResponse = await clientA.dispute.raiseDispute({\n    targetIpId: parentIpId,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 1,\n    bond: minimumBond,\n});\nconst testDisputeId = disputeResponse.disputeId;\nconst derivativeResponse2 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nconst newChildIpId = derivativeResponse2.ipId;\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, testDisputeId);\n// This timeout guarantees that the assertion is expired\n// its intended to be longer than the current block time\n// so it won&#x27;t be included in the same block\nawait new Promise((resolve) =&gt; setTimeout(resolve, 3000));\nconst { currentTag, targetTag } = await getDisputeState(testDisputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst response = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: testDisputeId,\n        },\n        {\n            ipId: newChildIpId,\n            disputeId: testDisputeId,\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: true,\n    },\n});\n(0, chai_1.expect)(response).to.have.lengthOf(1);\n(0, chai_1.expect)(response[0].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8170b136-ef81-4808-a384-7d047f624d63&quot;,&quot;parentUUID&quot;:&quot;5bbec603-bfa1-49af-b273-7de5fb6fb7e0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should tag multiple IPs without multicall when specified&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag multiple IPs without multicall when specified&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18891,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create two new derivative IPs sequentially\nconst derivativeResponse3 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nconst derivativeResponse4 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst responses = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: derivativeResponse3.ipId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: derivativeResponse4.ipId,\n            disputeId: disputeId,\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: false,\n    },\n});\n(0, chai_1.expect)(responses).to.have.lengthOf(2);\n(0, chai_1.expect)(responses[0].txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(responses[1].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;21fac008-6de4-4f51-8914-75c9143a739b&quot;,&quot;parentUUID&quot;:&quot;5bbec603-bfa1-49af-b273-7de5fb6fb7e0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to tag with invalid dispute ID&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should fail when trying to tag with invalid dispute ID&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:47,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: 999999n,\n        },\n    ],\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fc150ed1-f0d3-43d4-9c28-c271b70d559e&quot;,&quot;parentUUID&quot;:&quot;5bbec603-bfa1-49af-b273-7de5fb6fb7e0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should resolve a dispute successfully when initiated by dispute initiator&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should resolve a dispute successfully when initiated by dispute initiator&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12799,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst response = await clientA.dispute.resolveDispute({\n    disputeId: disputeId,\n    data: \&quot;0x\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f98e7f96-65ad-4f38-bd3e-9348fe3d96f3&quot;,&quot;parentUUID&quot;:&quot;5bbec603-bfa1-49af-b273-7de5fb6fb7e0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when non-initiator tries to resolve the dispute&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should fail when non-initiator tries to resolve the dispute&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:49,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(clientB.dispute.resolveDispute({\n    disputeId: disputeId,\n    data: \&quot;0x\&quot;,\n})).to.be.rejectedWith(\&quot;NotDisputeInitiator\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;73772bce-fc0c-436c-a093-3a6c1e5bff0e&quot;,&quot;parentUUID&quot;:&quot;5bbec603-bfa1-49af-b273-7de5fb6fb7e0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should propagate IMPROPER_REGISTRATION tag to derivative IPs&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should propagate IMPROPER_REGISTRATION tag to derivative IPs&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8785,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Verify the dispute state changed correctly\nconst { currentTag: parentCurrentTag, targetTag: parentTargetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(parentCurrentTag).to.equal(parentTargetTag);\n// Propagate the tag to both derivative IPs\nconst results = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: childIpId2,\n            disputeId: disputeId,\n        },\n    ],\n});\nconst logData = results[0].receipt?.logs[0].data;\nconst firstWord = logData.slice(0, 66);\nconst childDisputeId = BigInt(firstWord);\n// Verify successful tagging\n(0, chai_1.expect)(results[0].txHash).to.be.a(\&quot;string\&quot;);\nconst { currentTag: childCurrentTag } = await getDisputeState(childDisputeId);\n// Convert the IMPROPER_USAGE tag to hex for comparison\nconst improperUsageTagHex = (0, viem_1.toHex)(src_1.DisputeTargetTag.IMPROPER_REGISTRATION, { size: 32 });\n// Verify both child IPs have the IMPROPER_USAGE tag by\n// fetching and comparing their dispute tags\n(0, chai_1.expect)(parentCurrentTag).to.equal(parentTargetTag);\n(0, chai_1.expect)(childCurrentTag).to.equal(improperUsageTagHex);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ea750ae8-ef5f-460b-8bc5-b6078161fa8a&quot;,&quot;parentUUID&quot;:&quot;5bbec603-bfa1-49af-b273-7de5fb6fb7e0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;6077c6de-9fd3-43ec-b8f0-6ca0720c6502&quot;,&quot;0bec77da-cf2f-4e7f-8f4f-8318434c540a&quot;,&quot;8170b136-ef81-4808-a384-7d047f624d63&quot;,&quot;21fac008-6de4-4f51-8914-75c9143a739b&quot;,&quot;fc150ed1-f0d3-43d4-9c28-c271b70d559e&quot;,&quot;f98e7f96-65ad-4f38-bd3e-9348fe3d96f3&quot;,&quot;73772bce-fc0c-436c-a093-3a6c1e5bff0e&quot;,&quot;ea750ae8-ef5f-460b-8bc5-b6078161fa8a&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:83728,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;79683e13-142a-4f27-9300-93cca69be7c5&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:9217,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;d1169fd5-54ba-413f-81ff-833be79df4ad&quot;,&quot;title&quot;:&quot;Group Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Group Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Group Functions \&quot;before all\&quot; hook in \&quot;Group Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4337,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\n// Create NFT Collection\nspgNftContract = (await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n})).spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e66e3964-2004-4e8a-96c7-93f5f8ba92c0&quot;,&quot;parentUUID&quot;:&quot;d1169fd5-54ba-413f-81ff-833be79df4ad&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;00a37d2e-e63b-4cd1-aa15-389d8080c2b8&quot;,&quot;title&quot;:&quot;Group Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Group Operations\&quot;&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations \&quot;before all\&quot; hook in \&quot;Group Operations\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9223,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create initial IP with license terms\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    allowDuplicates: false,\n    licenseTermsData,\n});\nlicenseTermsId = result.licenseTermsIds[0];\nipId = result.ipId;\n// Set licensing config\nawait client.license.setLicensingConfig({\n    ipId,\n    licenseTermsId,\n    licenseTemplate: generated_1.piLicenseTemplateAddress[util_1.aeneid],\n    licensingConfig: {\n        isSet: true,\n        mintingFee: 0n,\n        licensingHook: viem_1.zeroAddress,\n        hookData: viem_1.zeroAddress,\n        commercialRevShare: 0,\n        disabled: false,\n        expectMinimumGroupRewardShare: 0,\n        expectGroupRewardPool: groupPoolAddress,\n    },\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;edb87f24-e3d5-49ad-8d40-f89a2a69140b&quot;,&quot;parentUUID&quot;:&quot;00a37d2e-e63b-4cd1-aa15-389d8080c2b8&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully register group and attach license&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register group and attach license&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4369,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.registerGroupAndAttachLicense({\n    groupPool: groupPoolAddress,\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n});\ngroupId = result.groupId;\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.groupId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;123338dc-2203-45dd-80d5-76ec6e0518dc&quot;,&quot;parentUUID&quot;:&quot;00a37d2e-e63b-4cd1-aa15-389d8080c2b8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully mint, register IP, attach license and add to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully mint, register IP, attach license and add to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4492,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.mintAndRegisterIpAndAttachLicenseAndAddToGroup({\n    groupId,\n    spgNftContract,\n    licenseData: [\n        {\n            licenseTermsId,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: groupPoolAddress,\n            },\n        },\n    ],\n    maxAllowedRewardShare: 100,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;585cbe98-fe1b-4d07-84c7-b1a5b52e2fcc&quot;,&quot;parentUUID&quot;:&quot;00a37d2e-e63b-4cd1-aa15-389d8080c2b8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register a basic group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register a basic group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4339,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.registerGroup({\n    groupPool: groupPoolAddress,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.groupId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;dc811c86-7311-4139-acb8-d7e8d98ee86e&quot;,&quot;parentUUID&quot;:&quot;00a37d2e-e63b-4cd1-aa15-389d8080c2b8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register existing IP with license and add to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register existing IP with license and add to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8914,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(spgNftContract, \&quot;test-metadata\&quot;);\nconst result = await client.groupClient.registerIpAndAttachLicenseAndAddToGroup({\n    groupId,\n    nftContract: spgNftContract,\n    tokenId,\n    licenseData: [\n        {\n            licenseTermsId,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: groupPoolAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5b36ea78-77cb-4025-9d76-bfabdfe055ed&quot;,&quot;parentUUID&quot;:&quot;00a37d2e-e63b-4cd1-aa15-389d8080c2b8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register group with license and add multiple IPs&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register group with license and add multiple IPs&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4451,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.registerGroupAndAttachLicenseAndAddIps({\n    groupPool: groupPoolAddress,\n    maxAllowedRewardShare: 50,\n    ipIds: [ipId],\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.groupId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2519477c-fba9-40a2-b459-abc472750717&quot;,&quot;parentUUID&quot;:&quot;00a37d2e-e63b-4cd1-aa15-389d8080c2b8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to add unregistered IP to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should fail when trying to add unregistered IP to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:49,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.groupClient.registerGroupAndAttachLicenseAndAddIps({\n    groupPool: groupPoolAddress,\n    maxAllowedRewardShare: 5,\n    ipIds: [viem_1.zeroAddress], // Invalid IP address\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n})).to.be.rejectedWith(\&quot;Failed to register group and attach license and add ips\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3571855f-0138-4381-9a17-fac483c14d14&quot;,&quot;parentUUID&quot;:&quot;00a37d2e-e63b-4cd1-aa15-389d8080c2b8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;513fddaf-cd17-4402-a17f-69beb3386de4&quot;,&quot;title&quot;:&quot;Add IPs to Group and Remove IPs from Group&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully add multiple IPs to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should successfully add multiple IPs to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17724,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const registerResult = await client.ipAsset.batchMintAndRegisterIpAssetWithPilTerms({\n    args: [\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n    ],\n});\nipIds = registerResult.results?.map((result) =&gt; result.ipId) ?? [];\nconst result = await client.groupClient.addIpsToGroup({\n    groupIpId: groupId,\n    ipIds: ipIds,\n    maxAllowedRewardSharePercentage: 55,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7aa0d334-ef43-4eb5-af38-c62317ff4eba&quot;,&quot;parentUUID&quot;:&quot;513fddaf-cd17-4402-a17f-69beb3386de4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully remove IPs from group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should successfully remove IPs from group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4354,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.removeIpsFromGroup({\n    groupIpId: groupId,\n    ipIds: ipIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c21f3793-05af-48f6-85e7-55bca7998c6c&quot;,&quot;parentUUID&quot;:&quot;513fddaf-cd17-4402-a17f-69beb3386de4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to remove IPs from a non-existent group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should fail when trying to remove IPs from a non-existent group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4780,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const registerResult = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData,\n});\nconst testIpId = registerResult.ipId;\nconst nonExistentGroupId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.removeIpsFromGroup({\n    groupIpId: nonExistentGroupId,\n    ipIds: [testIpId],\n})).to.be.rejectedWith(\&quot;Failed to remove IPs from group\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5a857711-6d83-48f3-850b-81fc2ae56017&quot;,&quot;parentUUID&quot;:&quot;513fddaf-cd17-4402-a17f-69beb3386de4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to remove non-existent IPs from a group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should fail when trying to remove non-existent IPs from a group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4373,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const groupResult = await client.groupClient.registerGroup({\n    groupPool: groupPoolAddress,\n});\nconst testGroupId = groupResult.groupId;\nconst nonExistentIpId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.removeIpsFromGroup({\n    groupIpId: testGroupId,\n    ipIds: [nonExistentIpId],\n})).to.be.rejectedWith(\&quot;Failed to remove IPs from group\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;eb4ab100-0f8e-46bc-846d-fdcad2a8baa0&quot;,&quot;parentUUID&quot;:&quot;513fddaf-cd17-4402-a17f-69beb3386de4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;7aa0d334-ef43-4eb5-af38-c62317ff4eba&quot;,&quot;c21f3793-05af-48f6-85e7-55bca7998c6c&quot;,&quot;5a857711-6d83-48f3-850b-81fc2ae56017&quot;,&quot;eb4ab100-0f8e-46bc-846d-fdcad2a8baa0&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:31231,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;123338dc-2203-45dd-80d5-76ec6e0518dc&quot;,&quot;585cbe98-fe1b-4d07-84c7-b1a5b52e2fcc&quot;,&quot;dc811c86-7311-4139-acb8-d7e8d98ee86e&quot;,&quot;5b36ea78-77cb-4025-9d76-bfabdfe055ed&quot;,&quot;2519477c-fba9-40a2-b459-abc472750717&quot;,&quot;3571855f-0138-4381-9a17-fac483c14d14&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:26614,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;13b34076-4ea9-45a1-b706-49240391a23d&quot;,&quot;title&quot;:&quot;Collect Royalty and Claim Reward&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Collect Royalty and Claim Reward\&quot;&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward \&quot;before all\&quot; hook in \&quot;Collect Royalty and Claim Reward\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13228,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Register IP id\nconst result1 = await mintAndRegisterIpAssetWithPilTermsHelper();\nipId = result1.ipId;\nlicenseTermsId = result1.licenseTermsIds[0];\n// Register group id\ngroupIpId = await registerGroupAndAttachLicenseHelper(licenseTermsId, [ipId]);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1a0780e0-5c7c-40e9-a6a9-de89ea6758fa&quot;,&quot;parentUUID&quot;:&quot;13b34076-4ea9-45a1-b706-49240391a23d&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully collect royalties&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully collect royalties&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22172,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Mint and register child IP id\nconst childIpId = await mintAndRegisterIpAndMakeDerivativeHelper(groupIpId, licenseTermsId);\n// Pay royalties from child IP id to group IP id and transfer to vault\nawait payRoyaltyAndTransferToVaultHelper(childIpId, groupIpId, src_1.WIP_TOKEN_ADDRESS, 100n);\n// Collect royalties\nconst result = await client.groupClient.collectRoyalties({\n    groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.collectedRoyalties).to.equal(10n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d5e6b849-a503-4e85-b9c4-af8a57288a3f&quot;,&quot;parentUUID&quot;:&quot;13b34076-4ea9-45a1-b706-49240391a23d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully get claimable reward&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully get claimable reward&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:46,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.getClaimableReward({\n    groupIpId: groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n});\n(0, chai_1.expect)(result).to.deep.equal([10n]);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;63f41c74-c4d2-4749-8966-f82effbc26ad&quot;,&quot;parentUUID&quot;:&quot;13b34076-4ea9-45a1-b706-49240391a23d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully claim reward&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully claim reward&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8856,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Mint license tokens to the IP id which doesn&#x27;t have a royalty vault\nawait client.license.mintLicenseTokens({\n    licensorIpId: ipId,\n    licenseTermsId,\n    amount: 1,\n    maxMintingFee: 1,\n    maxRevenueShare: 100,\n});\n// Claim reward\nconst result = await client.groupClient.claimReward({\n    groupIpId: groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.claimedReward?.[0].amount[0]).to.equal(10n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;30ffde26-34ad-4e9b-aaab-4dfe44926862&quot;,&quot;parentUUID&quot;:&quot;13b34076-4ea9-45a1-b706-49240391a23d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to claim reward for a non-existent group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should fail when trying to claim reward for a non-existent group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:52,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const nonExistentGroupId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.claimReward({\n    groupIpId: nonExistentGroupId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n})).to.be.rejectedWith(\&quot;Failed to claim reward\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;90fb012c-a733-4b63-a36d-4b1423bc444e&quot;,&quot;parentUUID&quot;:&quot;13b34076-4ea9-45a1-b706-49240391a23d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to claim reward with invalid token address&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should fail when trying to claim reward with invalid token address&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:50,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const invalidTokenAddress = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.claimReward({\n    groupIpId: groupIpId,\n    currencyToken: invalidTokenAddress,\n    memberIpIds: [ipId],\n})).to.be.rejectedWith(\&quot;Failed to claim reward\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ee546757-00a3-43c8-b2fe-97ba5c9e3803&quot;,&quot;parentUUID&quot;:&quot;13b34076-4ea9-45a1-b706-49240391a23d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully collect royalties and claim reward in one transaction&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully collect royalties and claim reward in one transaction&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:66220,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const ipIds = [];\nconst result1 = await mintAndRegisterIpAssetWithPilTermsHelper();\nconst result2 = await mintAndRegisterIpAssetWithPilTermsHelper();\nipIds.push(result1.ipId);\nipIds.push(result2.ipId);\nlicenseTermsId = result1.licenseTermsIds[0];\nconst groupId = await registerGroupAndAttachLicenseHelper(licenseTermsId, ipIds);\nconst childIpId1 = await mintAndRegisterIpAndMakeDerivativeHelper(groupId, licenseTermsId);\nconst childIpId2 = await mintAndRegisterIpAndMakeDerivativeHelper(groupId, licenseTermsId);\nawait payRoyaltyAndTransferToVaultHelper(childIpId1, groupId, src_1.WIP_TOKEN_ADDRESS, 100n);\nawait payRoyaltyAndTransferToVaultHelper(childIpId2, groupId, src_1.WIP_TOKEN_ADDRESS, 100n);\nconst result = await client.groupClient.collectAndDistributeGroupRoyalties({\n    groupIpId: groupId,\n    currencyTokens: [src_1.WIP_TOKEN_ADDRESS],\n    memberIpIds: ipIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.collectedRoyalties?.[0].amount).to.equal(20n);\n(0, chai_1.expect)(result.royaltiesDistributed?.[0].amount).to.equal(10n);\n(0, chai_1.expect)(result.royaltiesDistributed?.[1].amount).to.equal(10n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ccfe0e00-c0c2-482e-8c9d-0dac42a40b50&quot;,&quot;parentUUID&quot;:&quot;13b34076-4ea9-45a1-b706-49240391a23d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;d5e6b849-a503-4e85-b9c4-af8a57288a3f&quot;,&quot;63f41c74-c4d2-4749-8966-f82effbc26ad&quot;,&quot;30ffde26-34ad-4e9b-aaab-4dfe44926862&quot;,&quot;90fb012c-a733-4b63-a36d-4b1423bc444e&quot;,&quot;ee546757-00a3-43c8-b2fe-97ba5c9e3803&quot;,&quot;ccfe0e00-c0c2-482e-8c9d-0dac42a40b50&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:97396,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;b929e1d0-a424-47b0-8453-e3709e1c7820&quot;,&quot;title&quot;:&quot;IPAccount Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;IPAccount Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions \&quot;before all\&quot; hook in \&quot;IPAccount Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8828,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = registerResult.ipId;\ndata = (0, viem_1.encodeFunctionData)({\n    abi: generated_1.accessControllerAbi,\n    functionName: \&quot;setTransientPermission\&quot;,\n    args: [\n        (0, viem_1.getAddress)(ipId),\n        (0, viem_1.getAddress)(util_1.TEST_WALLET_ADDRESS),\n        (0, viem_1.getAddress)(coreMetadataModule),\n        (0, viem_1.toFunctionSelector)(\&quot;function setAll(address,string,bytes32,bytes32)\&quot;),\n        src_1.AccessPermission.ALLOW,\n    ],\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;430bd43f-4cf5-43b8-93f0-31a8564bcfde&quot;,&quot;parentUUID&quot;:&quot;b929e1d0-a424-47b0-8453-e3709e1c7820&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully set ip metadata&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions should successfully set ip metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4368,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txHash = await client.ipAccount.setIpMetadata({\n    ipId: ipId,\n    metadataURI: \&quot;https://example.com\&quot;,\n    metadataHash: (0, viem_1.toHex)(\&quot;test\&quot;, { size: 32 }),\n});\n(0, chai_1.expect)(txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a88ba554-6f87-49ce-95d3-df742043289a&quot;,&quot;parentUUID&quot;:&quot;b929e1d0-a424-47b0-8453-e3709e1c7820&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully transfer ERC20 tokens&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions should successfully transfer ERC20 tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17724,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const erc20 = new generated_1.Erc20Client(util_1.publicClient, util_1.walletClient);\n// 1. Query token balance of ipId and wallet before\nconst initialErc20BalanceOfIpId = await erc20.balanceOf({\n    account: ipId,\n});\nconst initialErc20BalanceOfWallet = await erc20.balanceOf({\n    account: util_1.TEST_WALLET_ADDRESS,\n});\nconst initialWipBalanceOfIpId = await client.wipClient.balanceOf(ipId);\nconst initialWipBalanceOfWallet = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n// 2. transfer erc20 token to the ip account\nconst txHash = await erc20.mint({\n    to: ipId,\n    amount: (0, viem_1.parseEther)(\&quot;0.002\&quot;),\n});\nawait util_1.publicClient.waitForTransactionReceipt({\n    hash: txHash,\n});\n// 3. transfer wip to the ip account\nawait client.wipClient.deposit({\n    amount: 1n,\n});\nawait client.wipClient.transfer({\n    to: ipId,\n    amount: 1n,\n});\n// 4. transfer token of ip account to wallet address\nconst ret = await client.ipAccount.transferErc20({\n    ipId,\n    tokens: [\n        {\n            address: src_1.WIP_TOKEN_ADDRESS,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: 1n,\n        },\n        {\n            address: erc20.address,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: (0, viem_1.parseEther)(\&quot;0.001\&quot;),\n        },\n        {\n            address: erc20.address,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: (0, viem_1.parseEther)(\&quot;0.001\&quot;),\n        },\n    ],\n});\n// 5. query token balance of ipId and wallet address after\nconst finalErc20BalanceOfIpId = await erc20.balanceOf({\n    account: ipId,\n});\nconst finalWipBalanceOfIpId = await client.wipClient.balanceOf(ipId);\nconst finalErc20BalanceOfWallet = await erc20.balanceOf({\n    account: util_1.TEST_WALLET_ADDRESS,\n});\nconst finalWipBalanceOfWallet = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(ret.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(finalErc20BalanceOfIpId).to.equal(initialErc20BalanceOfIpId);\n(0, chai_1.expect)(finalWipBalanceOfIpId).to.equal(initialWipBalanceOfIpId);\n(0, chai_1.expect)(finalErc20BalanceOfWallet).to.equal(initialErc20BalanceOfWallet + (0, viem_1.parseEther)(\&quot;0.002\&quot;));\n(0, chai_1.expect)(finalWipBalanceOfWallet).to.equal(initialWipBalanceOfWallet + 1n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;caba13a9-c2d0-4653-adca-43b76005db5e&quot;,&quot;parentUUID&quot;:&quot;b929e1d0-a424-47b0-8453-e3709e1c7820&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;6d1d448a-23b4-412a-880b-a16dfc2acf8c&quot;,&quot;title&quot;:&quot;execute&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully execute a transaction&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions execute should successfully execute a transaction&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4331,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.ipAccount.execute({\n    to: permissionAddress,\n    value: 0,\n    data: data,\n    ipId: ipId,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c68b9b5a-7912-42e3-a652-a045c089868c&quot;,&quot;parentUUID&quot;:&quot;6d1d448a-23b4-412a-880b-a16dfc2acf8c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid ipId&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions execute should fail with invalid ipId&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:51,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.execute({\n    to: permissionAddress,\n    value: 0,\n    data: data,\n    ipId: \&quot;0x0000000000000000000000000000000000000000\&quot;,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ec6f73b0-0bcc-4750-b32b-c0032285011d&quot;,&quot;parentUUID&quot;:&quot;6d1d448a-23b4-412a-880b-a16dfc2acf8c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;c68b9b5a-7912-42e3-a652-a045c089868c&quot;,&quot;ec6f73b0-0bcc-4750-b32b-c0032285011d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4382,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;572fff1c-fc7a-4aa8-8a3b-040ad55baee5&quot;,&quot;title&quot;:&quot;executeWithSig&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully execute with valid signature&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should successfully execute with valid signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4372,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Get the IP Account nonce (state)\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\n// Generate signature for the execute operation itself\n// We need to sign the data that will be executed, not the permission data\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\n// Execute with signature\nconst response = await client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;56a19a8e-91c6-4784-932b-b39b7857685e&quot;,&quot;parentUUID&quot;:&quot;572fff1c-fc7a-4aa8-8a3b-040ad55baee5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with expired deadline&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with expired deadline&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:59,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: EXPIRED_DEADLINE,\n    signature: \&quot;0x\&quot;,\n})).to.be.rejectedWith(\&quot;IPAccount__ExpiredSignature\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e43a02a4-3398-4f77-87af-416e08ca473e&quot;,&quot;parentUUID&quot;:&quot;572fff1c-fc7a-4aa8-8a3b-040ad55baee5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid signature format&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with invalid signature format&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:44,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: \&quot;0x1234567890abcdef\&quot;, // Invalid signature format\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;905f41a4-5752-4b70-9150-e55f8b8c4045&quot;,&quot;parentUUID&quot;:&quot;572fff1c-fc7a-4aa8-8a3b-040ad55baee5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with signature from wrong signer&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with signature from wrong signer&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:86,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Generate signature with wrong signer\nconst wrongSigner = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: wrongSigner,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;04605070-6842-46be-bee7-f937a1bd47a5&quot;,&quot;parentUUID&quot;:&quot;572fff1c-fc7a-4aa8-8a3b-040ad55baee5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid ipId format&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with invalid ipId format&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:44,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: \&quot;0x123\&quot;, // Invalid address format\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;Invalid address: 0x123.\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;80bbf140-98b6-4b64-bda1-6debee6524b2&quot;,&quot;parentUUID&quot;:&quot;572fff1c-fc7a-4aa8-8a3b-040ad55baee5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when IP account does not exist&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail when IP account does not exist&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:51,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create a real non-existent IP address (but with correct format)\nconst nonExistentIpId = \&quot;0x1111111111111111111111111111111111111111\&quot;;\n// Generate signature for this non-existent IP\n// Note: We need to try to get nonce first, if IP doesn&#x27;t exist, this step should fail\ntry {\n    const nonceResult = await client.ipAccount.getIpAccountNonce(nonExistentIpId);\n    const { signature } = await (0, src_1.getSignature)({\n        state: nonceResult,\n        to: permissionAddress,\n        encodeData: data,\n        wallet: util_1.walletClient,\n        verifyingContract: nonExistentIpId, // Use non-existent IP as verifying contract\n        deadline: VALID_DEADLINE,\n        chainId: util_1.aeneid,\n    });\n    await (0, chai_1.expect)(client.ipAccount.executeWithSig({\n        to: permissionAddress,\n        data: data,\n        ipId: nonExistentIpId,\n        signer: util_1.TEST_WALLET_ADDRESS,\n        deadline: VALID_DEADLINE,\n        signature: signature,\n    })).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;); // Should fail because IP doesn&#x27;t exist\n}\ncatch (error) {\n    // If getting nonce fails, it means IP indeed doesn&#x27;t exist, which is also our expected result\n    (0, chai_1.expect)(error.message).to.include(\&quot;Failed to get the IP Account nonce\&quot;);\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e73ab552-e9bd-4c0d-80bd-579520152275&quot;,&quot;parentUUID&quot;:&quot;572fff1c-fc7a-4aa8-8a3b-040ad55baee5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with unauthorized signer&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with unauthorized signer&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:98,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Test various unauthorized signer scenarios\nconst unauthorizedSigner = \&quot;0x2222222222222222222222222222222222222222\&quot;;\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: unauthorizedSigner, // Unauthorized signer\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;); // Contract returns InvalidSignature for permission issues&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9b929925-b766-4bfc-bb61-950c9b15e810&quot;,&quot;parentUUID&quot;:&quot;572fff1c-fc7a-4aa8-8a3b-040ad55baee5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with signature for wrong data&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with signature for wrong data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:87,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Generate signature for different data than what we execute\nconst wrongData = (0, viem_1.encodeFunctionData)({\n    abi: generated_1.accessControllerAbi,\n    functionName: \&quot;setTransientPermission\&quot;,\n    args: [\n        (0, viem_1.getAddress)(\&quot;0x1234567890123456789012345678901234567890\&quot;),\n        (0, viem_1.getAddress)(util_1.TEST_WALLET_ADDRESS),\n        (0, viem_1.getAddress)(coreMetadataModule),\n        (0, viem_1.toFunctionSelector)(\&quot;function setAll(address,string,bytes32,bytes32)\&quot;),\n        src_1.AccessPermission.DENY,\n    ],\n});\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: wrongData, // Sign wrong data\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data, // Execute with original data, not the signed data\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;); // Should fail because data doesn&#x27;t match signature&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;db6738c8-b4d7-4887-b6ca-fc6bb99915a9&quot;,&quot;parentUUID&quot;:&quot;572fff1c-fc7a-4aa8-8a3b-040ad55baee5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with signature for wrong target address&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with signature for wrong target address&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:87,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Generate signature for different target address than what we execute\nconst wrongTarget = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: wrongTarget, // Sign for wrong target\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress, // Execute with original target, not the signed target\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;); // Should fail because target doesn&#x27;t match signature&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c3988abe-3ba3-4155-8229-0df651ec5d02&quot;,&quot;parentUUID&quot;:&quot;572fff1c-fc7a-4aa8-8a3b-040ad55baee5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should execute with zero value transaction&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should execute with zero value transaction&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4380,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Test successful execution with zero value\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nconst response = await client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n    value: 0, // Explicitly set zero value\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0b08d7d3-5034-4e5f-a8a0-bc28d53b3c0b&quot;,&quot;parentUUID&quot;:&quot;572fff1c-fc7a-4aa8-8a3b-040ad55baee5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;56a19a8e-91c6-4784-932b-b39b7857685e&quot;,&quot;e43a02a4-3398-4f77-87af-416e08ca473e&quot;,&quot;905f41a4-5752-4b70-9150-e55f8b8c4045&quot;,&quot;04605070-6842-46be-bee7-f937a1bd47a5&quot;,&quot;80bbf140-98b6-4b64-bda1-6debee6524b2&quot;,&quot;e73ab552-e9bd-4c0d-80bd-579520152275&quot;,&quot;9b929925-b766-4bfc-bb61-950c9b15e810&quot;,&quot;db6738c8-b4d7-4887-b6ca-fc6bb99915a9&quot;,&quot;c3988abe-3ba3-4155-8229-0df651ec5d02&quot;,&quot;0b08d7d3-5034-4e5f-a8a0-bc28d53b3c0b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:9308,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;9a522a15-2169-4c68-a1b8-5b9edda9b449&quot;,&quot;title&quot;:&quot;getIpAccountNonce&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully return account nonce&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getIpAccountNonce should successfully return account nonce&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:48,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.ipAccount.getIpAccountNonce(ipId);\n(0, chai_1.expect)(response).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3e85d528-283a-4d5a-9b50-a0fa072b472c&quot;,&quot;parentUUID&quot;:&quot;9a522a15-2169-4c68-a1b8-5b9edda9b449&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid ipId&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getIpAccountNonce should fail with invalid ipId&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:48,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.getIpAccountNonce(\&quot;0x0000000000000000000000000000000000000000\&quot;))\n    .to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bae90181-9cc8-4be7-85b9-6012e8d7ced3&quot;,&quot;parentUUID&quot;:&quot;9a522a15-2169-4c68-a1b8-5b9edda9b449&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;3e85d528-283a-4d5a-9b50-a0fa072b472c&quot;,&quot;bae90181-9cc8-4be7-85b9-6012e8d7ced3&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:96,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;cf595b47-baf5-4187-8e82-4250ff2e87c1&quot;,&quot;title&quot;:&quot;getToken&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully return token information&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getToken should successfully return token information&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:43,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.ipAccount.getToken(ipId);\n(0, chai_1.expect)(response.chainId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(response.tokenContract).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.tokenId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(response.tokenContract).to.equal(util_1.mockERC721);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f14c6666-66ec-4958-a8ef-87e9ae142334&quot;,&quot;parentUUID&quot;:&quot;cf595b47-baf5-4187-8e82-4250ff2e87c1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid ipId&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getToken should fail with invalid ipId&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:52,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.getToken(\&quot;0x0000000000000000000000000000000000000000\&quot;)).to.be\n    .rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4bab8582-45e9-4004-91cb-b9a41ba68e9a&quot;,&quot;parentUUID&quot;:&quot;cf595b47-baf5-4187-8e82-4250ff2e87c1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;f14c6666-66ec-4958-a8ef-87e9ae142334&quot;,&quot;4bab8582-45e9-4004-91cb-b9a41ba68e9a&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:95,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;a88ba554-6f87-49ce-95d3-df742043289a&quot;,&quot;caba13a9-c2d0-4653-adca-43b76005db5e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:22092,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;3ae1d0e1-49d5-41b6-ad2b-5ea5878bc59c&quot;,&quot;title&quot;:&quot;IP Asset Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;IP Asset Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions \&quot;before all\&quot; hook in \&quot;IP Asset Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:43,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst res = await client.license.registerPILTerms(src_1.PILFlavor.nonCommercialSocialRemixing());\nnoCommercialLicenseTermsId = res.licenseTermsId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;79a1c58a-f571-4d39-b379-8e2ae79f9247&quot;,&quot;parentUUID&quot;:&quot;3ae1d0e1-49d5-41b6-ad2b-5ea5878bc59c&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;953ab777-223f-435d-b7ac-07578285da48&quot;,&quot;title&quot;:&quot;Basic IP Asset Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register an IP Asset&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register an IP Asset&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8695,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nchildIpId = response.ipId;\n(0, chai_1.expect)(childIpId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5e4dbf55-5627-459f-8cdf-e1fefeea8902&quot;,&quot;parentUUID&quot;:&quot;953ab777-223f-435d-b7ac-07578285da48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register an IP Asset with multiple metadata fields&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register an IP Asset with multiple metadata fields&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8808,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    ipMetadata: {\n        ipMetadataURI: \&quot;ipfs://test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataURI: \&quot;ipfs://test-nft-uri\&quot;,\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\nchildIpId2 = response.ipId;\n(0, chai_1.expect)(response.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;28c37177-7178-493c-b78d-4c6ed4c26a29&quot;,&quot;parentUUID&quot;:&quot;953ab777-223f-435d-b7ac-07578285da48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should not register with invalid metadata hash length&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should not register with invalid metadata hash length&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4458,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    ipMetadata: {\n        ipMetadataHash: \&quot;0x123\&quot;, // Invalid length hash\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;valid-hash\&quot;, { size: 32 }),\n    },\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b9e7de58-18db-42c7-8a24-f5c4d470e7d8&quot;,&quot;parentUUID&quot;:&quot;953ab777-223f-435d-b7ac-07578285da48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should not register with non-existent token ID&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should not register with non-existent token ID&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:134,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: BigInt(Number.MAX_SAFE_INTEGER),\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6357e13d-eb2b-4ab8-aff3-e9ae3f42fd8c&quot;,&quot;parentUUID&quot;:&quot;953ab777-223f-435d-b7ac-07578285da48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with Non-Commercial Remix PIL&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with Non-Commercial Remix PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17972,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nparentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [noCommercialLicenseTermsId],\n    maxMintingFee: 0,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: 0.32423,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8bd1a2eb-a892-4ebc-9ad1-c55b49b52ba9&quot;,&quot;parentUUID&quot;:&quot;953ab777-223f-435d-b7ac-07578285da48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with Commercial Remix PIL&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with Commercial Remix PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30714,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Register commercial remix PIL\nconst licenseResponse = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 10n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n}));\n// Register parent IP\nconst tokenId = await (0, util_1.getTokenId)();\nconst commercialParentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// Attach license terms to parent IP\nawait client.license.attachLicenseTerms({\n    ipId: commercialParentIpId,\n    licenseTermsId: licenseResponse.licenseTermsId,\n});\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: childIpId2,\n    parentIpIds: [commercialParentIpId],\n    licenseTermsIds: [licenseResponse.licenseTermsId],\n    maxMintingFee: 100,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: 10,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bced9883-82ed-40b3-9d7f-c0995abb5cf7&quot;,&quot;parentUUID&quot;:&quot;953ab777-223f-435d-b7ac-07578285da48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with multiple parent IPs&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with multiple parent IPs&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:40110,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create first parent IP\nconst tokenId1 = await (0, util_1.getTokenId)();\nconst parentIpId1 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n})).ipId;\n// Create second parent IP\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst parentIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId2,\n})).ipId;\n// Attach license terms to both parents\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId1,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId2,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\n// Create child IP\nconst childTokenId = await (0, util_1.getTokenId)();\nconst newChildIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId,\n})).ipId;\n// Register derivative with multiple parents\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: newChildIpId,\n    parentIpIds: [parentIpId1, parentIpId2],\n    licenseTermsIds: [noCommercialLicenseTermsId, noCommercialLicenseTermsId],\n    maxMintingFee: 0,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: 0.9999999999,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;92f8ed23-d9ae-43ea-a1de-a6fdff3e052b&quot;,&quot;parentUUID&quot;:&quot;953ab777-223f-435d-b7ac-07578285da48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:21788,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst ipId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: noCommercialLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 1,\n});\nconst response = await client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c8acc080-08c7-41ee-ab78-26facf26bad0&quot;,&quot;parentUUID&quot;:&quot;953ab777-223f-435d-b7ac-07578285da48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should return true if IP asset is registered&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should return true if IP asset is registered&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:42,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const isRegistered = await client.ipAsset.isRegistered(parentIpId);\n(0, chai_1.expect)(isRegistered).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f533dc68-06f6-45eb-b4b5-38aaa9029f03&quot;,&quot;parentUUID&quot;:&quot;953ab777-223f-435d-b7ac-07578285da48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should return false if IP asset is not registered&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should return false if IP asset is not registered&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:43,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const isRegistered = await client.ipAsset.isRegistered(\&quot;0x1234567890123456789012345678901234567890\&quot;);\n(0, chai_1.expect)(isRegistered).to.equal(false);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9a4eabc7-44d5-4371-85ca-47e44d5e7925&quot;,&quot;parentUUID&quot;:&quot;953ab777-223f-435d-b7ac-07578285da48&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;5e4dbf55-5627-459f-8cdf-e1fefeea8902&quot;,&quot;28c37177-7178-493c-b78d-4c6ed4c26a29&quot;,&quot;b9e7de58-18db-42c7-8a24-f5c4d470e7d8&quot;,&quot;6357e13d-eb2b-4ab8-aff3-e9ae3f42fd8c&quot;,&quot;8bd1a2eb-a892-4ebc-9ad1-c55b49b52ba9&quot;,&quot;bced9883-82ed-40b3-9d7f-c0995abb5cf7&quot;,&quot;92f8ed23-d9ae-43ea-a1de-a6fdff3e052b&quot;,&quot;c8acc080-08c7-41ee-ab78-26facf26bad0&quot;,&quot;f533dc68-06f6-45eb-b4b5-38aaa9029f03&quot;,&quot;9a4eabc7-44d5-4371-85ca-47e44d5e7925&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:132764,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;title&quot;:&quot;SPG NFT Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;SPG NFT Operations\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations \&quot;before all\&quot; hook in \&quot;SPG NFT Operations\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13557,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Setup NFT collection\nconst txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\n// Setup license terms\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContract,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];\n// Setup ERC20\nconst mockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\nawait mockERC20.approve(generated_1.derivativeWorkflowsAddress[util_1.aeneid], viem_1.maxUint256);\nawait mockERC20.approve(generated_1.royaltyTokenDistributionWorkflowsAddress[util_1.aeneid], viem_1.maxUint256);\nawait mockERC20.mint(util_1.TEST_WALLET_ADDRESS, 100000n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ed2b9c64-76c6-413c-a1e7-24345647eaf7&quot;,&quot;parentUUID&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register IP Asset with metadata&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP Asset with metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12973,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst response = await client.ipAsset.register({\n    nftContract,\n    tokenId,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(response.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;75a46f07-bbd4-454e-b6dc-4d23a3eb2f9d&quot;,&quot;parentUUID&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative IP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register derivative IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13260,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenChildId = await (0, util_1.mintBySpg)(nftContract);\nconst result = await client.ipAsset.registerDerivativeIp({\n    nftContract: nftContract,\n    tokenId: tokenChildId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 0,\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2bf391fe-94c2-4c2f-a49e-aa0b1a667795&quot;,&quot;parentUUID&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach PIL terms&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach PIL terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9296,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: nftContract,\n    tokenId,\n    deadline: 1000n,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.commercialUse({\n                defaultMintingFee: 10000n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 10000n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bbbf713c-7481-43a0-94e4-4eff4d85ac0d&quot;,&quot;parentUUID&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach PIL terms with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach PIL terms with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13471,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 10000n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9b473d26-26b3-4ba9-af2f-cc8bb14008c0&quot;,&quot;parentUUID&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and make derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and make derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4885,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;840402b0-5226-4db2-b437-ee8a5a1e1869&quot;,&quot;parentUUID&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4519,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: nftContract,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    allowDuplicates: false,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;75258ec1-bd79-4ead-ab05-31949ed7a942&quot;,&quot;parentUUID&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and make derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and make derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:21545,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: nftContract,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1af98ced-b2ba-4c68-b663-e0bb669abd44&quot;,&quot;parentUUID&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and make derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and make derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17848,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerIpAndMakeDerivativeWithLicenseTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e3f80b6f-e16d-44a0-99c6-8c40606ffec9&quot;,&quot;parentUUID&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach license terms and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14221,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 10,\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 0.00020302,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8cef905d-c841-4349-8e78-ada2adfc8799&quot;,&quot;parentUUID&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach license terms and distribute royalty tokens with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14537,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 12.232131,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d1ff4d9a-29dd-447b-a13e-d46be10b3915&quot;,&quot;parentUUID&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach license terms and distribute royalty tokens with complex royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens with complex royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17743,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: generated_1.erc20Address[util_1.aeneid],\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 43.000301,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 17.0003011,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 2.000301,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 32.0003012,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d9459e5b-f38c-4103-a07c-98fc6e891c6d&quot;,&quot;parentUUID&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative and attach license terms and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register derivative and attach license terms and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17745,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 0,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;74b389e2-b498-4ead-8648-17bd84da8f65&quot;,&quot;parentUUID&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and attach PIL terms and distribute royalty tokens without licensing config&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and attach PIL terms and distribute royalty tokens without licensing config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8978,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: nftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.2,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8401afdb-8119-4bb7-b627-5cc30a3c5b82&quot;,&quot;parentUUID&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and attach PIL terms and distribute royalty tokens with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and attach PIL terms and distribute royalty tokens with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5561,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: nftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            maxLicenseTokens: 100,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 11n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.434,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(3);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c5768c0b-78e3-4c2b-9cfd-cf0ef535e2c8&quot;,&quot;parentUUID&quot;:&quot;55baf708-ed57-494f-8cc6-0d6af0bdbacd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;75a46f07-bbd4-454e-b6dc-4d23a3eb2f9d&quot;,&quot;2bf391fe-94c2-4c2f-a49e-aa0b1a667795&quot;,&quot;bbbf713c-7481-43a0-94e4-4eff4d85ac0d&quot;,&quot;9b473d26-26b3-4ba9-af2f-cc8bb14008c0&quot;,&quot;840402b0-5226-4db2-b437-ee8a5a1e1869&quot;,&quot;75258ec1-bd79-4ead-ab05-31949ed7a942&quot;,&quot;1af98ced-b2ba-4c68-b663-e0bb669abd44&quot;,&quot;e3f80b6f-e16d-44a0-99c6-8c40606ffec9&quot;,&quot;8cef905d-c841-4349-8e78-ada2adfc8799&quot;,&quot;d1ff4d9a-29dd-447b-a13e-d46be10b3915&quot;,&quot;d9459e5b-f38c-4103-a07c-98fc6e891c6d&quot;,&quot;74b389e2-b498-4ead-8648-17bd84da8f65&quot;,&quot;8401afdb-8119-4bb7-b627-5cc30a3c5b82&quot;,&quot;c5768c0b-78e3-4c2b-9cfd-cf0ef535e2c8&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:176582,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;ecaf1984-f69e-48e5-a428-98348b8abced&quot;,&quot;title&quot;:&quot;SPG With Minting Fees with Public Minting SPG NFT Contract&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;SPG With Minting Fees with Public Minting SPG NFT Contract\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract \&quot;before all\&quot; hook in \&quot;SPG With Minting Fees with Public Minting SPG NFT Contract\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13700,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// ensure we start with no wip since we will be wrapping them\nconst wipBalance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nif (wipBalance &gt; 0n) {\n    await client.wipClient.withdraw({\n        amount: wipBalance,\n    });\n}\n// create a nft collection that requires minting fee\nconst rsp = await client.nftClient.createNFTCollection({\n    name: \&quot;Premium Collection\&quot;,\n    symbol: \&quot;PC\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 100n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nnftContractWithMintingFee = rsp.spgNftContract;\n// create parent ip with minting fee\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContractWithMintingFee,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 150n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: true,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: BigInt(0),\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: BigInt(0),\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 150n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a6fd3e48-ce3f-4827-ba73-fbca56132b09&quot;,&quot;parentUUID&quot;:&quot;ecaf1984-f69e-48e5-a428-98348b8abced&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should auto wrap ip when mint and register derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5289,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const userBalanceBefore = await client.getWalletBalance();\nconst rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContractWithMintingFee, // pay 100 here\n    derivData: {\n        parentIpIds: [parentIpId], // pay 150 here\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test\&quot;,\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \&quot;test\&quot;,\n        nftMetadataHash: viem_1.zeroHash,\n    },\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);\nconst userBalanceAfter = await client.getWalletBalance();\nconst cost = 150n + 100n;\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - cost));\n// user should not have any WIP tokens since we swap the exact amount\nconst wipBalance = await client.ipAsset.wipClient.balanceOf({\n    owner: util_1.TEST_WALLET_ADDRESS,\n});\n(0, chai_1.expect)(wipBalance.result).to.be.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0d1fc34f-b5b2-4658-9222-7560608358a6&quot;,&quot;parentUUID&quot;:&quot;ecaf1984-f69e-48e5-a428-98348b8abced&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto wrap ip when mint and register derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30713,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nconst { txHash, ipId } = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: nftContractWithMintingFee,\n    licenseTokenIds: licenseTokenIds,\n    maxRts: 0,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test\&quot;,\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \&quot;test\&quot;,\n        nftMetadataHash: viem_1.zeroHash,\n    },\n});\n(0, chai_1.expect)(txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(ipId).to.be.a(\&quot;string\&quot;);\nconst isRegistered = await client.ipAsset.isRegistered(ipId);\n(0, chai_1.expect)(isRegistered).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;71fea940-f436-43f4-bfb0-5b47f98c9202&quot;,&quot;parentUUID&quot;:&quot;ecaf1984-f69e-48e5-a428-98348b8abced&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto wrap ip when registering derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when registering derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17806,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst balanceBefore = await client.getWalletBalance();\nconst rsp = await client.ipAsset.registerDerivativeIp({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 150n));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b805c926-f217-4443-8bc5-570381e8cea6&quot;,&quot;parentUUID&quot;:&quot;ecaf1984-f69e-48e5-a428-98348b8abced&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should spend existing wip when register derivative and distribute loyalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should spend existing wip when register derivative and distribute loyalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18088,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nawait client.wipClient.deposit({\n    amount: 150n,\n});\nconst rsp = await client.ipAsset.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 4.000301,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.be.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b1aface2-14f2-49df-8e19-59969af58cf0&quot;,&quot;parentUUID&quot;:&quot;ecaf1984-f69e-48e5-a428-98348b8abced&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto wrap ip when mint and register derivative and distribute loyalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative and distribute loyalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5104,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens({\n    spgNftContract: nftContractWithMintingFee,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test\&quot;,\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \&quot;test\&quot;,\n        nftMetadataHash: viem_1.zeroHash,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 0.34343234234,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7ca77c7a-16f3-4d8a-bb1b-2838e25e5373&quot;,&quot;parentUUID&quot;:&quot;ecaf1984-f69e-48e5-a428-98348b8abced&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;0d1fc34f-b5b2-4658-9222-7560608358a6&quot;,&quot;71fea940-f436-43f4-bfb0-5b47f98c9202&quot;,&quot;b805c926-f217-4443-8bc5-570381e8cea6&quot;,&quot;b1aface2-14f2-49df-8e19-59969af58cf0&quot;,&quot;7ca77c7a-16f3-4d8a-bb1b-2838e25e5373&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:77000,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;1fc94bbd-56bc-44d9-bac6-02670592adfa&quot;,&quot;title&quot;:&quot;IP Asset Registration with Private Minting SPG NFT Contracts&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;IP Asset Registration with Private Minting SPG NFT Contracts\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts \&quot;before all\&quot; hook in \&quot;IP Asset Registration with Private Minting SPG NFT Contracts\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4310,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;Private Minting Collection\&quot;,\n    symbol: \&quot;PMC\&quot;,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 3n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \&quot;\&quot;,\n});\nspgNftContractWithPrivateMinting = privateMintingCollectionResult.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;26382d6e-da0c-480a-a6a3-5f0671e523a5&quot;,&quot;parentUUID&quot;:&quot;1fc94bbd-56bc-44d9-bac6-02670592adfa&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when call mint and register ip asset with pil terms&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip asset with pil terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13810,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 6n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                commercialRevShare: 90,\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;19397f3b-918a-4bff-8d7b-91c79235547a&quot;,&quot;parentUUID&quot;:&quot;1fc94bbd-56bc-44d9-bac6-02670592adfa&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip asset with pil terms with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip asset with pil terms with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9870,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 5n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 5n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n    ipMetadata: {\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3ece7855-f910-460d-b18b-7009eda288bb&quot;,&quot;parentUUID&quot;:&quot;1fc94bbd-56bc-44d9-bac6-02670592adfa&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip and make derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and make derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9422,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 100n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e42cfb77-0f11-44bc-b3e9-3611ef7db36e&quot;,&quot;parentUUID&quot;:&quot;1fc94bbd-56bc-44d9-bac6-02670592adfa&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8990,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    allowDuplicates: false,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a4a3b540-6064-4815-b6a6-6bc75aff1277&quot;,&quot;parentUUID&quot;:&quot;1fc94bbd-56bc-44d9-bac6-02670592adfa&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip and make derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and make derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18066,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst licenseTokenId = mintLicenseTokensResult.licenseTokenIds[0];\nconst result = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    licenseTokenIds: [licenseTokenId],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;412b92db-c761-4a3f-b37f-efc0d25381a1&quot;,&quot;parentUUID&quot;:&quot;1fc94bbd-56bc-44d9-bac6-02670592adfa&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip and attach pil terms and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and attach pil terms and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9309,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.434,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bd9a0bfd-dc9e-4b92-b048-0218a049f30b&quot;,&quot;parentUUID&quot;:&quot;1fc94bbd-56bc-44d9-bac6-02670592adfa&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should succeed when call mint and register ip and make derivative and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should succeed when call mint and register ip and make derivative and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22709,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: true,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\nconst newParentIpId = result.ipId;\nconst licenseId = result.licenseTermsIds[0];\nconst rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    derivData: {\n        parentIpIds: [newParentIpId],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.434,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e5fd422f-7301-40cc-8351-6f98b92b00e2&quot;,&quot;parentUUID&quot;:&quot;1fc94bbd-56bc-44d9-bac6-02670592adfa&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;19397f3b-918a-4bff-8d7b-91c79235547a&quot;,&quot;3ece7855-f910-460d-b18b-7009eda288bb&quot;,&quot;e42cfb77-0f11-44bc-b3e9-3611ef7db36e&quot;,&quot;a4a3b540-6064-4815-b6a6-6bc75aff1277&quot;,&quot;412b92db-c761-4a3f-b37f-efc0d25381a1&quot;,&quot;bd9a0bfd-dc9e-4b92-b048-0218a049f30b&quot;,&quot;e5fd422f-7301-40cc-8351-6f98b92b00e2&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:92176,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;71391176-5533-4a18-b77e-9daf486500b4&quot;,&quot;title&quot;:&quot;Batch Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Batch Operations\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations \&quot;before all\&quot; hook in \&quot;Batch Operations\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13269,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\nconst tokenId = await (0, util_1.getTokenId)();\nparentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9d502bcd-79db-493c-a3a2-f2ea6dafd8f0&quot;,&quot;parentUUID&quot;:&quot;71391176-5533-4a18-b77e-9daf486500b4&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should batch register derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch register derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30867,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const childTokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId,\n})).ipId;\nconst childTokenId2 = await (0, util_1.getTokenId)();\nconst childIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId2,\n})).ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nconst result = await client.ipAsset.batchRegisterDerivative({\n    args: [\n        {\n            childIpId: childIpId,\n            parentIpIds: [parentIpId],\n            licenseTermsIds: [noCommercialLicenseTermsId],\n        },\n        {\n            childIpId: childIpId2,\n            parentIpIds: [parentIpId],\n            licenseTermsIds: [noCommercialLicenseTermsId],\n            maxMintingFee: 10000000,\n            maxRts: 5 * 10 ** 6,\n            maxRevenueShare: 0,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;06bc2ca9-1f2a-4b3d-be6a-82678be8bca4&quot;,&quot;parentUUID&quot;:&quot;71391176-5533-4a18-b77e-9daf486500b4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should batch mint and register IP asset with PIL terms&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch mint and register IP asset with PIL terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9361,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.batchMintAndRegisterIpAssetWithPilTerms({\n    args: [\n        {\n            spgNftContract: nftContract,\n            licenseTermsData: [\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 8n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \&quot;\&quot;,\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 8n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                    maxLicenseTokens: 100,\n                },\n                {\n                    terms: src_1.PILFlavor.commercialRemix({\n                        defaultMintingFee: 100n,\n                        commercialRevShare: 10,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                    }),\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 100n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                },\n            ],\n        },\n        {\n            spgNftContract: nftContract,\n            licenseTermsData: [\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 8n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \&quot;\&quot;,\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 8n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                    maxLicenseTokens: 100,\n                },\n            ],\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.results).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.results[0].licenseTermsIds).to.be.an(\&quot;array\&quot;).and.length(2);\n(0, chai_1.expect)(result.results[0].maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;).and.length(1);\n(0, chai_1.expect)(result.results[1].licenseTermsIds).to.be.an(\&quot;array\&quot;).and.length(1);\n(0, chai_1.expect)(result.results[1].maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;).and.length(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c6041029-3b9c-461b-8a70-613adbdd2ad3&quot;,&quot;parentUUID&quot;:&quot;71391176-5533-4a18-b77e-9daf486500b4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should batch mint and register IP asset and make derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch mint and register IP asset and make derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4967,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract: nftContract,\n            derivData: {\n                parentIpIds: [parentIpId],\n                licenseTermsIds: [noCommercialLicenseTermsId],\n                maxMintingFee: 0,\n                maxRts: 5 * 10 ** 6,\n                maxRevenueShare: 0,\n            },\n        },\n        {\n            spgNftContract: nftContract,\n            derivData: {\n                parentIpIds: [parentIpId],\n                licenseTermsIds: [noCommercialLicenseTermsId],\n                maxMintingFee: 0,\n                maxRts: 5 * 10 ** 6,\n                maxRevenueShare: 0,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.results).to.be.an(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7560d4c2-04dc-40ec-af79-cb27ebd119c9&quot;,&quot;parentUUID&quot;:&quot;71391176-5533-4a18-b77e-9daf486500b4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should batch register giving parameters&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch register giving parameters&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30311,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst spgTokenId1 = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst spgTokenId2 = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId,\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2,\n        },\n        {\n            nftContract,\n            tokenId: spgTokenId1,\n            ipMetadata: {\n                ipMetadataURI: \&quot;test-uri2\&quot;,\n                ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash2\&quot;, { size: 32 }),\n                nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash2\&quot;, { size: 32 }),\n            },\n        },\n        {\n            nftContract,\n            tokenId: spgTokenId2,\n            ipMetadata: {\n                ipMetadataURI: \&quot;test-uri\&quot;,\n                ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n                nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.results).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;62f215bc-7247-440f-952e-d4cab7f4f1c6&quot;,&quot;parentUUID&quot;:&quot;71391176-5533-4a18-b77e-9daf486500b4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;06bc2ca9-1f2a-4b3d-be6a-82678be8bca4&quot;,&quot;c6041029-3b9c-461b-8a70-613adbdd2ad3&quot;,&quot;7560d4c2-04dc-40ec-af79-cb27ebd119c9&quot;,&quot;62f215bc-7247-440f-952e-d4cab7f4f1c6&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:75506,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;e963dad1-2ef4-4007-9b4a-9aaec03873c5&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Error Cases\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Error Cases \&quot;before all\&quot; hook in \&quot;Error Cases\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4320,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d277f9b6-f6df-46d3-9505-d2e656adc8e1&quot;,&quot;parentUUID&quot;:&quot;e963dad1-2ef4-4007-9b4a-9aaec03873c5&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should fail to register unowned NFT&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Error Cases should fail to register unowned NFT&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:137,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: nftContract,\n    tokenId: 999999n, // Non-existent token\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;21472373-c760-490f-91d1-2a545b13ce86&quot;,&quot;parentUUID&quot;:&quot;e963dad1-2ef4-4007-9b4a-9aaec03873c5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;21472373-c760-490f-91d1-2a545b13ce86&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:137,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;19549440-a135-4f82-865f-cdc8552ee726&quot;,&quot;title&quot;:&quot;Other Edge Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Other Edge Cases\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases \&quot;before all\&quot; hook in \&quot;Other Edge Cases\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13164,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst parentIpResponse = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nparentIpId = parentIpResponse.ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;38b92cfe-1de7-4ec9-9968-91bfd568d96a&quot;,&quot;parentUUID&quot;:&quot;19549440-a135-4f82-865f-cdc8552ee726&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;dea3612b-9123-42c7-81eb-583afdb63324&quot;,&quot;title&quot;:&quot;License Token Edge Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should fail when trying to use non-existent license token&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases License Token Edge Cases should fail when trying to use non-existent license token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8781,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId,\n    })).ipId,\n    licenseTokenIds: [BigInt(999999)], // Non-existent token\n    maxRts: 5 * 10 ** 6,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3e081a7f-2d64-4d8b-be8e-cf422ebb6cbe&quot;,&quot;parentUUID&quot;:&quot;dea3612b-9123-42c7-81eb-583afdb63324&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to use same license token twice&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases License Token Edge Cases should fail when trying to use same license token twice&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:26455,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: noCommercialLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 1,\n});\nconst tokenId1 = await (0, util_1.getTokenId)();\nawait client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n    })).ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 0,\n});\nconst tokenId2 = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n    })).ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n})).to.be.rejected; // Should fail as token already used&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;594e02b9-3257-4cf9-812c-dda5a7b5475a&quot;,&quot;parentUUID&quot;:&quot;dea3612b-9123-42c7-81eb-583afdb63324&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;3e081a7f-2d64-4d8b-be8e-cf422ebb6cbe&quot;,&quot;594e02b9-3257-4cf9-812c-dda5a7b5475a&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:35236,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;88773446-a0bb-4a4c-83ae-b628f4280293&quot;,&quot;title&quot;:&quot;Batch Operation Edge Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should handle partial failures in batch registration&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases Batch Operation Edge Cases should handle partial failures in batch registration&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13321,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nawait client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n});\nawait (0, chai_1.expect)(client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId1, // Already registered\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2, // New registration\n        },\n    ],\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9d74d28e-326a-4a98-9d19-d6a2bf25f7f8&quot;,&quot;parentUUID&quot;:&quot;88773446-a0bb-4a4c-83ae-b628f4280293&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;9d74d28e-326a-4a98-9d19-d6a2bf25f7f8&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13321,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;c365af1e-49cd-4504-a543-9e87fb849320&quot;,&quot;title&quot;:&quot;Batch Register IP Assets With Optimized Workflows&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Batch Register IP Assets With Optimized Workflows\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows \&quot;before all\&quot; hook in \&quot;Batch Register IP Assets With Optimized Workflows\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:39673,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create a public minting NFT collection\nconst publicMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;Public Minting Collection\&quot;,\n    symbol: \&quot;PMC\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \&quot;\&quot;,\n});\nspgNftContractWithPublicMintingWithWip = publicMintingCollectionResult.spgNftContract;\n// Create a private minting NFT collection\nconst privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;Private Minting Collection\&quot;,\n    symbol: \&quot;PRC\&quot;,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: generated_1.erc20Address[util_1.aeneid],\n    contractURI: \&quot;\&quot;,\n});\nspgNftContractWithPrivateMintingWithErc20 = privateMintingCollectionResult.spgNftContract;\n// Register a commercial remix PIL license\nconst commercialRemixPILResult = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 10n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n}));\nlicenseTermsIdWithWIP = commercialRemixPILResult.licenseTermsId;\n// Register a commercial use PIL license\nconst commercialUsePILResult = await client.license.registerPILTerms({\n    transferable: true,\n    royaltyPolicy: \&quot;0xBe54FB168b3c982b7AaE60dB6CF75Bd8447b390E\&quot;,\n    defaultMintingFee: 5n,\n    expiration: 0n,\n    commercialUse: true,\n    commercialAttribution: true,\n    commercializerChecker: viem_1.zeroAddress,\n    commercializerCheckerData: viem_1.zeroAddress,\n    commercialRevShare: 10,\n    commercialRevCeiling: 0n,\n    derivativesAllowed: true,\n    derivativesAttribution: true,\n    derivativesApproval: false,\n    derivativesReciprocal: true,\n    derivativeRevCeiling: 0n,\n    currency: generated_1.erc20Address[util_1.aeneid],\n    uri: \&quot;https://github.com/piplabs/pil-document/blob/ad67bb632a310d2557f8abcccd428e4c9c798db1/off-chain-terms/CommercialRemix.json\&quot;,\n});\nlicenseTermsIdWithErc20 = commercialUsePILResult.licenseTermsId;\n// Mint and register IP with public minting contract\nconst publicMintingIpResult = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPublicMintingWithWip,\n});\nparentIpId1 = publicMintingIpResult.ipId;\n// Attach license terms to the first IP\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId1,\n    licenseTermsId: licenseTermsIdWithWIP,\n});\n// Mint and register IP with private minting contract\nconst privateMintingIpResult = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n});\nparentIpId2 = privateMintingIpResult.ipId;\n// Attach license terms to the second IP\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId2,\n    licenseTermsId: licenseTermsIdWithErc20,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a3c38d11-dea2-4fe3-b82d-a505cfdc821c&quot;,&quot;parentUUID&quot;:&quot;c365af1e-49cd-4504-a543-9e87fb849320&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully batch register multiple IP assets with SPG NFT contracts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully batch register multiple IP assets with SPG NFT contracts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:34979,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10 WIP tokens + 10 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15 WIP tokens + 5 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the ERC20 token is used\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 0 WIP tokens + 10 ERC20 tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall due to the private minting\n     * - Two license terms\n     * - `maxLicenseTokens` is set to 1000n for first license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 1000n,\n            },\n            {\n                terms: src_1.PILFlavor.commercialUse({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 3n,\n                    override: {\n                        commercialRevShare: 90,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesReciprocal: true,\n                        commercialAttribution: false,\n                    },\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 3n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     * - One license terms\n     * - `maxLicenseTokens` is set to 100n for license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 0n,\n                    commercialRevShare: 90,\n                    override: {\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesReciprocal: true,\n                        commercialAttribution: false,\n                    },\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 100n,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 20(10+10) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 3.000301,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10 ERC20 tokens +5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.434,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the mint tokens is given `msg.sender` as the recipient\n     * - Two license terms\n     * - `maxLicenseTokens` is set to 80n and 10n for license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                maxLicenseTokens: 80n,\n            },\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 100n,\n                    commercialRevShare: 0,\n                    override: {\n                        derivativesReciprocal: true,\n                        commercialAttribution: false,\n                        expiration: 1000n,\n                    },\n                }),\n                maxLicenseTokens: 10n,\n            },\n        ],\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 1.211,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens + 10 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the mint tokens is given `msg.sender` as the recipient\n     * - One license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.creativeCommonsAttribution({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    override: {\n                        defaultMintingFee: 10000n,\n                    },\n                }),\n            },\n        ],\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 1.231,\n            },\n        ],\n    },\n];\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\n/**\n * Transaction breakdown:\n *\n * 1. derivativeWorkflowsClient: 2 args\n *    - First arg:\n *      - 10WIP tokens +10 ERC20 tokens\n *    - Second arg:\n *      - 15WIP tokens + 5 ERC20 tokens\n *\n * 2. licenseAttachmentWorkflowsClient: 1 args\n *    - 10 ERC20 tokens\n *    - Two license terms attached\n *    - First license terms: maxLicenseTokens: 1000n\n *\n * 3. multicall3Client: 2 args\n *    - First arg:\n *      - 10 WIP tokens\n *      - One license terms\n *      - First license terms: maxLicenseTokens: 100n\n *    - Second arg:\n *      - 20 WIP tokens\n *\n * 3. multicall3Client: 2 args\n *    - First arg:\n *      - 10 WIP tokens\n *      - One license terms\n *      - First license terms: maxLicenseTokens: 100n\n *    - Second arg:\n *      - 20 WIP tokens\n *\n * 4. royaltyTokenDistributionWorkflowsClient: 3 args\n *    - First arg:\n *      - 10 ERC20+ 5 ERC20 tokens\n *    - Second arg:\n *      - 15 WIP tokens\n *      - Two license terms\n *      - First license terms: maxLicenseTokens: 80n\n *      - Second license terms: maxLicenseTokens: 10n\n *    - Third arg:\n *      - 10 ERC20 tokens\n *      - One license terms\n *\n * Summary:\n * - Total transactions: 4 (4 unique transaction hashes)\n * - Total IP assets registered: 8\n */\nconst totalFeesForWIP = 10 + 15 + 10 + 20 + 15;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFeesForWIP)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(4);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes).equal(undefined);\n// Derivative workflow\n// First arg\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(undefined);\n// Second arg\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(undefined);\n// license attachment workflow\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n// multicall3 workflow\n// First arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(2);\n// First arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n// Second arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(undefined);\n// royalty token distribution workflow\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(3);\n// First arg\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(undefined);\n// Second arg\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(2);\n// Third arg\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(undefined);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;445e1a99-932b-4043-8dc7-d9136301c86f&quot;,&quot;parentUUID&quot;:&quot;c365af1e-49cd-4504-a543-9e87fb849320&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully batch register multiple IP assets with NFT contracts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully batch register multiple IP assets with NFT contracts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:68691,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst tokenId4 = await (0, util_1.getTokenId)();\nconst tokenId5 = await (0, util_1.getTokenId)();\nconst tokenId6 = await (0, util_1.getTokenId)();\nconst tokenId7 = await (0, util_1.getTokenId)();\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst requests = [\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerIpAndAttachPilTerms  workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall\n     * - Two license terms\n     * - `maxLicenseTokens` is set to 100n for second license terms\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId3,\n        deadline: 1000n,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 0n,\n                    commercialRevShare: 100,\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 10000n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 100n,\n            },\n        ],\n    },\n    /**\n     * registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Two license terms\n     * - Need to distribute royalty tokens\n     * - `maxLicenseTokens` is set to 10n for first license terms\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId4,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 1n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n            {\n                terms: src_1.PILFlavor.creativeCommonsAttribution({\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 6n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n        ],\n        ipMetadata: {\n            ipMetadataURI: \&quot;test-uri\&quot;,\n            ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n            nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 43.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 17.0003011,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 2.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 30.0003012,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId5,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId6,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId7,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.434,\n            },\n        ],\n    },\n];\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\n/**\n * Transaction breakdown:\n * 1. royaltyTokenDistributionWorkflowsClient: 4 args\n *  - First arg:\n *    - 10 WIP tokens\n *    - Need to distribute royalty tokens\n *  - Second arg:\n *    - 5 ERC20 tokens\n *    - Need to distribute royalty tokens\n *  - Third arg:\n *    - 0 WIP tokens\n *    - Two license terms\n *    - First license terms: maxLicenseTokens: 10n\n *    - Need to distribute royalty tokens\n *  - Fourth arg:\n *    - 5 ERC20 tokens\n *    - Need to distribute royalty tokens\n * 2. licenseAttachmentWorkflowsClient: 1 arg\n *  - 0 WIP tokens\n *  - Two license terms\n *  - Second license terms: maxLicenseTokens: 100n\n * 3. derivativeWorkflowsClient: 2 args\n *  - First arg:\n *    - 5 ERC20 tokens\n *  - Second arg:\n *    - 10 WIP tokens\n *\n * Summary:\n * - Total transactions: 3 (3 unique transaction hashes)\n * - Total IP assets registered: 7\n */\nconst totalFees = 10 + 10;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(3);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).equal(1);\n// royaltyTokenDistributionWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(4);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[0].ipRoyaltyVault?.length).equal(4);\n// licenseAttachmentWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipRoyaltyVault?.length).equal(0);\n//derivativeWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipRoyaltyVault?.length).equal(0);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;564bd848-07d5-4f87-aa4b-d8b3c25b5644&quot;,&quot;parentUUID&quot;:&quot;c365af1e-49cd-4504-a543-9e87fb849320&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register IP assets using a combination of NFT contracts and SPG NFT contracts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully register IP assets using a combination of NFT contracts and SPG NFT contracts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:47565,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst tokenId4 = await (0, util_1.getTokenId)();\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10 WIP tokens +5 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall3 due to contains ERC20 token\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10 ERC20 tokens+ 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.434,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 20(10+10) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.4341111111,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10 ERC20 tokens+10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.2312332,\n            },\n        ],\n    },\n    /**\n     * registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     * - One license terms\n     * - `maxLicenseTokens` is set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 1n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n        ipMetadata: {\n            ipMetadataURI: \&quot;test-uri\&quot;,\n            ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n            nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 43.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 17.0003011,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 2.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 30.0003012,\n            },\n        ],\n    },\n    /**\n     * registerIpAndAttachPilTerms  workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall\n     * - Two license terms\n     * - The second request has `maxLicenseTokens` set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId3,\n        deadline: 1000n,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 0n,\n                    commercialRevShare: 100,\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 10000n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId4,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n];\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\n/**\n * Transaction breakdown:\n * 1. derivativeWorkflowsClient:3 args\n * - First arg\n *   - 10 WIP tokens+ 5 ERC20 tokens\n * - Second arg\n *   - 10 ERC20 + 10 WIP tokens\n * - Third arg\n *   - 10 WIP tokens\n *\n * 2. royaltyTokenDistributionWorkflowsClient: 3 args\n *  - First arg\n *    - 15 ERC20 tokens\n *  - Second arg\n *    - 5 ERC20 tokens\n *    - Need to distribute royalty tokens\n *  - Third arg\n *    - 0 WIP tokens\n *    - One license terms\n *    - First license terms: maxLicenseTokens: 10n\n *    - Need to distribute royalty tokens\n *\n * 3. licenseAttachmentWorkflowsClient: 1 arg\n * - 0 WIP tokens\n * - Two license terms\n * - Second license terms: maxLicenseTokens: 100n\n *\n * Summary:\n * - Total transactions: 4 (4 unique transaction hashes)\n * - Total IP assets registered: 8\n */\nconst totalFeesWithWIP = 10 + 10 + 10;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFeesWithWIP)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(4);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).equal(1);\n// derivativeWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[0].ipRoyaltyVault?.length).equal(0);\n// royaltyTokenDistributionWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipRoyaltyVault?.length).equal(2);\n//licenseAttachmentWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipRoyaltyVault?.length).equal(0);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;41be87d7-693e-44cd-8722-60e5b42aa6d9&quot;,&quot;parentUUID&quot;:&quot;c365af1e-49cd-4504-a543-9e87fb849320&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register IP assets with multicall disabled&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully register IP assets with multicall disabled&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:42279,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15(10+5) WIP tokens\n     * - Uses `derivativeWorkflowsClient` to call the this method\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` to call the this method\n     * - One license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` to call the this method\n     * - Two license terms\n     * - The first request has `maxLicenseTokens` set to 10n\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 10n,\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient`to call the this method\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.4341212321,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient`to call the this method\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 3.000301,\n            },\n        ],\n    },\n];\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n    options: {\n        wipOptions: {\n            useMulticallWhenPossible: false,\n        },\n    },\n});\n/**\n * Transaction breakdown:\n *  1. derivativeWorkflowsClient:1 arg\n *    - 15 WIP\n * 2. licenseAttachmentWorkflowsClient: 2 args\n *    - First arg\n *      - 0 WIP tokens\n *      - One license terms\n *    - Second arg\n *      - 10  WIP tokens\n *      - Two license terms\n *      - First license terms: maxLicenseTokens: 10n\n * 3. royaltyTokenDistributionWorkflowsClient: 2 args\n *    - First arg\n *      - 5 ERC20 tokens\n *      - Need to distribute royalty tokens\n *    - Second arg\n *      - 5 ERC20 tokens\n *      - Need to distribute royalty tokens\n * Summary:\n * - Total transactions: 5 (5 unique transaction hashes) due to the multicall disabled\n * - Total IP assets registered: 5\n * - Two distribute royalty tokens transactions\n */\nconst totalFees = 15 + 10;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(requests.length);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).equal(2);\n//derivativeWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipRoyaltyVault?.length).equal(0);\n//licenseAttachmentWorkflowsClient\n//First arg\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n//Second arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n//royaltyTokenDistributionWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipRoyaltyVault?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[4].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[4].ipRoyaltyVault?.length).equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;36abac78-6510-4a8a-9d92-797d2c4f68a0&quot;,&quot;parentUUID&quot;:&quot;c365af1e-49cd-4504-a543-9e87fb849320&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;445e1a99-932b-4043-8dc7-d9136301c86f&quot;,&quot;564bd848-07d5-4f87-aa4b-d8b3c25b5644&quot;,&quot;41be87d7-693e-44cd-8722-60e5b42aa6d9&quot;,&quot;36abac78-6510-4a8a-9d92-797d2c4f68a0&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:193514,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;8e691fb2-ddf2-4587-8a57-62ffe4ce14e6&quot;,&quot;title&quot;:&quot;Batch Mint and Register IP Asset&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Batch Mint and Register IP Asset\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset \&quot;before all\&quot; hook in \&quot;Batch Mint and Register IP Asset\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12874,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const publicMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContractWithPublicMinting = publicMintingCollectionResult.spgNftContract;\nconst privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 20n,\n    mintFeeToken: generated_1.erc20Address[util_1.aeneid],\n});\nspgNftContractWithPrivateMinting = privateMintingCollectionResult.spgNftContract;\nconst { address } = await (0, BIP32_1.getDerivedStoryClient)();\nanotherWalletAddress = address;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0b2ae30b-ce5f-4293-b461-e9b80b8b4501&quot;,&quot;parentUUID&quot;:&quot;8e691fb2-ddf2-4587-8a57-62ffe4ce14e6&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when public minting of spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should successfully when public minting of spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9107,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst { registrationResults } = await client.ipAsset.batchMintAndRegisterIp({\n    requests: [\n        { spgNftContract: spgNftContractWithPublicMinting },\n        { spgNftContract: spgNftContractWithPublicMinting, recipient: anotherWalletAddress },\n        { spgNftContract: spgNftContractWithPublicMinting, allowDuplicates: false },\n    ],\n});\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(registrationResults.length).equal(1);\n(0, chai_1.expect)(registrationResults[0].ipIdsAndTokenIds.length).equal(3);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1d4f4793-38c0-4cb1-b733-2c828f7e3784&quot;,&quot;parentUUID&quot;:&quot;8e691fb2-ddf2-4587-8a57-62ffe4ce14e6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when private minting of spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should successfully when private minting of spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13412,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst { registrationResults } = await client.ipAsset.batchMintAndRegisterIp({\n    requests: [\n        { spgNftContract: spgNftContractWithPrivateMinting },\n        { spgNftContract: spgNftContractWithPrivateMinting, recipient: anotherWalletAddress },\n        {\n            spgNftContract: spgNftContractWithPrivateMinting,\n            allowDuplicates: false,\n            recipient: anotherWalletAddress,\n        },\n    ],\n});\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(registrationResults.length).equal(1);\n(0, chai_1.expect)(registrationResults[0].ipIdsAndTokenIds.length).equal(3);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;78ba5479-24b3-41fe-a91b-0089b4d32541&quot;,&quot;parentUUID&quot;:&quot;8e691fb2-ddf2-4587-8a57-62ffe4ce14e6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when hybrid private minting and public minting of spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should successfully when hybrid private minting and public minting of spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9765,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst { registrationResults } = await client.ipAsset.batchMintAndRegisterIp({\n    requests: [\n        { spgNftContract: spgNftContractWithPublicMinting },\n        { spgNftContract: spgNftContractWithPrivateMinting, recipient: anotherWalletAddress },\n        { spgNftContract: spgNftContractWithPrivateMinting, allowDuplicates: false },\n        { spgNftContract: spgNftContractWithPublicMinting, recipient: anotherWalletAddress },\n    ],\n});\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(registrationResults.length).equal(2);\n(0, chai_1.expect)(registrationResults[0].ipIdsAndTokenIds.length).equal(2);\n(0, chai_1.expect)(registrationResults[1].ipIdsAndTokenIds.length).equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1edfdda9-f9ab-4c48-bf77-1b8ffa554a29&quot;,&quot;parentUUID&quot;:&quot;8e691fb2-ddf2-4587-8a57-62ffe4ce14e6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when private minting of spgNftContract but caller does not have the minter role&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should fail when private minting of spgNftContract but caller does not have the minter role&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4575,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Register a new SPG NFT contract with private minting with clientB\nconst { address, clientB } = await (0, BIP32_1.getDerivedStoryClient)();\nconst { spgNftContract: privateMintingContractOfClientB } = await clientB.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: address,\n    contractURI: \&quot;test-uri\&quot;,\n});\nawait (0, chai_1.expect)(client.ipAsset.batchMintAndRegisterIp({\n    requests: [{ spgNftContract: privateMintingContractOfClientB }],\n})).to.be.rejectedWith(\&quot;does not have the minter role\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1df676b4-0b15-4e3f-8387-7fc87e3a31f7&quot;,&quot;parentUUID&quot;:&quot;8e691fb2-ddf2-4587-8a57-62ffe4ce14e6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1d4f4793-38c0-4cb1-b733-2c828f7e3784&quot;,&quot;78ba5479-24b3-41fe-a91b-0089b4d32541&quot;,&quot;1edfdda9-f9ab-4c48-bf77-1b8ffa554a29&quot;,&quot;1df676b4-0b15-4e3f-8387-7fc87e3a31f7&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:36859,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;c8ebfe1b-fadd-4db4-a16d-c6ee1ba4412d&quot;,&quot;title&quot;:&quot;Register ip asset with minted and mint nft&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;e3222f8b-21eb-4d49-bc67-8ff0f7c6055f&quot;,&quot;title&quot;:&quot;Register IP Asset with Minted NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give license terms data and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when give license terms data and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13869,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 2.000000001,\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds.length).to.be.equal(1);\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;17b1bf54-70c7-4f3b-867a-b7e4926d77da&quot;,&quot;parentUUID&quot;:&quot;e3222f8b-21eb-4d49-bc67-8ff0f7c6055f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give license terms data without royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when give license terms data without royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9218,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d5da80c5-5d0e-4332-806b-0750d194d820&quot;,&quot;parentUUID&quot;:&quot;e3222f8b-21eb-4d49-bc67-8ff0f7c6055f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when without license terms data, royalty shares, ip metadata&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when without license terms data, royalty shares, ip metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8772,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4a80dc04-709c-4c82-869f-972377350eda&quot;,&quot;parentUUID&quot;:&quot;e3222f8b-21eb-4d49-bc67-8ff0f7c6055f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when without license terms data and royalty shares, with ip metadata&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when without license terms data and royalty shares, with ip metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8796,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataURI: \&quot;test-nft-uri\&quot;,\n    },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;42c008e2-2f3a-4b4a-89c9-9c251a08f5eb&quot;,&quot;parentUUID&quot;:&quot;e3222f8b-21eb-4d49-bc67-8ff0f7c6055f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;17b1bf54-70c7-4f3b-867a-b7e4926d77da&quot;,&quot;d5da80c5-5d0e-4332-806b-0750d194d820&quot;,&quot;4a80dc04-709c-4c82-869f-972377350eda&quot;,&quot;42c008e2-2f3a-4b4a-89c9-9c251a08f5eb&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:40655,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;700c4d41-fa75-434b-a933-332120e47704&quot;,&quot;title&quot;:&quot;Register IP Asset by minting a new NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Register IP Asset by minting a new NFT\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT \&quot;before all\&quot; hook in \&quot;Register IP Asset by minting a new NFT\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4381,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST_FOR_MINT\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;57f59712-5697-45a3-93f6-42e65f43176e&quot;,&quot;parentUUID&quot;:&quot;700c4d41-fa75-434b-a933-332120e47704&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give license terms data and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT should successfully when give license terms data and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18118,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgNftContract },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 0.000001,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;45418100-bbc9-43d1-ad8e-7b30441fcef1&quot;,&quot;parentUUID&quot;:&quot;700c4d41-fa75-434b-a933-332120e47704&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give license terms data without royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT should successfully when give license terms data without royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13944,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgNftContract },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1e41bd97-9100-4bae-afbe-0e88c2929e20&quot;,&quot;parentUUID&quot;:&quot;700c4d41-fa75-434b-a933-332120e47704&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when without license terms data and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT should successfully when without license terms data and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9093,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgNftContract },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataURI: \&quot;test-nft-uri\&quot;,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bafc33f8-c732-421a-b64a-e3e582ec1880&quot;,&quot;parentUUID&quot;:&quot;700c4d41-fa75-434b-a933-332120e47704&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;45418100-bbc9-43d1-ad8e-7b30441fcef1&quot;,&quot;1e41bd97-9100-4bae-afbe-0e88c2929e20&quot;,&quot;bafc33f8-c732-421a-b64a-e3e582ec1880&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:41155,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;6b25035c-2ff3-4d67-9109-b99e9b84ee60&quot;,&quot;title&quot;:&quot;Register derivative IP Asset&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Register derivative IP Asset\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset \&quot;before all\&quot; hook in \&quot;Register derivative IP Asset\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17226,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\nparentIpId = result.ipId;\ncommercialRemixLicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4bfad838-ab94-4bf0-8fb6-64e60a1dc7e9&quot;,&quot;parentUUID&quot;:&quot;6b25035c-2ff3-4d67-9109-b99e9b84ee60&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;fce48b2c-6b86-49b2-8d5d-6de0d5196500&quot;,&quot;title&quot;:&quot;Register derivative IP Asset with Minted NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give derivData and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset with Minted NFT should successfully when give derivData and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22185,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.equal(BigInt(tokenId));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b711330f-3031-4c2d-a4f4-b0a6b875a508&quot;,&quot;parentUUID&quot;:&quot;fce48b2c-6b86-49b2-8d5d-6de0d5196500&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully given derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset with Minted NFT should successfully given derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17601,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.equal(BigInt(tokenId));\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fabf92c4-d83a-4c58-abc0-763c1c1ffb24&quot;,&quot;parentUUID&quot;:&quot;fce48b2c-6b86-49b2-8d5d-6de0d5196500&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully given licenseTokenIds and maxRts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset with Minted NFT should successfully given licenseTokenIds and maxRts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17862,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: commercialRemixLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nconst tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    licenseTokenIds: licenseTokenIds,\n    maxRts: 100,\n    maxMintingFee: 10000n,\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.equal(BigInt(tokenId));\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;eb233165-6e84-403a-ab12-b0ac8d45ee7e&quot;,&quot;parentUUID&quot;:&quot;fce48b2c-6b86-49b2-8d5d-6de0d5196500&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;b711330f-3031-4c2d-a4f4-b0a6b875a508&quot;,&quot;fabf92c4-d83a-4c58-abc0-763c1c1ffb24&quot;,&quot;eb233165-6e84-403a-ab12-b0ac8d45ee7e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:57648,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;e766cca8-a2d0-433f-a1ab-cc47caa08d67&quot;,&quot;title&quot;:&quot;Register derivative IP Asset by minting a new NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Register derivative IP Asset by minting a new NFT\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT \&quot;before all\&quot; hook in \&quot;Register derivative IP Asset by minting a new NFT\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4331,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST_FOR_MINT\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9966d019-fd54-4be6-9b73-d6c891732471&quot;,&quot;parentUUID&quot;:&quot;e766cca8-a2d0-433f-a1ab-cc47caa08d67&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give derivData and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT should successfully when give derivData and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13646,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 1.23,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b5d2b619-1c46-4a5d-8cd3-251b972d8e76&quot;,&quot;parentUUID&quot;:&quot;e766cca8-a2d0-433f-a1ab-cc47caa08d67&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give licenseTokenIds and maxRts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT should successfully when give licenseTokenIds and maxRts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22088,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: commercialRemixLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract },\n    licenseTokenIds: licenseTokenIds,\n    maxRts: 100,\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;09c38579-cc86-406f-9a59-82e15a6f45cf&quot;,&quot;parentUUID&quot;:&quot;e766cca8-a2d0-433f-a1ab-cc47caa08d67&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT should successfully when give derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13876,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;703f48da-2c4b-4816-8c4a-e239da257a10&quot;,&quot;parentUUID&quot;:&quot;e766cca8-a2d0-433f-a1ab-cc47caa08d67&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;b5d2b619-1c46-4a5d-8cd3-251b972d8e76&quot;,&quot;09c38579-cc86-406f-9a59-82e15a6f45cf&quot;,&quot;703f48da-2c4b-4816-8c4a-e239da257a10&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:49610,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;0902bca5-7f4a-4b3c-8899-1d91707ac922&quot;,&quot;title&quot;:&quot;Link Derivative&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give childIpId and licenseTokenIds&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative should successfully when give childIpId and licenseTokenIds&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30958,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst { parentIpId, licenseTermsId } = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f166c91e-e49b-43b8-a881-3c5dc68b16e0&quot;,&quot;parentUUID&quot;:&quot;0902bca5-7f4a-4b3c-8899-1d91707ac922&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;45997857-56bf-4ec5-b57e-2c14f15f9c30&quot;,&quot;title&quot;:&quot;parentIpId and licenseTermsId&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully give ERC20 token&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative parentIpId and licenseTermsId should successfully give ERC20 token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30892,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// 1. register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// 2. create parent ip and license terms for ERC20\nconst parentIpIdAndLicenseTermsIdForERC20 = await createParentIpAndLicenseTerms(client, generated_1.erc20Address[util_1.aeneid]);\n// 3. link derivative\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpIdAndLicenseTermsIdForERC20.parentIpId],\n    licenseTermsIds: [parentIpIdAndLicenseTermsIdForERC20.licenseTermsId],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;43511d6e-eee8-4e73-a0dc-8adbd59da41c&quot;,&quot;parentUUID&quot;:&quot;45997857-56bf-4ec5-b57e-2c14f15f9c30&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully give sufficient WIP token&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative parentIpId and licenseTermsId should successfully give sufficient WIP token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:35435,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// 1. deposit 100 WIP token\nawait client.wipClient.deposit({\n    amount: 100n,\n});\n// 2. register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// 3. create parent ip and license terms for WIP\nconst parentIpIdAndLicenseTermsIdForWIP = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\n// 4. link derivative\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpIdAndLicenseTermsIdForWIP.parentIpId],\n    licenseTermsIds: [parentIpIdAndLicenseTermsIdForWIP.licenseTermsId],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n// 5. withdraw all WIP token\nconst wipBalance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nawait client.wipClient.withdraw({\n    amount: wipBalance,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;57968d03-260e-4c72-958f-0dc4603456c0&quot;,&quot;parentUUID&quot;:&quot;45997857-56bf-4ec5-b57e-2c14f15f9c30&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully give insufficient WIP token&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative parentIpId and licenseTermsId should successfully give insufficient WIP token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22505,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// 1. register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// 2. create parent ip and license terms for WIP\nconst parentIpIdAndLicenseTermsIdForWIP = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\n// 3. link derivative\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpIdAndLicenseTermsIdForWIP.parentIpId],\n    licenseTermsIds: [parentIpIdAndLicenseTermsIdForWIP.licenseTermsId],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;10737a14-d6a0-4733-b761-d6860bead2f7&quot;,&quot;parentUUID&quot;:&quot;45997857-56bf-4ec5-b57e-2c14f15f9c30&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully give wip token with insufficient balance and sufficient erc20 token&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative parentIpId and licenseTermsId should successfully give wip token with insufficient balance and sufficient erc20 token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:40162,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;//1. register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// 2. create parent ip and license terms for WIP\nconst parentIpIdAndLicenseTermsIdForWIP1 = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\nconst parentIpIdAndLicenseTermsIdForERC20 = await createParentIpAndLicenseTerms(client, generated_1.erc20Address[util_1.aeneid]);\n// 3. link derivative\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [\n        parentIpIdAndLicenseTermsIdForWIP1.parentIpId,\n        parentIpIdAndLicenseTermsIdForERC20.parentIpId,\n    ],\n    licenseTermsIds: [\n        parentIpIdAndLicenseTermsIdForWIP1.licenseTermsId,\n        parentIpIdAndLicenseTermsIdForERC20.licenseTermsId,\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8f639ae2-6b54-4e9e-9260-3634b1ee8d2d&quot;,&quot;parentUUID&quot;:&quot;45997857-56bf-4ec5-b57e-2c14f15f9c30&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully give wip token with sufficient balance and sufficient erc20 token&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative parentIpId and licenseTermsId should successfully give wip token with sufficient balance and sufficient erc20 token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:57375,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// 1. deposit 100 WIP token\nawait client.wipClient.deposit({\n    amount: 100n,\n});\n// 2. register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// 3. create parent ip and license terms for WIP\nconst parentIpIdAndLicenseTermsIdForWIP1 = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\n// 4. create parent ip and license terms for ERC20\nconst parentIpIdAndLicenseTermsIdForERC20 = await createParentIpAndLicenseTerms(client, generated_1.erc20Address[util_1.aeneid]);\n// 5. link derivative\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [\n        parentIpIdAndLicenseTermsIdForWIP1.parentIpId,\n        parentIpIdAndLicenseTermsIdForERC20.parentIpId,\n    ],\n    licenseTermsIds: [\n        parentIpIdAndLicenseTermsIdForWIP1.licenseTermsId,\n        parentIpIdAndLicenseTermsIdForERC20.licenseTermsId,\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n// 6. withdraw all WIP token\nconst wipBalance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nawait client.wipClient.withdraw({\n    amount: wipBalance,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;065d99f0-ee62-422c-be10-6546ae244182&quot;,&quot;parentUUID&quot;:&quot;45997857-56bf-4ec5-b57e-2c14f15f9c30&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully give wip token with insufficient balance and sufficient erc20 token and useMulticallWhenPossible is false&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative parentIpId and licenseTermsId should successfully give wip token with insufficient balance and sufficient erc20 token and useMulticallWhenPossible is false&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:53980,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// 1. register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// 2. create parent ip and license terms for WIP\nconst parentIpIdAndLicenseTermsIdForWIP1 = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\n// 3. create parent ip and license terms for ERC20\nconst parentIpIdAndLicenseTermsIdForERC20 = await createParentIpAndLicenseTerms(client, generated_1.erc20Address[util_1.aeneid]);\n// 4. link derivative\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [\n        parentIpIdAndLicenseTermsIdForWIP1.parentIpId,\n        parentIpIdAndLicenseTermsIdForERC20.parentIpId,\n    ],\n    licenseTermsIds: [\n        parentIpIdAndLicenseTermsIdForWIP1.licenseTermsId,\n        parentIpIdAndLicenseTermsIdForERC20.licenseTermsId,\n    ],\n    options: {\n        wipOptions: {\n            useMulticallWhenPossible: false,\n        },\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0cf07480-fa3a-4541-98de-3f4dd2902073&quot;,&quot;parentUUID&quot;:&quot;45997857-56bf-4ec5-b57e-2c14f15f9c30&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;43511d6e-eee8-4e73-a0dc-8adbd59da41c&quot;,&quot;57968d03-260e-4c72-958f-0dc4603456c0&quot;,&quot;10737a14-d6a0-4733-b761-d6860bead2f7&quot;,&quot;8f639ae2-6b54-4e9e-9260-3634b1ee8d2d&quot;,&quot;065d99f0-ee62-422c-be10-6546ae244182&quot;,&quot;0cf07480-fa3a-4541-98de-3f4dd2902073&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:240349,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;f166c91e-e49b-43b8-a881-3c5dc68b16e0&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:30958,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;e1debc38-3185-487d-9707-2fc2d11d5f52&quot;,&quot;title&quot;:&quot;with ERC20 and WIP token fee&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;with ERC20 and WIP token fee\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee \&quot;before all\&quot; hook in \&quot;with ERC20 and WIP token fee\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22837,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;spgContractWith100WIP = (await client.nftClient.createNFTCollection({\n    name: \&quot;100 WIP\&quot;,\n    symbol: \&quot;100WIP\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 100n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \&quot;\&quot;,\n})).spgNftContract;\nspgContractWith10ERC20 = (await client.nftClient.createNFTCollection({\n    name: \&quot;10 ERC20\&quot;,\n    symbol: \&quot;10ERC20\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 100n,\n    mintFeeToken: generated_1.erc20Address[util_1.aeneid],\n    contractURI: \&quot;\&quot;,\n})).spgNftContract;\nconst result1 = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\nparentIpIdForWIP = result1.ipId;\nlicenseTermsIdFor100WIP = result1.licenseTermsIds[0];\nconst result2 = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10n,\n                commercialRevShare: 10,\n                currency: generated_1.erc20Address[util_1.aeneid],\n            }),\n        },\n    ],\n});\nparentIpIdForERC20 = result2.ipId;\nlicenseTermsIdFor10ERC20 = result2.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;323ced19-11a7-4507-9f22-f11428c07c98&quot;,&quot;parentUUID&quot;:&quot;e1debc38-3185-487d-9707-2fc2d11d5f52&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;04d9386a-b7cb-45ef-beeb-f035a6366a14&quot;,&quot;title&quot;:&quot;SpgNftContract with ERC20 token&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when register ip with license terms data and royalty shares for ERC20&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register ip with license terms data and royalty shares for ERC20&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4915,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0c3e4222-2464-4e0d-b8ca-534a43346066&quot;,&quot;parentUUID&quot;:&quot;04d9386a-b7cb-45ef-beeb-f035a6366a14&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register ip with license terms data&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register ip with license terms data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8898,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: generated_1.erc20Address[util_1.aeneid],\n            }),\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;98b732c7-6e91-4eac-9386-58c43103a4a9&quot;,&quot;parentUUID&quot;:&quot;04d9386a-b7cb-45ef-beeb-f035a6366a14&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register ip with spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register ip with spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4574,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e1c69299-c4f4-4ae1-aaef-ceedcf8af87f&quot;,&quot;parentUUID&quot;:&quot;04d9386a-b7cb-45ef-beeb-f035a6366a14&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with derivData and royalty shares for ERC20&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register derivative ip with derivData and royalty shares for ERC20&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4945,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForERC20],\n        licenseTermsIds: [licenseTermsIdFor10ERC20],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;18e9175e-40fc-4f27-a5c8-f30d59a65afb&quot;,&quot;parentUUID&quot;:&quot;04d9386a-b7cb-45ef-beeb-f035a6366a14&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with license token ids and derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register derivative ip with license token ids and derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9627,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsIdFor10ERC20,\n    licensorIpId: parentIpIdForERC20,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForERC20],\n        licenseTermsIds: [licenseTermsIdFor10ERC20],\n    },\n    licenseTokenIds: licenseTokenIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5c2c36f8-6731-424c-b771-c0a7d53f4994&quot;,&quot;parentUUID&quot;:&quot;04d9386a-b7cb-45ef-beeb-f035a6366a14&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register derivative ip with derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4940,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForERC20],\n        licenseTermsIds: [licenseTermsIdFor10ERC20],\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6a77eda2-6241-42b5-91ea-d91d0bcfc1ff&quot;,&quot;parentUUID&quot;:&quot;04d9386a-b7cb-45ef-beeb-f035a6366a14&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when link derivative ip given childIpId and license token ids&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when link derivative ip given childIpId and license token ids&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17959,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpIdForERC20],\n    licenseTermsIds: [licenseTermsIdFor10ERC20],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c39c14d6-c874-47a3-829f-123524a46ec0&quot;,&quot;parentUUID&quot;:&quot;04d9386a-b7cb-45ef-beeb-f035a6366a14&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when batch register derivatives&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when batch register derivatives&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:62534,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst childIpId1 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n})).ipId;\nconst childIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId2,\n})).ipId;\nconst { parentIpId: parentIpId1, licenseTermsId: licenseTermsId1 } = await createParentIpAndLicenseTerms(client, generated_1.erc20Address[util_1.aeneid]);\nconst { parentIpId: parentIpId2, licenseTermsId: licenseTermsId2 } = await createParentIpAndLicenseTerms(client, generated_1.erc20Address[util_1.aeneid]);\nconst result = await client.ipAsset.batchRegisterDerivatives({\n    requests: [\n        {\n            childIpId: childIpId1,\n            parentIpIds: [parentIpId1, parentIpId2],\n            licenseTermsIds: [licenseTermsId1, licenseTermsId2],\n        },\n        {\n            childIpId: childIpId2,\n            parentIpIds: [parentIpIdForERC20],\n            licenseTermsIds: [licenseTermsIdFor10ERC20],\n        },\n    ],\n});\n(0, chai_1.expect)(result.length).to.equal(2);\n(0, chai_1.expect)(result[0]).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9c4b3ed4-9312-45d1-b066-8c67351bdbd2&quot;,&quot;parentUUID&quot;:&quot;04d9386a-b7cb-45ef-beeb-f035a6366a14&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;0c3e4222-2464-4e0d-b8ca-534a43346066&quot;,&quot;98b732c7-6e91-4eac-9386-58c43103a4a9&quot;,&quot;e1c69299-c4f4-4ae1-aaef-ceedcf8af87f&quot;,&quot;18e9175e-40fc-4f27-a5c8-f30d59a65afb&quot;,&quot;5c2c36f8-6731-424c-b771-c0a7d53f4994&quot;,&quot;6a77eda2-6241-42b5-91ea-d91d0bcfc1ff&quot;,&quot;c39c14d6-c874-47a3-829f-123524a46ec0&quot;,&quot;9c4b3ed4-9312-45d1-b066-8c67351bdbd2&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:118392,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;81045482-72d4-41d0-8584-134177edc0db&quot;,&quot;title&quot;:&quot;SpgNftContract with WIP token&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when register ip with license terms data and royalty shares for WIP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register ip with license terms data and royalty shares for WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17762,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3bfe549e-1cc1-4c4b-bf17-5e6ef8b12171&quot;,&quot;parentUUID&quot;:&quot;81045482-72d4-41d0-8584-134177edc0db&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register ip with license terms data&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register ip with license terms data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4961,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a1fb6dc7-ae48-496a-b962-e7714ce65983&quot;,&quot;parentUUID&quot;:&quot;81045482-72d4-41d0-8584-134177edc0db&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register ip with spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register ip with spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13023,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;58031dd0-1a6b-46e3-a287-148d31b59fe3&quot;,&quot;parentUUID&quot;:&quot;81045482-72d4-41d0-8584-134177edc0db&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with derivData and royalty shares for WIP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register derivative ip with derivData and royalty shares for WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5180,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cc789ddf-9eba-452a-9479-0a4d87b5beba&quot;,&quot;parentUUID&quot;:&quot;81045482-72d4-41d0-8584-134177edc0db&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with license token ids and derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register derivative ip with license token ids and derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10343,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsIdFor100WIP,\n    licensorIpId: parentIpIdForWIP,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n    licenseTokenIds: licenseTokenIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;047dd582-bf65-4e23-8d08-0e33be96a7ce&quot;,&quot;parentUUID&quot;:&quot;81045482-72d4-41d0-8584-134177edc0db&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register derivative ip with derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5087,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cb1ea289-11c8-4992-b987-f1a4d92a4994&quot;,&quot;parentUUID&quot;:&quot;81045482-72d4-41d0-8584-134177edc0db&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when link derivative ip given childIpId and license token ids&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when link derivative ip given childIpId and license token ids&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13491,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpIdForWIP],\n    licenseTermsIds: [licenseTermsIdFor100WIP],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;26de3b7a-29c2-4879-9038-15e84099fdd2&quot;,&quot;parentUUID&quot;:&quot;81045482-72d4-41d0-8584-134177edc0db&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when batch register derivatives&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when batch register derivatives&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:41085,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst registerResponse = await client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId1,\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2,\n        },\n    ],\n});\nconst childIpId1 = registerResponse.results[0]?.ipId;\nconst childIpId2 = registerResponse.results[1]?.ipId;\nconst { parentIpId: parentIpId1, licenseTermsId: licenseTermsId1 } = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\nconst { parentIpId: parentIpId2, licenseTermsId: licenseTermsId2 } = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\nconst result = await client.ipAsset.batchRegisterDerivatives({\n    requests: [\n        {\n            childIpId: childIpId1,\n            parentIpIds: [parentIpId1, parentIpId2],\n            licenseTermsIds: [licenseTermsId1, licenseTermsId2],\n        },\n        {\n            childIpId: childIpId2,\n            parentIpIds: [parentIpIdForWIP],\n            licenseTermsIds: [licenseTermsIdFor100WIP],\n        },\n    ],\n});\n(0, chai_1.expect)(result.length).to.equal(2);\n(0, chai_1.expect)(result[0]).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result[1]).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c0bcfba5-ae32-43ff-a04a-eab8537d28e7&quot;,&quot;parentUUID&quot;:&quot;81045482-72d4-41d0-8584-134177edc0db&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;3bfe549e-1cc1-4c4b-bf17-5e6ef8b12171&quot;,&quot;a1fb6dc7-ae48-496a-b962-e7714ce65983&quot;,&quot;58031dd0-1a6b-46e3-a287-148d31b59fe3&quot;,&quot;cc789ddf-9eba-452a-9479-0a4d87b5beba&quot;,&quot;047dd582-bf65-4e23-8d08-0e33be96a7ce&quot;,&quot;cb1ea289-11c8-4992-b987-f1a4d92a4994&quot;,&quot;26de3b7a-29c2-4879-9038-15e84099fdd2&quot;,&quot;c0bcfba5-ae32-43ff-a04a-eab8537d28e7&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:110932,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;c727843a-eafa-43b0-9cf4-2cdb5c22ec93&quot;,&quot;title&quot;:&quot;Mixed ERC20 and WIP token&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when register derivative ip with derivData and royalty shares for mixed ERC20 and WIP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee Mixed ERC20 and WIP token should successfully when register derivative ip with derivData and royalty shares for mixed ERC20 and WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9468,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;af0135c1-d068-4c25-beb3-2f0d9915549f&quot;,&quot;parentUUID&quot;:&quot;c727843a-eafa-43b0-9cf4-2cdb5c22ec93&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with license token ids and derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee Mixed ERC20 and WIP token should successfully when register derivative ip with license token ids and derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14186,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsIdFor100WIP,\n    licensorIpId: parentIpIdForWIP,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n    licenseTokenIds: licenseTokenIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;aad964e2-1f12-471d-a96f-d869da34e9e8&quot;,&quot;parentUUID&quot;:&quot;c727843a-eafa-43b0-9cf4-2cdb5c22ec93&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when batch register derivatives&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee Mixed ERC20 and WIP token should successfully when batch register derivatives&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:62752,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst registerResponse = await client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId1,\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2,\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId3,\n        },\n    ],\n});\nconst childIpId1 = registerResponse.results[0]?.ipId;\nconst childIpId2 = registerResponse.results[1]?.ipId;\nconst childIpId3 = registerResponse.results[2]?.ipId;\nconst { parentIpId: parentIpId1, licenseTermsId: licenseTermsId1 } = await createParentIpAndLicenseTerms(client, generated_1.erc20Address[util_1.aeneid]);\nconst { parentIpId: parentIpId2, licenseTermsId: licenseTermsId2 } = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\nconst result = await client.ipAsset.batchRegisterDerivatives({\n    requests: [\n        {\n            childIpId: childIpId1,\n            parentIpIds: [parentIpId1, parentIpId2],\n            licenseTermsIds: [licenseTermsId1, licenseTermsId2],\n        },\n        {\n            childIpId: childIpId2,\n            parentIpIds: [parentIpIdForWIP],\n            licenseTermsIds: [licenseTermsIdFor100WIP],\n        },\n        {\n            childIpId: childIpId3,\n            parentIpIds: [parentIpIdForWIP],\n            licenseTermsIds: [licenseTermsIdFor100WIP],\n        },\n    ],\n});\n(0, chai_1.expect)(result.length).to.equal(3);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5b4f0844-008b-463e-b41e-2f086700414a&quot;,&quot;parentUUID&quot;:&quot;c727843a-eafa-43b0-9cf4-2cdb5c22ec93&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;af0135c1-d068-4c25-beb3-2f0d9915549f&quot;,&quot;aad964e2-1f12-471d-a96f-d869da34e9e8&quot;,&quot;5b4f0844-008b-463e-b41e-2f086700414a&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:86406,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;c663adfa-4fff-4177-b5d3-ab944e7c2670&quot;,&quot;title&quot;:&quot;License Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;License Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions \&quot;before all\&quot; hook in \&quot;License Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:61,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nclientB = derivedClient.clientB;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f7e0ea47-def8-4727-85f6-7bff2b7b58dc&quot;,&quot;parentUUID&quot;:&quot;c663adfa-4fff-4177-b5d3-ab944e7c2670&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;94821d1d-1774-4b53-94a6-2301cc5694e0&quot;,&quot;title&quot;:&quot;register license with different types&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register license &quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license &quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:43,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerPILTerms({\n    defaultMintingFee: 0,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    transferable: false,\n    royaltyPolicy: viem_1.zeroAddress,\n    commercialUse: false,\n    commercialAttribution: false,\n    commercializerChecker: viem_1.zeroAddress,\n    commercializerCheckerData: \&quot;0x\&quot;,\n    commercialRevShare: 0,\n    derivativesAllowed: false,\n    derivativesAttribution: false,\n    derivativesApproval: false,\n    derivativesReciprocal: false,\n    uri: \&quot;\&quot;,\n    expiration: 0,\n    commercialRevCeiling: 0,\n    derivativeRevCeiling: 0,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6880529a-436b-4e28-bdff-9604ac6b1362&quot;,&quot;parentUUID&quot;:&quot;94821d1d-1774-4b53-94a6-2301cc5694e0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with non commercial social remixing PIL&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with non commercial social remixing PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:43,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerNonComSocialRemixingPIL();\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;90cc9d45-c68f-4a9d-af68-2513bf9217e6&quot;,&quot;parentUUID&quot;:&quot;94821d1d-1774-4b53-94a6-2301cc5694e0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with commercial use&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with commercial use&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:44,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerCommercialUsePIL({\n    defaultMintingFee: \&quot;1\&quot;,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3cebece4-524b-4ca9-b00a-28d5a356ed8b&quot;,&quot;parentUUID&quot;:&quot;94821d1d-1774-4b53-94a6-2301cc5694e0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with commercial Remix use&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with commercial Remix use&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:43,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerCommercialRemixPIL({\n    defaultMintingFee: \&quot;1\&quot;,\n    commercialRevShare: 100,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;08fc9f9a-9379-479f-bfd2-f25f0c7a01af&quot;,&quot;parentUUID&quot;:&quot;94821d1d-1774-4b53-94a6-2301cc5694e0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with creative commons attribution PIL&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with creative commons attribution PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:43,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerCreativeCommonsAttributionPIL({\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicyAddress: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0eaabfe4-dce9-4258-b944-9247e458dbe7&quot;,&quot;parentUUID&quot;:&quot;94821d1d-1774-4b53-94a6-2301cc5694e0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;6880529a-436b-4e28-bdff-9604ac6b1362&quot;,&quot;90cc9d45-c68f-4a9d-af68-2513bf9217e6&quot;,&quot;3cebece4-524b-4ca9-b00a-28d5a356ed8b&quot;,&quot;08fc9f9a-9379-479f-bfd2-f25f0c7a01af&quot;,&quot;0eaabfe4-dce9-4258-b944-9247e458dbe7&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:216,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;06ffd684-eac7-43a8-9420-12fcc09d02c8&quot;,&quot;title&quot;:&quot;attach License Terms and mint license tokens&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;attach License Terms and mint license tokens\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens \&quot;before all\&quot; hook in \&quot;attach License Terms and mint license tokens\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13078,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;tokenId = await (0, util_1.getTokenId)();\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nconst mockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\nawait mockERC20.approve(generated_1.licensingModuleAddress[util_1.aeneid], viem_1.maxUint256);\nipId = registerResult.ipId;\nconst registerLicenseResult = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 0n,\n    commercialRevShare: 100,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n}));\nlicenseId = registerLicenseResult.licenseTermsId;\nconst paidLicenseResult = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 100n,\n    commercialRevShare: 10,\n    currency: generated_1.erc20Address[util_1.aeneid],\n}));\npaidLicenseId = paidLicenseResult.licenseTermsId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f0321d2f-30e4-4811-9d13-f534a7d9b534&quot;,&quot;parentUUID&quot;:&quot;06ffd684-eac7-43a8-9420-12fcc09d02c8&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should attach License Terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should attach License Terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4517,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1ae42077-c793-4f33-acae-a4a5126df9f1&quot;,&quot;parentUUID&quot;:&quot;06ffd684-eac7-43a8-9420-12fcc09d02c8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should be able to attach another license terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should be able to attach another license terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8487,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: paidLicenseId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a31703c5-d6b9-48c4-bf58-637be3402ea6&quot;,&quot;parentUUID&quot;:&quot;06ffd684-eac7-43a8-9420-12fcc09d02c8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license tokens with ip owner&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license tokens with ip owner&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4511,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseId,\n    licensorIpId: ipId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4616f09f-9443-49b8-a6b1-8f1cf303b61e&quot;,&quot;parentUUID&quot;:&quot;06ffd684-eac7-43a8-9420-12fcc09d02c8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license tokens with non ip owner&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license tokens with non ip owner&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17719,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// register ip with another wallet account\nconst tokenIdB = await (0, util_1.getTokenId)();\nconst registerResult = await clientB.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenIdB,\n});\nconst ipIdB = registerResult.ipId;\n// attach license terms to the ip\nawait client.license.attachLicenseTerms({\n    ipId: ipIdB,\n    licenseTermsId: licenseId,\n});\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseId,\n    licensorIpId: ipIdB,\n    maxMintingFee: 10000000,\n    maxRevenueShare: 100,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1c3f2abb-2234-45b9-8c86-ce0c31a82523&quot;,&quot;parentUUID&quot;:&quot;06ffd684-eac7-43a8-9420-12fcc09d02c8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license token with default license terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license token with default license terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4547,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// get default license terms id\nconst licenseRegistryReadOnlyClient = new generated_1.LicenseRegistryReadOnlyClient(util_1.publicClient);\nconst { licenseTermsId: defaultLicenseTermsId } = await licenseRegistryReadOnlyClient.getDefaultLicenseTerms();\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: defaultLicenseTermsId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 1,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bd56e823-3491-4a34-bff1-3bebd158ad07&quot;,&quot;parentUUID&quot;:&quot;06ffd684-eac7-43a8-9420-12fcc09d02c8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license tokens with fee and pay with IP&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license tokens with fee and pay with IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4682,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const balanceBefore = await client.getWalletBalance();\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: paidLicenseId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 50,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 100n));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7bf55510-d762-4d82-9b82-9a73f05b6a70&quot;,&quot;parentUUID&quot;:&quot;06ffd684-eac7-43a8-9420-12fcc09d02c8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should get license terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should get license terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:46,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.getLicenseTerms(licenseId);\n(0, chai_1.expect)(result).to.be.an(\&quot;object\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4272aed3-57d6-4ad6-80c9-bcbc35fa1e40&quot;,&quot;parentUUID&quot;:&quot;06ffd684-eac7-43a8-9420-12fcc09d02c8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should predict minting license fee&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should predict minting license fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:129,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.predictMintingLicenseFee({\n    licenseTermsId: licenseId,\n    licensorIpId: ipId,\n    amount: 1,\n});\n(0, chai_1.expect)(result.currencyToken).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenAmount).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;eb6efc2d-af15-416d-ad95-fdf70e73d354&quot;,&quot;parentUUID&quot;:&quot;06ffd684-eac7-43a8-9420-12fcc09d02c8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;54704264-58fa-4c99-b259-2a9ef32f326d&quot;,&quot;title&quot;:&quot;licensing config and max license tokens&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should set licensing config&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens licensing config and max license tokens should set licensing config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8490,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.setLicensingConfig({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n    licensingConfig,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;804c12a9-4a3c-4bde-8fea-ca698a42f453&quot;,&quot;parentUUID&quot;:&quot;54704264-58fa-4c99-b259-2a9ef32f326d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should get licensing config&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens licensing config and max license tokens should get licensing config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:43,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.getLicensingConfig({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n});\n(0, chai_1.expect)(result).to.deep.equal({\n    ...licensingConfig,\n    expectMinimumGroupRewardShare: 1 * 10 ** 6,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;65609e8f-2456-47c4-a06b-1545102f7bd4&quot;,&quot;parentUUID&quot;:&quot;54704264-58fa-4c99-b259-2a9ef32f326d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should set max license tokens&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens licensing config and max license tokens should set max license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8857,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.setMaxLicenseTokens({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n    maxLicenseTokens: 100,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d9799655-8f52-42cd-aa25-b9b48bfb2c9f&quot;,&quot;parentUUID&quot;:&quot;54704264-58fa-4c99-b259-2a9ef32f326d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;804c12a9-4a3c-4bde-8fea-ca698a42f453&quot;,&quot;65609e8f-2456-47c4-a06b-1545102f7bd4&quot;,&quot;d9799655-8f52-42cd-aa25-b9b48bfb2c9f&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:17390,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;1ae42077-c793-4f33-acae-a4a5126df9f1&quot;,&quot;a31703c5-d6b9-48c4-bf58-637be3402ea6&quot;,&quot;4616f09f-9443-49b8-a6b1-8f1cf303b61e&quot;,&quot;1c3f2abb-2234-45b9-8c86-ce0c31a82523&quot;,&quot;bd56e823-3491-4a34-bff1-3bebd158ad07&quot;,&quot;7bf55510-d762-4d82-9b82-9a73f05b6a70&quot;,&quot;4272aed3-57d6-4ad6-80c9-bcbc35fa1e40&quot;,&quot;eb6efc2d-af15-416d-ad95-fdf70e73d354&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:44638,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;225fb5c7-d00a-4bcd-9ab6-03c18443bc18&quot;,&quot;title&quot;:&quot;register pil terms and attach&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;register pil terms and attach\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions register pil terms and attach \&quot;before all\&quot; hook in \&quot;register pil terms and attach\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8726,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;tokenId = (await (0, util_1.getTokenId)());\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId,\n});\nipId = registerResult.ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f27f0092-48ed-4b32-aa41-7ac5a150dee8&quot;,&quot;parentUUID&quot;:&quot;225fb5c7-d00a-4bcd-9ab6-03c18443bc18&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register PIL terms and attach&quot;,&quot;fullTitle&quot;:&quot;License Functions register pil terms and attach should register PIL terms and attach&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4650,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerPilTermsAndAttach({\n    ipId: ipId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 0n,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.nonCommercialSocialRemixing(),\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a87b651f-a8f7-4157-8336-de627ed84f5a&quot;,&quot;parentUUID&quot;:&quot;225fb5c7-d00a-4bcd-9ab6-03c18443bc18&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register PIL terms and attach with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;License Functions register pil terms and attach should register PIL terms and attach with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9215,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerPilTermsAndAttach({\n    ipId: ipId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 0n,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 1,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 0n,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cccbec14-f97a-48e0-8a34-d01897042399&quot;,&quot;parentUUID&quot;:&quot;225fb5c7-d00a-4bcd-9ab6-03c18443bc18&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a87b651f-a8f7-4157-8336-de627ed84f5a&quot;,&quot;cccbec14-f97a-48e0-8a34-d01897042399&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13865,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;9c818e11-418a-43ee-a464-95bab460b12b&quot;,&quot;title&quot;:&quot;Creative Commons Attribution License Tests&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Creative Commons Attribution License Tests\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests \&quot;before all\&quot; hook in \&quot;Creative Commons Attribution License Tests\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12781,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;tokenId = await (0, util_1.getTokenId)();\n// Register an IP asset\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = registerResult.ipId;\n// Create a Creative Commons Attribution license\nconst ccLicenseResult = await client.license.registerCreativeCommonsAttributionPIL({\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicyAddress: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n});\nccLicenseTermsId = ccLicenseResult.licenseTermsId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;28660bd7-0173-4c68-a7e4-400803037dc1&quot;,&quot;parentUUID&quot;:&quot;9c818e11-418a-43ee-a464-95bab460b12b&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should verify the license terms match Creative Commons Attribution specifications&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests should verify the license terms match Creative Commons Attribution specifications&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:54,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const licenseTerms = await client.license.getLicenseTerms(ccLicenseTermsId);\n(0, chai_1.expect)(licenseTerms.terms.transferable).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.commercialUse).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesAllowed).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesAttribution).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesReciprocal).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesApproval).to.equal(false);\n(0, chai_1.expect)(licenseTerms.terms.commercialAttribution).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.commercialRevShare).to.equal(0);\n(0, chai_1.expect)(licenseTerms.terms.defaultMintingFee).to.equal(0n);\n(0, chai_1.expect)(licenseTerms.terms.royaltyPolicy).to.equal(generated_1.royaltyPolicyLapAddress[util_1.aeneid]);\n(0, chai_1.expect)(licenseTerms.terms.expiration).to.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2fdc4feb-2741-4e11-8e35-77555793b143&quot;,&quot;parentUUID&quot;:&quot;9c818e11-418a-43ee-a464-95bab460b12b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should attach Creative Commons Attribution license to an IP&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests should attach Creative Commons Attribution license to an IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4511,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const attachResult = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: ccLicenseTermsId,\n});\n(0, chai_1.expect)(attachResult.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(attachResult.success).to.equal(true);\nconst licenseRegistryReadOnlyClient = new generated_1.LicenseRegistryReadOnlyClient(util_1.publicClient);\nconst hasLicense = await licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({\n    ipId: ipId,\n    licenseTemplate: client.ipAsset.licenseTemplateClient.address,\n    licenseTermsId: ccLicenseTermsId,\n});\n(0, chai_1.expect)(hasLicense).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c5cfe669-311f-4393-ad12-d009b36b6586&quot;,&quot;parentUUID&quot;:&quot;9c818e11-418a-43ee-a464-95bab460b12b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint CC-BY license tokens with no minting fee&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests should mint CC-BY license tokens with no minting fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4739,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Get wallet balance before minting\nconst balanceBefore = await client.getWalletBalance();\n// Predict the minting fee (should be zero for CC-BY)\nconst feePredict = await client.license.predictMintingLicenseFee({\n    licenseTermsId: ccLicenseTermsId,\n    licensorIpId: ipId,\n    amount: 1,\n});\n// CC-BY licenses should have zero minting fee\n(0, chai_1.expect)(feePredict.tokenAmount).to.equal(0n);\nconst mintResult = await client.license.mintLicenseTokens({\n    licenseTermsId: ccLicenseTermsId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 0,\n});\n(0, chai_1.expect)(mintResult.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(mintResult.licenseTokenIds).to.be.a(\&quot;array\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n// Verify no fee was charged just gas\n// This checks that any difference is very small (just gas costs)\nconst balanceDiff = balanceBefore - balanceAfter;\nconst gasUsed = mintResult.receipt.gasUsed;\nconst effectiveGasPrice = mintResult.receipt.effectiveGasPrice;\nconst totalGas = gasUsed * effectiveGasPrice;\n// Confirms the balance diff only reflects gas cost, since license fee is zero.\n(0, chai_1.expect)(balanceDiff).to.equal(totalGas); // Small amount for gas&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e9684cba-9736-4659-9072-9200d7e08f30&quot;,&quot;parentUUID&quot;:&quot;9c818e11-418a-43ee-a464-95bab460b12b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;2fdc4feb-2741-4e11-8e35-77555793b143&quot;,&quot;c5cfe669-311f-4393-ad12-d009b36b6586&quot;,&quot;e9684cba-9736-4659-9072-9200d7e08f30&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:9304,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;617f8850-6118-4dd4-93b9-303cc86c3a0d&quot;,&quot;title&quot;:&quot;nftClient Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;nftClient Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions \&quot;before all\&quot; hook in \&quot;nftClient Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;57f4b4fb-84e0-4f61-85d5-82a6000cfcc4&quot;,&quot;parentUUID&quot;:&quot;617f8850-6118-4dd4-93b9-303cc86c3a0d&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;59070138-8999-4b56-8c0b-55c9e9a72448&quot;,&quot;title&quot;:&quot;createNFTCollection&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully create public nft collection with minimal params&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create public nft collection with minimal params&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8400,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(txData.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;614d93dc-649a-43c1-9c9e-a1ad15731a29&quot;,&quot;parentUUID&quot;:&quot;59070138-8999-4b56-8c0b-55c9e9a72448&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create collection with custom mint fee&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create collection with custom mint fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4371,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;paid-collection\&quot;,\n    symbol: \&quot;PAID\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 10000000,\n    mintFeeToken: generated_1.erc20Address[mockData_1.aeneid],\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);\nspgNftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;122a46bc-8754-4942-8c0b-9ea5cf830e42&quot;,&quot;parentUUID&quot;:&quot;59070138-8999-4b56-8c0b-55c9e9a72448&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create private collection&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create private collection&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4332,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;private-collection\&quot;,\n    symbol: \&quot;PRIV\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false, // private minting\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: false, // starts closed\n    contractURI: \&quot;test-uri\&quot;,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7bb7a73c-3ea1-4833-8428-a52fea28cb93&quot;,&quot;parentUUID&quot;:&quot;59070138-8999-4b56-8c0b-55c9e9a72448&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create collection with baseURI&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create collection with baseURI&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4315,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;uri-collection\&quot;,\n    symbol: \&quot;URI\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    baseURI: \&quot;ipfs://QmTest/\&quot;,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f9ae06a8-9378-4665-a991-7ce1c3d03309&quot;,&quot;parentUUID&quot;:&quot;59070138-8999-4b56-8c0b-55c9e9a72448&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create collection with custom owner&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create collection with custom owner&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4332,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;owned-collection\&quot;,\n    symbol: \&quot;OWN\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    owner: util_1.TEST_WALLET_ADDRESS,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d9efe821-c3c0-429e-a33b-d6439d8bb040&quot;,&quot;parentUUID&quot;:&quot;59070138-8999-4b56-8c0b-55c9e9a72448&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully get encoded transaction data&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully get encoded transaction data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;encoded-collection\&quot;,\n    symbol: \&quot;ENC\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    txOptions: {\n        encodedTxDataOnly: true,\n    },\n});\n(0, chai_1.expect)(txData.encodedTxData).to.be.an(\&quot;object\&quot;);\n(0, chai_1.expect)(txData.encodedTxData?.data).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(txData.encodedTxData?.to).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e4c4e928-e4fe-491e-a398-12d66a5ca1fd&quot;,&quot;parentUUID&quot;:&quot;59070138-8999-4b56-8c0b-55c9e9a72448&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid mint fee token&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should fail with invalid mint fee token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.nftClient.createNFTCollection({\n    name: \&quot;invalid-fee-collection\&quot;,\n    symbol: \&quot;INV\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 1000000000000000000,\n    mintFeeToken: \&quot;0x0000000000000000000000000000000000000000\&quot;,\n})).to.be.rejectedWith(\&quot;Invalid mint fee token address\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2e79b9f2-c7cc-48a1-9e7d-3baff245681d&quot;,&quot;parentUUID&quot;:&quot;59070138-8999-4b56-8c0b-55c9e9a72448&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;614d93dc-649a-43c1-9c9e-a1ad15731a29&quot;,&quot;122a46bc-8754-4942-8c0b-9ea5cf830e42&quot;,&quot;7bb7a73c-3ea1-4833-8428-a52fea28cb93&quot;,&quot;f9ae06a8-9378-4665-a991-7ce1c3d03309&quot;,&quot;d9efe821-c3c0-429e-a33b-d6439d8bb040&quot;,&quot;e4c4e928-e4fe-491e-a398-12d66a5ca1fd&quot;,&quot;2e79b9f2-c7cc-48a1-9e7d-3baff245681d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:25753,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;f1e36e3a-5162-4c00-8327-f7731377661a&quot;,&quot;title&quot;:&quot;Mint Fee&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully get mint fee token&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions Mint Fee should successfully get mint fee token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:52,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintFeeToken = await client.nftClient.getMintFeeToken(spgNftContract);\n(0, chai_1.expect)(mintFeeToken).to.equal(generated_1.erc20Address[mockData_1.aeneid]);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f2cb16dd-653e-4195-9e0f-bb74fd8321e8&quot;,&quot;parentUUID&quot;:&quot;f1e36e3a-5162-4c00-8327-f7731377661a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully get mint fee&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions Mint Fee should successfully get mint fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:42,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintFee = await client.nftClient.getMintFee(spgNftContract);\n(0, chai_1.expect)(mintFee).to.equal(10000000n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2c8e7a41-5260-4718-bfe4-f79d63640651&quot;,&quot;parentUUID&quot;:&quot;f1e36e3a-5162-4c00-8327-f7731377661a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;f2cb16dd-653e-4195-9e0f-bb74fd8321e8&quot;,&quot;2c8e7a41-5260-4718-bfe4-f79d63640651&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:94,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;c54bfc8f-9523-4cbb-9fbf-4723fdea9be5&quot;,&quot;title&quot;:&quot;set and get tokenURI&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully set token URI&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions set and get tokenURI should successfully set token URI&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13018,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Setup: Approve the contract for ERC20 transfers\nconst erc20Client = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[mockData_1.aeneid]);\nconst txHash = await erc20Client.approve(spgNftContract, viem_1.maxUint256);\nawait util_1.publicClient.waitForTransactionReceipt({ hash: txHash });\n// Mint a new token with initial metadata\nconst tokenId = await (0, util_1.mintBySpg)(spgNftContract, \&quot;ipfs://QmTest/\&quot;);\n(0, chai_1.expect)(tokenId).to.be.a(\&quot;bigint\&quot;);\n// Update the token URI\nconst updatedMetadata = \&quot;ipfs://QmUpdated/metadata.json\&quot;;\nconst result = await client.nftClient.setTokenURI({\n    tokenId: tokenId,\n    tokenURI: updatedMetadata,\n    spgNftContract,\n});\n// Verify the transaction\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n// Verification that the URI was updated\nconst tokenURI = await client.nftClient.getTokenURI({\n    tokenId,\n    spgNftContract,\n});\n(0, chai_1.expect)(tokenURI).to.equal(updatedMetadata);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bc155a19-a139-422e-b976-2f05796949ec&quot;,&quot;parentUUID&quot;:&quot;c54bfc8f-9523-4cbb-9fbf-4723fdea9be5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;bc155a19-a139-422e-b976-2f05796949ec&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13018,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;12b15346-ebc3-4a47-abbf-766911ca7017&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;fails with invalid token ID&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions Error Cases fails with invalid token ID&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4384,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const erc20Client = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[mockData_1.aeneid]);\nconst txHash = await erc20Client.approve(spgNftContract, viem_1.maxUint256);\nawait util_1.publicClient.waitForTransactionReceipt({ hash: txHash });\nconst invalidTokenId = 999999999999999n;\nconst updatedMetadata = \&quot;ipfs://QmUpdated/metadata.json\&quot;;\nawait (0, chai_1.expect)(client.nftClient.setTokenURI({\n    tokenId: invalidTokenId,\n    tokenURI: updatedMetadata,\n    spgNftContract,\n})).to.be.rejectedWith(\&quot;Failed to set token URI\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3fb9cd39-7292-4144-9090-b8355f1e83f9&quot;,&quot;parentUUID&quot;:&quot;12b15346-ebc3-4a47-abbf-766911ca7017&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;3fb9cd39-7292-4144-9090-b8355f1e83f9&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4384,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;09ab3a40-fbc9-4ee5-9ba7-a1ab594ac006&quot;,&quot;title&quot;:&quot;Permission Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Permission Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Permission Functions \&quot;before all\&quot; hook in \&quot;Permission Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8694,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = response.ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b672a1ed-c778-4b2d-9423-cd8d4b474da9&quot;,&quot;parentUUID&quot;:&quot;09ab3a40-fbc9-4ee5-9ba7-a1ab594ac006&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;98cc3aa0-fe1a-48ef-be89-941b4e2be6d4&quot;,&quot;title&quot;:&quot;Single Permission Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should set permission successfully&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Single Permission Operations should set permission successfully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4365,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.setPermission({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n    func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;00fba852-13cc-402d-b237-d52a375a4478&quot;,&quot;parentUUID&quot;:&quot;98cc3aa0-fe1a-48ef-be89-941b4e2be6d4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should set all permissions successfully&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Single Permission Operations should set all permissions successfully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4365,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.setAllPermissions({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    permission: permission_1.AccessPermission.ALLOW,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e3475abb-273e-42a4-ab53-cb99e6d90b66&quot;,&quot;parentUUID&quot;:&quot;98cc3aa0-fe1a-48ef-be89-941b4e2be6d4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;00fba852-13cc-402d-b237-d52a375a4478&quot;,&quot;e3475abb-273e-42a4-ab53-cb99e6d90b66&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:8730,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;72950909-999f-4488-8267-17d3f7ddb43e&quot;,&quot;title&quot;:&quot;Permission Signatures&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should create set permission signature&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Permission Signatures should create set permission signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4446,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.createSetPermissionSignature({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n    permission: permission_1.AccessPermission.ALLOW,\n    deadline: 60000n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3fbb4285-c772-4244-816f-a661e261b207&quot;,&quot;parentUUID&quot;:&quot;72950909-999f-4488-8267-17d3f7ddb43e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;3fbb4285-c772-4244-816f-a661e261b207&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4446,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;6fc3379a-327f-42c8-9136-9b274fc8a226&quot;,&quot;title&quot;:&quot;Batch Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should set batch permissions successfully&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Batch Operations should set batch permissions successfully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4402,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.setBatchPermissions({\n    permissions: [\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.ALLOW,\n            func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n        },\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.DENY,\n            func: \&quot;function freezeMetadata(address)\&quot;,\n        },\n    ],\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;923dae63-be72-40b9-9bd5-c5b65e925821&quot;,&quot;parentUUID&quot;:&quot;6fc3379a-327f-42c8-9136-9b274fc8a226&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should create batch permission signature&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Batch Operations should create batch permission signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4515,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.createBatchPermissionSignature({\n    ipId: ipId,\n    permissions: [\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.ALLOW,\n            func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n        },\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.DENY,\n            func: \&quot;function freezeMetadata(address)\&quot;,\n        },\n    ],\n    deadline: 60000n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fd4dc39b-aa6e-4c2a-8b52-cb5b51a0ad60&quot;,&quot;parentUUID&quot;:&quot;6fc3379a-327f-42c8-9136-9b274fc8a226&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;923dae63-be72-40b9-9bd5-c5b65e925821&quot;,&quot;fd4dc39b-aa6e-4c2a-8b52-cb5b51a0ad60&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:8917,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;e1fff4a7-684e-41ec-9e0d-c579f9948fe1&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should fail when setting permission for unregistered IP&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Error Cases should fail when setting permission for unregistered IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:46,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const unregisteredIpId = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nawait (0, chai_1.expect)(client.permission.setPermission({\n    ipId: unregisteredIpId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n})).to.be.rejectedWith(`IP id with ${unregisteredIpId} is not registered.`);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ab523cb3-4204-4f21-8053-7e2a12faa217&quot;,&quot;parentUUID&quot;:&quot;e1fff4a7-684e-41ec-9e0d-c579f9948fe1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid function signature&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Error Cases should fail with invalid function signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:50,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.permission.setPermission({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n    func: \&quot;invalid_function_signature\&quot;,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;97677784-d240-4ac9-9364-f253edf77e0a&quot;,&quot;parentUUID&quot;:&quot;e1fff4a7-684e-41ec-9e0d-c579f9948fe1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;ab523cb3-4204-4f21-8053-7e2a12faa217&quot;,&quot;97677784-d240-4ac9-9364-f253edf77e0a&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:96,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;07af46df-75a0-4e95-86d5-309d5045f0ca&quot;,&quot;title&quot;:&quot;Royalty Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Royalty Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions \&quot;before all\&quot; hook in \&quot;Royalty Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:31282,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nmockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\n// Setup initial state\nparentIpId = await getIpId();\nchildIpId = await getIpId();\nlicenseTermsId = await getCommercialPolicyId();\n// Setup relationships and approvals\nawait attachLicenseTerms(parentIpId, licenseTermsId);\nawait mockERC20.mint(util_1.TEST_WALLET_ADDRESS, (0, viem_1.parseEther)(\&quot;10\&quot;));\nawait mockERC20.approve(generated_1.royaltyModuleAddress[util_1.aeneid], viem_1.maxUint256);\n// Register derivative\nawait client.ipAsset.registerDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [licenseTermsId],\n    maxMintingFee: 0,\n    maxRts: 0,\n    maxRevenueShare: 0,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4954d365-a5db-4321-8d8a-5a0212a90c4c&quot;,&quot;parentUUID&quot;:&quot;07af46df-75a0-4e95-86d5-309d5045f0ca&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;48896abd-0ce6-4787-809f-1dccc02113bf&quot;,&quot;title&quot;:&quot;Royalty Payments&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully pay royalty on behalf&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should successfully pay royalty on behalf&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4594,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: parentIpId,\n    payerIpId: childIpId,\n    token: generated_1.erc20Address[util_1.aeneid],\n    amount: 1,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;096aeb42-5551-4d13-bb50-c061bb711572&quot;,&quot;parentUUID&quot;:&quot;48896abd-0ce6-4787-809f-1dccc02113bf&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto convert IP to WIP when paying WIP on behalf&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should auto convert IP to WIP when paying WIP on behalf&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4684,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const balanceBefore = await client.getWalletBalance();\nconst response = await client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: parentIpId,\n    payerIpId: childIpId,\n    token: common_1.WIP_TOKEN_ADDRESS,\n    amount: 100n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 100n));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;821fb765-d60d-435d-aacb-26c4f59a4767&quot;,&quot;parentUUID&quot;:&quot;48896abd-0ce6-4787-809f-1dccc02113bf&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail to pay royalty with unregistered receiver&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should fail to pay royalty with unregistered receiver&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:42,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const unregisteredIpId = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nawait (0, chai_1.expect)(client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: unregisteredIpId,\n    payerIpId: childIpId,\n    token: generated_1.erc20Address[util_1.aeneid],\n    amount: 10 * 10 ** 2,\n})).to.be.rejectedWith(`The receiver IP with id ${unregisteredIpId} is not registered.`);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ef3912dc-b4f5-443b-8d9a-b37d303fe2f4&quot;,&quot;parentUUID&quot;:&quot;48896abd-0ce6-4787-809f-1dccc02113bf&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow the royalty vault to transfer its native tokens to a wallet address&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should allow the royalty vault to transfer its native tokens to a wallet address&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8685,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const royaltyVaultAddress = await client.royalty.getRoyaltyVaultAddress(parentIpId);\nconst royaltyVaultToken = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, royaltyVaultAddress);\nconst transferAmount = BigInt(10 * 10 ** 6); // 10 million tokens\n// Check initial balances of the vault token\nconst initialTargetBalance = await royaltyVaultToken.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst initialParentBalance = await royaltyVaultToken.balanceOf(parentIpId);\n(0, chai_1.expect)(Number(initialParentBalance)).greaterThanOrEqual(Number(transferAmount));\nconst transferResult = await client.ipAccount.execute({\n    to: royaltyVaultAddress,\n    value: 0,\n    ipId: parentIpId,\n    data: (0, viem_1.encodeFunctionData)({\n        abi: viem_1.erc20Abi,\n        functionName: \&quot;transfer\&quot;,\n        args: [util_1.TEST_WALLET_ADDRESS, transferAmount],\n    }),\n});\n(0, chai_1.expect)(transferResult.txHash).to.be.a(\&quot;string\&quot;);\n// Check final balances to confirm the transfer worked\nconst finalTargetBalance = await royaltyVaultToken.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst finalParentBalance = await royaltyVaultToken.balanceOf(parentIpId);\n(0, chai_1.expect)(finalTargetBalance).to.equal(initialTargetBalance + transferAmount, \&quot;Target wallet balance should increase by the transfer amount\&quot;);\n(0, chai_1.expect)(Number(finalParentBalance)).equal(Number(initialParentBalance - transferAmount));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ceff1cd4-aa86-40c4-91d4-5caf55f826f9&quot;,&quot;parentUUID&quot;:&quot;48896abd-0ce6-4787-809f-1dccc02113bf&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;096aeb42-5551-4d13-bb50-c061bb711572&quot;,&quot;821fb765-d60d-435d-aacb-26c4f59a4767&quot;,&quot;ef3912dc-b4f5-443b-8d9a-b37d303fe2f4&quot;,&quot;ceff1cd4-aa86-40c4-91d4-5caf55f826f9&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:18005,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;05969699-b69f-43b2-bed6-ed06bb7ac0a5&quot;,&quot;title&quot;:&quot;Revenue Queries&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should return claimable revenue amount&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Revenue Queries should return claimable revenue amount&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:156,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.royalty.claimableRevenue({\n    ipId: parentIpId,\n    claimer: util_1.TEST_WALLET_ADDRESS,\n    token: generated_1.erc20Address[util_1.aeneid],\n});\n(0, chai_1.expect)(response).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;99ae68d1-2b79-41d7-8d55-73b017653a49&quot;,&quot;parentUUID&quot;:&quot;05969699-b69f-43b2-bed6-ed06bb7ac0a5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail to get royalty vault address for unregistered IP&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Revenue Queries should fail to get royalty vault address for unregistered IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:46,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const unregisteredIpId = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nawait (0, chai_1.expect)(client.royalty.getRoyaltyVaultAddress(unregisteredIpId)).to.be.rejectedWith(`The royalty vault IP with id ${unregisteredIpId} is not registered.`);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ad124af5-022e-4af4-8630-b55b2f3da783&quot;,&quot;parentUUID&quot;:&quot;05969699-b69f-43b2-bed6-ed06bb7ac0a5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;99ae68d1-2b79-41d7-8d55-73b017653a49&quot;,&quot;ad124af5-022e-4af4-8630-b55b2f3da783&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:202,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;70572b83-430e-43bc-b7da-0ce94128e312&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should return zero for claimable revenue with invalid token&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Error Cases should return zero for claimable revenue with invalid token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:149,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.royalty.claimableRevenue({\n    ipId: parentIpId,\n    claimer: util_1.TEST_WALLET_ADDRESS,\n    token: \&quot;0x0000000000000000000000000000000000000000\&quot;,\n});\n(0, chai_1.expect)(response).to.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2184f7b4-db2a-4c3a-bd94-a0af92b6a286&quot;,&quot;parentUUID&quot;:&quot;70572b83-430e-43bc-b7da-0ce94128e312&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;2184f7b4-db2a-4c3a-bd94-a0af92b6a286&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:149,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;3ae08655-339a-41bf-aef0-b89f70b9133a&quot;,&quot;title&quot;:&quot;ClaimAllRevenue With WIP&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;ClaimAllRevenue With WIP\&quot;&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions ClaimAllRevenue With WIP \&quot;before all\&quot; hook in \&quot;ClaimAllRevenue With WIP\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:28619,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// set up\n// minting Fee: 100, 10% LAP rev share, A expect to get 120 WIP\n// A -&gt; B -&gt; C -&gt; D\nconst txData = await client.nftClient.createNFTCollection({\n    name: \&quot;free-collection\&quot;,\n    symbol: \&quot;FREE\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: viem_1.zeroAddress,\n});\nspgNftContract = txData.spgNftContract;\nconst retA = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 100n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 100n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nipA = retA.ipId;\nlicenseId = retA.licenseTermsIds[0];\nconst retB = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipA],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\nipB = retB.ipId;\nconst retC = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipB],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\nipC = retC.ipId;\nawait client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipC],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;705bd975-a780-4f12-a850-bb415912a9fb&quot;,&quot;parentUUID&quot;:&quot;3ae08655-339a-41bf-aef0-b89f70b9133a&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should claim all revenue&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions ClaimAllRevenue With WIP should claim all revenue&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13030,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const ret = await client.royalty.claimAllRevenue({\n    ancestorIpId: ipA,\n    claimer: ipA,\n    childIpIds: [ipB, ipC],\n    royaltyPolicies: [generated_1.royaltyPolicyLapAddress[util_1.aeneid], generated_1.royaltyPolicyLapAddress[util_1.aeneid]],\n    currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n});\n(0, chai_1.expect)(ret.txHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(ret.claimedTokens[0].amount).to.equal(120n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e5c9ec73-4275-402c-87d3-188dac05b432&quot;,&quot;parentUUID&quot;:&quot;3ae08655-339a-41bf-aef0-b89f70b9133a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;e5c9ec73-4275-402c-87d3-188dac05b432&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13030,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;4bc5d717-3478-449f-b92c-01ac96a32136&quot;,&quot;title&quot;:&quot;BatchClaimAllRevenue With WIP&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;BatchClaimAllRevenue With WIP\&quot;&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions BatchClaimAllRevenue With WIP \&quot;before all\&quot; hook in \&quot;BatchClaimAllRevenue With WIP\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:42505,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nanotherAddress = derivedClient.address;\nawait client.wipClient.deposit({\n    amount: (0, viem_1.parseEther)(\&quot;5\&quot;),\n});\n/**\n * Asset Hierarchy Setup for Revenue Collection Tests\n *\n * Overview:\n * This test setup creates two distinct IP asset hierarchies (IpA and IpB) to demonstrate\n * different revenue collection scenarios using LAP (Licensing Agreement Policy) and LRP\n * (Licensing Revenue Policy) respectively.\n *\n * IpA Hierarchy (LAP - Licensing Agreement Policy):                           IpB Hierarchy (LRP - Licensing Revenue Policy):\n *           \n *  IpA (Parent) - Total Expected Revenue: 130 WIP                         IpB (Parent) - Total Expected Revenue: 330 WIP              \n *           \n *  Revenue Sources:                                                       Revenue Sources:                                            \n *   Minting Fee: 100 WIP                                                Minting Fee: 150 WIP                                    \n *   Revenue Share (ipA2-&gt;ipA1): 10 WIP (10% LAP)                        LRP Revenue Share: 10%                                  \n *   Revenue Share (ipA3-&gt;ipA2): 10 WIP (10% LAP)                        Total Revenue: 330 WIP                                  \n *   Direct Payment (ipA3): 10 WIP (10% LAP)                                From ipB1: 150 WIP + 10% revenue share               \n *                                                                             From ipB2: 150 WIP + 10% revenue share               \n *                                                                                                                                     \n * | Ownership Distribution:                                               |                                                             \n *   Wallet Address: 50%  65 WIP                                        Revenue Flow:                                               \n *   Another Address: 50% 65 WIP                                        ipB3                                                        \n *                                                                          ipB1                                                  \n *  Revenue Flow:                                                           ipB2 &gt; ipB (collects 330 WIP)                       \n *  ipA3                                                                                                                               \n *   &gt; ipA2 (20% LAP) &gt; ipA1 (10% LAP) &gt; ipA                                                                                    \n *        &gt; Direct Payment: 100 WIP                                                                                                 \n *           \n */\nconst txData = await client.nftClient.createNFTCollection({\n    name: \&quot;free-collection\&quot;,\n    symbol: \&quot;FREE\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: viem_1.zeroAddress,\n});\nspgNftContract = txData.spgNftContract;\n// 1. Register ipA\nconst ret1A = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 100n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 100n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 50,\n        },\n        {\n            recipient: anotherAddress,\n            percentage: 50,\n        },\n    ],\n});\nipA = ret1A.ipId;\nlicenseId = ret1A.licenseTermsIds[0];\n// 2. Register ipB\nconst ret1B = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n                defaultMintingFee: 150n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 150n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nipB = ret1B.ipId;\nlicenseId1 = ret1B.licenseTermsIds[0];\n// 3. Register ipA1 from ipA and ipB1 from ipB\nconst { results: ret2 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB],\n                licenseTermsIds: [licenseId1],\n            },\n        },\n    ],\n});\nipA1 = ret2[0].ipId;\nipB1 = ret2[1].ipId;\n// 4. Register ipA2 from ipA1 and ipB2 from ipB\nconst { results: ret3 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA1],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB],\n                licenseTermsIds: [licenseId1],\n            },\n        },\n    ],\n});\nipA2 = ret3[0].ipId;\nipB2 = ret3[1].ipId;\n// 5. Register ipA3 from ipA2 and ipB3 from ipB1 and ipB2\nconst { results: ret4 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA2],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB1, ipB2],\n                licenseTermsIds: [licenseId1, licenseId1],\n            },\n        },\n    ],\n});\nipA3 = ret4[0].ipId;\n// 6. Pay royalty on behalf of ipA2 to ipA3\nawait client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: ipA2,\n    payerIpId: ipA3,\n    token: common_1.WIP_TOKEN_ADDRESS,\n    amount: 100n,\n});\nconst balance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nawait client.wipClient.withdraw({\n    amount: balance,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;34eb2688-0f7f-4706-8527-555b895152bf&quot;,&quot;parentUUID&quot;:&quot;4bc5d717-3478-449f-b92c-01ac96a32136&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should batch claim all revenue&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions BatchClaimAllRevenue With WIP should batch claim all revenue&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13286,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const anotherAddressWipBalanceBefore = await client.wipClient.balanceOf(anotherAddress);\nconst result = await client.royalty.batchClaimAllRevenue({\n    ancestorIps: [\n        {\n            ipId: ipA,\n            claimer: util_1.TEST_WALLET_ADDRESS,\n            childIpIds: [ipA1, ipA2],\n            royaltyPolicies: [generated_1.royaltyPolicyLapAddress[util_1.aeneid], generated_1.royaltyPolicyLapAddress[util_1.aeneid]],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n        },\n        {\n            ipId: ipA,\n            claimer: anotherAddress,\n            childIpIds: [],\n            royaltyPolicies: [],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS],\n        },\n        {\n            ipId: ipB,\n            claimer: ipB,\n            childIpIds: [ipB1, ipB2],\n            royaltyPolicies: [generated_1.royaltyPolicyLrpAddress[util_1.aeneid], generated_1.royaltyPolicyLrpAddress[util_1.aeneid]],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n        },\n    ],\n});\nconst anotherAddressWipBalanceAfter = await client.wipClient.balanceOf(anotherAddress);\nconst walletWipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(result.txHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.claimedTokens[0].amount).to.equal(65n);\n(0, chai_1.expect)(result.claimedTokens[1].amount).to.equal(65n);\n(0, chai_1.expect)(result.claimedTokens[2].amount).to.equal(330n);\n(0, chai_1.expect)(walletWipBalanceAfter).to.equal(0n);\n(0, chai_1.expect)(anotherAddressWipBalanceAfter).to.equal(anotherAddressWipBalanceBefore + 65n);\n// Note: The final wallet balance cannot be precisely calculated because:\n// The test involves multiple transactions (claimAllRevenue, token transfers, etc.)\n// batchClaimAllRevenue only returns receipts for claimAllRevenue calls\n// Additional gas costs and token transfers occur outside the returned receipts&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;814f2d62-2eda-4870-9ce3-8111723b883e&quot;,&quot;parentUUID&quot;:&quot;4bc5d717-3478-449f-b92c-01ac96a32136&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;814f2d62-2eda-4870-9ce3-8111723b883e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13286,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;5adbe878-1bc2-4c63-9ca0-3fb08684fb53&quot;,&quot;title&quot;:&quot;WIP Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;WIP Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;WIP Functions \&quot;before all\&quot; hook in \&quot;WIP Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7f3c3d13-4baa-4574-8bb8-a3e19513f89f&quot;,&quot;parentUUID&quot;:&quot;5adbe878-1bc2-4c63-9ca0-3fb08684fb53&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;0f5565a5-2638-4f91-94a6-866cf4a0ea27&quot;,&quot;title&quot;:&quot;deposit&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should deposit 0.01 WIP&quot;,&quot;fullTitle&quot;:&quot;WIP Functions deposit should deposit 0.01 WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4481,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const ipAmt = (0, viem_1.parseEther)(\&quot;0.01\&quot;);\nconst balanceBefore = await client.getWalletBalance();\nconst wipBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst rsp = await client.wipClient.deposit({\n    amount: ipAmt,\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.equal(wipBefore + ipAmt);\nconst gasCost = rsp.receipt.gasUsed * rsp.receipt.effectiveGasPrice;\n(0, chai_1.expect)(balanceAfter).to.equal(balanceBefore - ipAmt - gasCost);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;68aaae2d-38bc-49b7-bc7e-daa98289da9b&quot;,&quot;parentUUID&quot;:&quot;0f5565a5-2638-4f91-94a6-866cf4a0ea27&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;68aaae2d-38bc-49b7-bc7e-daa98289da9b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4481,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;4b5b00df-2cfb-48eb-a77a-c7b5d1a0de35&quot;,&quot;title&quot;:&quot;transfer&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should transfer WIP&quot;,&quot;fullTitle&quot;:&quot;WIP Functions transfer should transfer WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4330,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const rsp = await client.wipClient.transfer({\n    to: util_1.TEST_WALLET_ADDRESS,\n    amount: (0, viem_1.parseEther)(\&quot;0.01\&quot;),\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n//Due to approve cannot approve msy.sender, so skip transferFrom test&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;40e0553b-175d-4bd7-b8a2-2edf6b7e259c&quot;,&quot;parentUUID&quot;:&quot;4b5b00df-2cfb-48eb-a77a-c7b5d1a0de35&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;40e0553b-175d-4bd7-b8a2-2edf6b7e259c&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4330,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;3fde25a7-be5c-43d9-bf41-ff79c38c59ba&quot;,&quot;title&quot;:&quot;withdraw&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should withdrawal WIP&quot;,&quot;fullTitle&quot;:&quot;WIP Functions withdraw should withdrawal WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4508,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const balanceBefore = await client.getWalletBalance();\nconst wipBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst rsp = await client.wipClient.withdraw({\n    amount: wipBefore,\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.equal(0n);\nconst balanceAfter = await client.getWalletBalance();\nconst gasCost = rsp.receipt.gasUsed * rsp.receipt.effectiveGasPrice;\n(0, chai_1.expect)(balanceAfter).to.equal(balanceBefore + wipBefore - gasCost);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1f68637c-7c12-40d4-ad6e-daeef9dad2fc&quot;,&quot;parentUUID&quot;:&quot;3fde25a7-be5c-43d9-bf41-ff79c38c59ba&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1f68637c-7c12-40d4-ad6e-daeef9dad2fc&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4508,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:300000}],&quot;meta&quot;:{&quot;mocha&quot;:{&quot;version&quot;:&quot;10.8.2&quot;},&quot;mochawesome&quot;:{&quot;options&quot;:{&quot;quiet&quot;:false,&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;saveHtml&quot;:true,&quot;saveJson&quot;:true,&quot;consoleReporter&quot;:&quot;spec&quot;,&quot;useInlineDiffs&quot;:false,&quot;code&quot;:true},&quot;version&quot;:&quot;7.1.4&quot;},&quot;marge&quot;:{&quot;version&quot;:&quot;6.3.2&quot;}}}" data-config="{&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;reportDir&quot;:&quot;mochawesome-report&quot;,&quot;reportTitle&quot;:&quot;core-sdk&quot;,&quot;reportPageTitle&quot;:&quot;Mochawesome Report&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;cdn&quot;:false,&quot;charts&quot;:false,&quot;enableCharts&quot;:false,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;showPassed&quot;:true,&quot;showFailed&quot;:true,&quot;showPending&quot;:true,&quot;showSkipped&quot;:false,&quot;showHooks&quot;:&quot;failed&quot;,&quot;saveJson&quot;:true,&quot;saveHtml&quot;:true,&quot;dev&quot;:false,&quot;assetsDir&quot;:&quot;mochawesome-report/assets&quot;,&quot;jsonFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/mochawesome-report/mochawesome.json&quot;,&quot;htmlFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/mochawesome-report/mochawesome.html&quot;}"><div id="report"></div><script src="assets/app.js"></script></body></html>