# v1.4.4 Release Notes

## New Features

### Account Abstraction (AA) Wallet Support — `txHashResolver`

Added support for Account Abstraction wallets (e.g. **ZeroDev**, **Dynamic Global Wallet**) via a new optional `txHashResolver` configuration parameter.

#### Problem

When using AA wallets, `writeContract` returns a **UserOperation hash** instead of a standard **transaction hash**. The SDK's `waitForTransactionReceipt` only works with regular transaction hashes, causing AA wallet transactions to fail silently or hang.

#### Solution

A new `txHashResolver` option can be passed when creating a `StoryClient`. This function resolves UserOperation hashes into on-chain transaction hashes before the SDK waits for receipts. The resolver is applied transparently — **all existing SDK methods work without any changes**.

#### Usage

**Normal wallets** — no changes needed:

```typescript
const client = StoryClient.newClient({
  transport: http("https://aeneid.storyrpc.io"),
  account: privateKeyToAccount("0x..."),
});
```

**ZeroDev AA wallet — Using Kernel Client directly (recommended)**:

ZeroDev's `createKernelAccountClient` returns a viem smart account client whose `writeContract` internally sends the UserOperation, waits for the bundler to include it on-chain, and returns the **real tx hash**. Therefore **`txHashResolver` is NOT needed** — simply pass the kernel client as the wallet:

```typescript
import { createKernelAccountClient } from "@zerodev/sdk";

const kernelClient = await createKernelAccountClient({ /* ... */ });

const client = StoryClient.newClientUseWallet({
  transport: http("https://aeneid.storyrpc.io"),
  wallet: kernelClient,
  // No txHashResolver needed — kernel client handles it internally
});

// All SDK methods work as usual
const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({
  spgNftContract: "0x...",
  terms: [],
});
```

**Raw UserOp wallet + txHashResolver (for AA wallets that return userOpHash)**:

Some AA wallet integrations return the **UserOperation hash** directly from `writeContract` without internally waiting for the bundler receipt. For these wallets, configure `txHashResolver` to convert the userOpHash into the real on-chain tx hash:

```typescript
const client = StoryClient.newClientUseWallet({
  transport: http("https://aeneid.storyrpc.io"),
  wallet: rawAAWallet, // writeContract returns userOpHash
  txHashResolver: async (userOpHash) => {
    const receipt = await bundlerClient.waitForUserOperationReceipt({
      hash: userOpHash,
    });
    return receipt.receipt.transactionHash;
  },
});
```

> **How to tell?** If the hash returned by the AA wallet's `writeContract` cannot be found as a transaction on a block explorer, it is a userOpHash and you need `txHashResolver`. If it can be found on-chain directly, the wallet already handles resolution internally and no resolver is needed.

**Dynamic Global Wallet**:

```typescript
const client = StoryClient.newClientUseWallet({
  transport: http("https://aeneid.storyrpc.io"),
  wallet: dynamicWalletClient,
  txHashResolver: async (userOpHash) => {
    // Use Dynamic's bundler client to resolve the hash
    const receipt = await dynamicBundlerClient.waitForUserOperationReceipt({
      hash: userOpHash,
    });
    return receipt.receipt.transactionHash;
  },
});
```

#### Supported Factory Methods

`txHashResolver` is supported by all three client creation methods:

- `StoryClient.newClient({ ..., txHashResolver })`
- `StoryClient.newClientUseWallet({ ..., txHashResolver })`
- `StoryClient.newClientUseAccount({ ..., txHashResolver })`

#### API Reference

```typescript
/**
 * A function that resolves a hash returned by writeContract into an actual
 * transaction hash that can be used with waitForTransactionReceipt.
 *
 * @param hash - The hash returned by writeContract (could be a userOpHash or txHash)
 * @returns The resolved on-chain transaction hash
 */
type TxHashResolver = (hash: Hash) => Promise<Hash>;
```

## Changed Files

| File | Change |
|------|--------|
| `packages/core-sdk/src/types/config.ts` | Added `TxHashResolver` type; added `txHashResolver` to `StoryConfig`, `UseWalletStoryConfig`, `UseAccountStoryConfig` |
| `packages/core-sdk/src/client.ts` | Added `applyTxHashResolver()` method; patched `rpcClient.waitForTransactionReceipt` when resolver is provided; forwarded resolver in factory methods |
| `packages/core-sdk/test/unit/client.test.ts` | Added unit tests that verify resolver wiring, hash transformation, and constructor-time patching |
| `packages/core-sdk/test/integration/txHashResolver.test.ts` | ZeroDev E2E integration tests (6 passing), covering both AA wallet modes |
| `packages/core-sdk/package.json` | Added `@zerodev/sdk`, `@zerodev/ecdsa-validator` as devDependencies |

## Test Coverage Notes

- **Unit tests**: Validate that `txHashResolver` is invoked before receipt polling and that the resolved hash is used for receipt lookup.
- **Integration tests — Pass-through & Simulated**: Cover normal wallet pass-through and simulated AA hash mapping behavior.
- **Integration tests — ZeroDev E2E (2 scenarios)**:
  - **Kernel client as wallet**: Verifies that `writeContract` returns a real txHash and the SDK works correctly without a resolver.
  - **Raw userOp wallet + txHashResolver**: Uses a custom wallet wrapper (whose `writeContract` returns a userOpHash) to verify end-to-end that the resolver converts the userOpHash into a real on-chain txHash.
- ZeroDev E2E tests require `BUNDLER_RPC_URL` and `WALLET_PRIVATE_KEY` in `.env`. Tests are automatically skipped when these are not configured.
