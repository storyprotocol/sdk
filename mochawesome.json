{
  "stats": {
    "suites": 61,
    "tests": 182,
    "passes": 181,
    "pending": 1,
    "failures": 0,
    "start": "2025-11-17T08:19:19.227Z",
    "end": "2025-11-17T09:01:57.568Z",
    "duration": 2558341,
    "testsRegistered": 182,
    "passPercent": 100,
    "pendingPercent": 0.5494505494505495,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false
  },
  "results": [
    {
      "uuid": "4550960a-ec87-4f8f-94d6-a07a2e751a4b",
      "title": "",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "f08e9ae9-86c3-4d00-a88e-14353a0e9ce8",
          "title": "Dispute Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts",
          "file": "/test/integration/dispute.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Dispute Functions\"",
              "fullTitle": "Dispute Functions \"before all\" hook in \"Dispute Functions\"",
              "timedOut": false,
              "duration": 9145,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "clientA = (0, util_1.getStoryClient)();\nconst derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nclientB = derivedClient.clientB;\nminimumBond = await (0, oov3_1.getMinimumBond)(util_1.publicClient, new generated_1.ArbitrationPolicyUmaClient(util_1.publicClient, util_1.walletClient), src_1.WIP_TOKEN_ADDRESS);\nconst txData = await clientA.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nconst nftContract = txData.spgNftContract;\nipIdB = (await clientB.ipAsset.mintAndRegisterIp({\n    spgNftContract: nftContract,\n})).ipId;",
              "err": {},
              "uuid": "ac35b5e2-cae0-480e-971a-9ca301ea5db5",
              "parentUUID": "f08e9ae9-86c3-4d00-a88e-14353a0e9ce8",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [
            {
              "title": "it should not cancel a dispute (yet)",
              "fullTitle": "Dispute Functions it should not cancel a dispute (yet)",
              "timedOut": false,
              "duration": 9142,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const raiseResponse = await clientA.dispute.raiseDispute({\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 2592000,\n    bond: minimumBond,\n});\nawait (0, chai_1.expect)(clientA.dispute.cancelDispute({\n    disputeId: raiseResponse.disputeId,\n})).to.be.rejected;",
              "err": {},
              "uuid": "af71eaa6-da59-4a66-bf9c-d4336ee234fc",
              "parentUUID": "f08e9ae9-86c3-4d00-a88e-14353a0e9ce8",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [
            {
              "uuid": "b997598d-1539-41a0-9694-0dc3e569fbf1",
              "title": "raiseDispute and counter dispute",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts",
              "file": "/test/integration/dispute.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should raise a dispute",
                  "fullTitle": "Dispute Functions raiseDispute and counter dispute should raise a dispute",
                  "timedOut": false,
                  "duration": 13087,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const raiseDisputeRequest = {\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 2592000,\n    bond: minimumBond,\n};\nconst response = await clientA.dispute.raiseDispute(raiseDisputeRequest);\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(response.disputeId).to.be.a(\"bigint\");\ndisputeId = response.disputeId;",
                  "err": {},
                  "uuid": "28f82908-0037-4068-a0c5-326600c124a4",
                  "parentUUID": "b997598d-1539-41a0-9694-0dc3e569fbf1",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should validate all enum values defined in DisputeTargetTag",
                  "fullTitle": "Dispute Functions raiseDispute and counter dispute should validate all enum values defined in DisputeTargetTag",
                  "timedOut": false,
                  "duration": 198,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const allTags = Object.values(src_1.DisputeTargetTag);\nfor (const tag of allTags) {\n    const tagHex = (0, viem_1.toHex)(tag, { size: 32 });\n    const { allowed } = await clientA.dispute.disputeModuleClient.isWhitelistedDisputeTag({\n        tag: tagHex,\n    });\n    if (tag === src_1.DisputeTargetTag.IN_DISPUTE) {\n        (0, chai_1.expect)(allowed).equal(false);\n    }\n    else {\n        (0, chai_1.expect)(allowed).equal(true);\n    }\n}",
                  "err": {},
                  "uuid": "d9e19c01-3bb6-4d60-b582-0168e784455f",
                  "parentUUID": "b997598d-1539-41a0-9694-0dc3e569fbf1",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should raise disputes with different DisputeTargetTag enum values",
                  "fullTitle": "Dispute Functions raiseDispute and counter dispute should raise disputes with different DisputeTargetTag enum values",
                  "timedOut": false,
                  "duration": 44449,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const allTags = Object.values(src_1.DisputeTargetTag);\nfor (const tag of allTags) {\n    const raiseDisputeRequest = {\n        targetIpId: ipIdB,\n        cid: await generateCID(),\n        targetTag: tag,\n        liveness: 2592000,\n        bond: minimumBond,\n    };\n    if (tag === src_1.DisputeTargetTag.IN_DISPUTE) {\n        await (0, chai_1.expect)(clientA.dispute.raiseDispute(raiseDisputeRequest)).to.be.rejectedWith(\"The target tag IN_DISPUTE is not whitelisted\");\n    }\n    else {\n        const response = await clientA.dispute.raiseDispute(raiseDisputeRequest);\n        (0, chai_1.expect)(response.txHash).to.be.a(\"string\");\n        (0, chai_1.expect)(response.disputeId).to.be.a(\"bigint\");\n    }\n}",
                  "err": {},
                  "uuid": "dcec5e83-23c6-4f17-bdc4-d615babe99ea",
                  "parentUUID": "b997598d-1539-41a0-9694-0dc3e569fbf1",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should reject a dispute with an invalid tag not defined in the enum",
                  "fullTitle": "Dispute Functions raiseDispute and counter dispute should reject a dispute with an invalid tag not defined in the enum",
                  "timedOut": false,
                  "duration": 140,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(clientA.dispute.raiseDispute({\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: \"INVALID_TAG\",\n    liveness: 2592000,\n    bond: minimumBond,\n})).to.be.rejectedWith(\"The target tag INVALID_TAG is not whitelisted\");",
                  "err": {},
                  "uuid": "fa0a35a5-1b7d-4e55-9b91-c9170a435fe6",
                  "parentUUID": "b997598d-1539-41a0-9694-0dc3e569fbf1",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to counter existing dispute once",
                  "fullTitle": "Dispute Functions raiseDispute and counter dispute should be able to counter existing dispute once",
                  "timedOut": false,
                  "duration": 17619,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const assertionId = await clientB.dispute.disputeIdToAssertionId(disputeId);\nconst counterEvidenceCID = await generateCID();\nconst ret = await clientB.dispute.disputeAssertion({\n    ipId: ipIdB,\n    assertionId,\n    counterEvidenceCID,\n});\n(0, chai_1.expect)(ret.txHash).to.be.a(\"string\");\n// should throw error if attempting to dispute assertion again\nawait (0, chai_1.expect)(clientB.dispute.disputeAssertion({\n    ipId: ipIdB,\n    assertionId,\n    counterEvidenceCID,\n})).to.be.rejected;",
                  "err": {},
                  "uuid": "df1042a8-9cd9-40c4-917c-21442c7dfdba",
                  "parentUUID": "b997598d-1539-41a0-9694-0dc3e569fbf1",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "28f82908-0037-4068-a0c5-326600c124a4",
                "d9e19c01-3bb6-4d60-b582-0168e784455f",
                "dcec5e83-23c6-4f17-bdc4-d615babe99ea",
                "fa0a35a5-1b7d-4e55-9b91-c9170a435fe6",
                "df1042a8-9cd9-40c4-917c-21442c7dfdba"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 75493,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "9bf5855b-7617-437f-b6ac-ee0ad6e73ad2",
              "title": "Dispute resolution",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts",
              "file": "/test/integration/dispute.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"Dispute resolution\"",
                  "fullTitle": "Dispute Functions Dispute resolution \"before each\" hook in \"Dispute resolution\"",
                  "timedOut": false,
                  "duration": 34904,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Setup NFT collection\nconst txData = await clientA.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\n// Get parent IP ID and license terms ID\nconst ipIdAndLicenseResponse = await clientA.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContract,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: src_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: generated_1.evenSplitGroupPoolAddress[util_1.aeneid],\n            },\n        },\n    ],\n});\nparentIpId = ipIdAndLicenseResponse.ipId;\nlicenseTermsId = ipIdAndLicenseResponse.licenseTermsIds[0];\n//Create a derivative ip\nconst derivativeIpIdResponse1 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\nchildIpId = derivativeIpIdResponse1.ipId;\n// Create a second derivative ip\nconst derivativeIpIdResponse2 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\nchildIpId2 = derivativeIpIdResponse2.ipId;\n// Raise a dispute\nconst response = await clientA.dispute.raiseDispute({\n    targetIpId: parentIpId,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 1,\n    bond: minimumBond,\n});\ndisputeId = response.disputeId;\n// This timeout guarantees that the assertion is expired\n// its intended to be longer than the current block time\n// so it won't be included in the same block\nawait new Promise((resolve) => setTimeout(resolve, 3000));",
                  "err": {},
                  "uuid": "8d509cb4-6b35-4947-8d19-fdee4ebf0819",
                  "parentUUID": "9bf5855b-7617-437f-b6ac-ee0ad6e73ad2",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should tag infringing ip",
                  "fullTitle": "Dispute Functions Dispute resolution should tag infringing ip",
                  "timedOut": false,
                  "duration": 12781,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Tag derivative IP as infringing\nconst results = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: childIpId2,\n            disputeId: disputeId,\n        },\n    ],\n});\n(0, chai_1.expect)(results[0].txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "c179bb4e-70c7-4655-96c7-3242fd6a6aab",
                  "parentUUID": "9bf5855b-7617-437f-b6ac-ee0ad6e73ad2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should tag a single IP as infringing without using multicall",
                  "fullTitle": "Dispute Functions Dispute resolution should tag a single IP as infringing without using multicall",
                  "timedOut": false,
                  "duration": 12882,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "/**\n * Test Flow:\n * 1. Set judgment on an existing dispute to mark it as valid (did in `before each` block)\n * 2. Verify the dispute state changed correctly after judgment\n * 3. Try to tag a derivative IP using the judged dispute\n */\n// Step 1: Set judgment on an existing dispute to mark it as valid\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Step 2: Verify dispute state\n// The disputes() function returns multiple values about the dispute:\n// - targetTag: the tag we wanted to apply when raising the dispute\n// - currentTag: the current state of the dispute after judgment\n// After a successful judgment, currentTag should equal targetTag\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag); // Verify judgment was recorded correctly\n// Step 3: Attempt to tag a derivative IP\n// This will fail if:\n// - The dispute is not in a valid state (still IN_DISPUTE or cleared)\n// - The IP we're trying to tag is not actually a derivative of the disputed IP\n// - The dispute has already been used to tag this IP\nconst response = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId, // The derivative IP to tag\n            disputeId: disputeId, // Using the judged dispute as basis for tagging\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: false, // Force single transaction instead of batch\n    },\n});\n// Verify we got the expected response\n(0, chai_1.expect)(response).to.have.lengthOf(1);\n(0, chai_1.expect)(response[0].txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "220a9cc4-c2f9-4a47-86d0-d9cfc30d2950",
                  "parentUUID": "9bf5855b-7617-437f-b6ac-ee0ad6e73ad2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should tag multiple IPs as infringing using multicall",
                  "fullTitle": "Dispute Functions Dispute resolution should tag multiple IPs as infringing using multicall",
                  "timedOut": false,
                  "duration": 25590,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const disputeResponse = await clientA.dispute.raiseDispute({\n    targetIpId: parentIpId,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 1,\n    bond: minimumBond,\n});\nconst testDisputeId = disputeResponse.disputeId;\nconst derivativeResponse2 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nconst newChildIpId = derivativeResponse2.ipId;\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, testDisputeId);\n// This timeout guarantees that the assertion is expired\n// its intended to be longer than the current block time\n// so it won't be included in the same block\nawait new Promise((resolve) => setTimeout(resolve, 3000));\nconst { currentTag, targetTag } = await getDisputeState(testDisputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst response = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: testDisputeId,\n        },\n        {\n            ipId: newChildIpId,\n            disputeId: testDisputeId,\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: true,\n    },\n});\n(0, chai_1.expect)(response).to.have.lengthOf(1);\n(0, chai_1.expect)(response[0].txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "41a181bb-2610-4936-965b-6242319ef0ce",
                  "parentUUID": "9bf5855b-7617-437f-b6ac-ee0ad6e73ad2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should tag multiple IPs without multicall when specified",
                  "fullTitle": "Dispute Functions Dispute resolution should tag multiple IPs without multicall when specified",
                  "timedOut": false,
                  "duration": 18597,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Create two new derivative IPs sequentially\nconst derivativeResponse3 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nconst derivativeResponse4 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst responses = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: derivativeResponse3.ipId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: derivativeResponse4.ipId,\n            disputeId: disputeId,\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: false,\n    },\n});\n(0, chai_1.expect)(responses).to.have.lengthOf(2);\n(0, chai_1.expect)(responses[0].txHash).to.be.a(\"string\");\n(0, chai_1.expect)(responses[1].txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "d10eac77-5a04-4b9c-a7b4-f3135c9cdce9",
                  "parentUUID": "9bf5855b-7617-437f-b6ac-ee0ad6e73ad2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail when trying to tag with invalid dispute ID",
                  "fullTitle": "Dispute Functions Dispute resolution should fail when trying to tag with invalid dispute ID",
                  "timedOut": false,
                  "duration": 41,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: 999999n,\n        },\n    ],\n})).to.be.rejected;",
                  "err": {},
                  "uuid": "65c22371-00a3-46be-bfb6-1ce61c09af02",
                  "parentUUID": "9bf5855b-7617-437f-b6ac-ee0ad6e73ad2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should resolve a dispute successfully when initiated by dispute initiator",
                  "fullTitle": "Dispute Functions Dispute resolution should resolve a dispute successfully when initiated by dispute initiator",
                  "timedOut": false,
                  "duration": 8893,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst response = await clientA.dispute.resolveDispute({\n    disputeId: disputeId,\n    data: \"0x\",\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "8f402c61-eda4-4684-b41f-a8e106e9ffb8",
                  "parentUUID": "9bf5855b-7617-437f-b6ac-ee0ad6e73ad2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail when non-initiator tries to resolve the dispute",
                  "fullTitle": "Dispute Functions Dispute resolution should fail when non-initiator tries to resolve the dispute",
                  "timedOut": false,
                  "duration": 46,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(clientB.dispute.resolveDispute({\n    disputeId: disputeId,\n    data: \"0x\",\n})).to.be.rejectedWith(\"NotDisputeInitiator\");",
                  "err": {},
                  "uuid": "f7ec3f32-4426-4d1c-95d1-45b81e34e6c3",
                  "parentUUID": "9bf5855b-7617-437f-b6ac-ee0ad6e73ad2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should propagate IMPROPER_REGISTRATION tag to derivative IPs",
                  "fullTitle": "Dispute Functions Dispute resolution should propagate IMPROPER_REGISTRATION tag to derivative IPs",
                  "timedOut": false,
                  "duration": 8844,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Verify the dispute state changed correctly\nconst { currentTag: parentCurrentTag, targetTag: parentTargetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(parentCurrentTag).to.equal(parentTargetTag);\n// Propagate the tag to both derivative IPs\nconst results = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: childIpId2,\n            disputeId: disputeId,\n        },\n    ],\n});\nconst logData = results[0].receipt?.logs[0].data;\nconst firstWord = logData.slice(0, 66);\nconst childDisputeId = BigInt(firstWord);\n// Verify successful tagging\n(0, chai_1.expect)(results[0].txHash).to.be.a(\"string\");\nconst { currentTag: childCurrentTag } = await getDisputeState(childDisputeId);\n// Convert the IMPROPER_USAGE tag to hex for comparison\nconst improperUsageTagHex = (0, viem_1.toHex)(src_1.DisputeTargetTag.IMPROPER_REGISTRATION, { size: 32 });\n// Verify both child IPs have the IMPROPER_USAGE tag by\n// fetching and comparing their dispute tags\n(0, chai_1.expect)(parentCurrentTag).to.equal(parentTargetTag);\n(0, chai_1.expect)(childCurrentTag).to.equal(improperUsageTagHex);",
                  "err": {},
                  "uuid": "b25571bd-32af-4cbb-8421-4ccc5d08affe",
                  "parentUUID": "9bf5855b-7617-437f-b6ac-ee0ad6e73ad2",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "c179bb4e-70c7-4655-96c7-3242fd6a6aab",
                "220a9cc4-c2f9-4a47-86d0-d9cfc30d2950",
                "41a181bb-2610-4936-965b-6242319ef0ce",
                "d10eac77-5a04-4b9c-a7b4-f3135c9cdce9",
                "65c22371-00a3-46be-bfb6-1ce61c09af02",
                "8f402c61-eda4-4684-b41f-a8e106e9ffb8",
                "f7ec3f32-4426-4d1c-95d1-45b81e34e6c3",
                "b25571bd-32af-4cbb-8421-4ccc5d08affe"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 87674,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [
            "af71eaa6-da59-4a66-bf9c-d4336ee234fc"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 9142,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "b24f4429-dbcb-415c-a184-3f87f35ceeee",
          "title": "Group Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts",
          "file": "/test/integration/group.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Group Functions\"",
              "fullTitle": "Group Functions \"before all\" hook in \"Group Functions\"",
              "timedOut": false,
              "duration": 4380,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();\n// Create NFT Collection\nspgNftContract = (await client.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \"test-uri\",\n})).spgNftContract;",
              "err": {},
              "uuid": "abfe662e-ca20-4948-8fb2-b23672a5cf17",
              "parentUUID": "b24f4429-dbcb-415c-a184-3f87f35ceeee",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "2ffbcfc5-bad3-42fb-99be-5d5e395391aa",
              "title": "Group Operations",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts",
              "file": "/test/integration/group.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Group Operations\"",
                  "fullTitle": "Group Functions Group Operations \"before all\" hook in \"Group Operations\"",
                  "timedOut": false,
                  "duration": 9192,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Create initial IP with license terms\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    allowDuplicates: false,\n    licenseTermsData,\n});\nlicenseTermsId = result.licenseTermsIds[0];\nipId = result.ipId;\n// Set licensing config\nawait client.license.setLicensingConfig({\n    ipId,\n    licenseTermsId,\n    licenseTemplate: generated_1.piLicenseTemplateAddress[util_1.aeneid],\n    licensingConfig: {\n        isSet: true,\n        mintingFee: 0n,\n        licensingHook: viem_1.zeroAddress,\n        hookData: viem_1.zeroAddress,\n        commercialRevShare: 0,\n        disabled: false,\n        expectMinimumGroupRewardShare: 0,\n        expectGroupRewardPool: groupPoolAddress,\n    },\n});",
                  "err": {},
                  "uuid": "451dc0c6-828d-4da4-a203-3da02bef5e2c",
                  "parentUUID": "2ffbcfc5-bad3-42fb-99be-5d5e395391aa",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully register group and attach license",
                  "fullTitle": "Group Functions Group Operations should successfully register group and attach license",
                  "timedOut": false,
                  "duration": 4397,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.groupClient.registerGroupAndAttachLicense({\n    groupPool: groupPoolAddress,\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n});\ngroupId = result.groupId;\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.groupId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "65a89304-778f-4a58-ac6b-53f9f1544155",
                  "parentUUID": "2ffbcfc5-bad3-42fb-99be-5d5e395391aa",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully mint, register IP, attach license and add to group",
                  "fullTitle": "Group Functions Group Operations should successfully mint, register IP, attach license and add to group",
                  "timedOut": false,
                  "duration": 4512,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.groupClient.mintAndRegisterIpAndAttachLicenseAndAddToGroup({\n    groupId,\n    spgNftContract,\n    licenseData: [\n        {\n            licenseTermsId,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: groupPoolAddress,\n            },\n        },\n    ],\n    maxAllowedRewardShare: 100,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "0368b86f-4f7a-4d26-bf95-f5d4b029bf52",
                  "parentUUID": "2ffbcfc5-bad3-42fb-99be-5d5e395391aa",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully register a basic group",
                  "fullTitle": "Group Functions Group Operations should successfully register a basic group",
                  "timedOut": false,
                  "duration": 4424,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.groupClient.registerGroup({\n    groupPool: groupPoolAddress,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.groupId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "4e734363-d861-4bb0-99be-e51052ed3225",
                  "parentUUID": "2ffbcfc5-bad3-42fb-99be-5d5e395391aa",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully register existing IP with license and add to group",
                  "fullTitle": "Group Functions Group Operations should successfully register existing IP with license and add to group",
                  "timedOut": false,
                  "duration": 9042,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(spgNftContract, \"test-metadata\");\nconst result = await client.groupClient.registerIpAndAttachLicenseAndAddToGroup({\n    groupId,\n    nftContract: spgNftContract,\n    tokenId,\n    licenseData: [\n        {\n            licenseTermsId,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: groupPoolAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "85ba7a6f-138d-44a6-b680-f132db745a93",
                  "parentUUID": "2ffbcfc5-bad3-42fb-99be-5d5e395391aa",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully register group with license and add multiple IPs",
                  "fullTitle": "Group Functions Group Operations should successfully register group with license and add multiple IPs",
                  "timedOut": false,
                  "duration": 4459,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.groupClient.registerGroupAndAttachLicenseAndAddIps({\n    groupPool: groupPoolAddress,\n    maxAllowedRewardShare: 50,\n    ipIds: [ipId],\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.groupId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "c716ae08-98da-46b1-b634-ab0ce45bf870",
                  "parentUUID": "2ffbcfc5-bad3-42fb-99be-5d5e395391aa",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail when trying to add unregistered IP to group",
                  "fullTitle": "Group Functions Group Operations should fail when trying to add unregistered IP to group",
                  "timedOut": false,
                  "duration": 40,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.groupClient.registerGroupAndAttachLicenseAndAddIps({\n    groupPool: groupPoolAddress,\n    maxAllowedRewardShare: 5,\n    ipIds: [viem_1.zeroAddress], // Invalid IP address\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n})).to.be.rejectedWith(\"Failed to register group and attach license and add ips\");",
                  "err": {},
                  "uuid": "b2b2f53d-b4af-427b-bc49-b0a9815cd139",
                  "parentUUID": "2ffbcfc5-bad3-42fb-99be-5d5e395391aa",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [
                {
                  "uuid": "f89aa399-aa2e-4fb7-8e83-32300c444f44",
                  "title": "Add IPs to Group and Remove IPs from Group",
                  "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts",
                  "file": "/test/integration/group.test.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should successfully add multiple IPs to group",
                      "fullTitle": "Group Functions Group Operations Add IPs to Group and Remove IPs from Group should successfully add multiple IPs to group",
                      "timedOut": false,
                      "duration": 13593,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const registerResult = await client.ipAsset.batchMintAndRegisterIpAssetWithPilTerms({\n    args: [\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n    ],\n});\nipIds = registerResult.results?.map((result) => result.ipId) ?? [];\nconst result = await client.groupClient.addIpsToGroup({\n    groupIpId: groupId,\n    ipIds: ipIds,\n    maxAllowedRewardSharePercentage: 55,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                      "err": {},
                      "uuid": "a4efd961-8c01-4463-87df-f74b2061db79",
                      "parentUUID": "f89aa399-aa2e-4fb7-8e83-32300c444f44",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully remove IPs from group",
                      "fullTitle": "Group Functions Group Operations Add IPs to Group and Remove IPs from Group should successfully remove IPs from group",
                      "timedOut": false,
                      "duration": 4378,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.groupClient.removeIpsFromGroup({\n    groupIpId: groupId,\n    ipIds: ipIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                      "err": {},
                      "uuid": "11e3bad9-5db3-4af0-8fde-93dfd0e59413",
                      "parentUUID": "f89aa399-aa2e-4fb7-8e83-32300c444f44",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should fail when trying to remove IPs from a non-existent group",
                      "fullTitle": "Group Functions Group Operations Add IPs to Group and Remove IPs from Group should fail when trying to remove IPs from a non-existent group",
                      "timedOut": false,
                      "duration": 4777,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const registerResult = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData,\n});\nconst testIpId = registerResult.ipId;\nconst nonExistentGroupId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.removeIpsFromGroup({\n    groupIpId: nonExistentGroupId,\n    ipIds: [testIpId],\n})).to.be.rejectedWith(\"Failed to remove IPs from group\");",
                      "err": {},
                      "uuid": "2307ceab-b173-41b3-b139-23c4d18510f5",
                      "parentUUID": "f89aa399-aa2e-4fb7-8e83-32300c444f44",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should fail when trying to remove non-existent IPs from a group",
                      "fullTitle": "Group Functions Group Operations Add IPs to Group and Remove IPs from Group should fail when trying to remove non-existent IPs from a group",
                      "timedOut": false,
                      "duration": 4458,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const groupResult = await client.groupClient.registerGroup({\n    groupPool: groupPoolAddress,\n});\nconst testGroupId = groupResult.groupId;\nconst nonExistentIpId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.removeIpsFromGroup({\n    groupIpId: testGroupId,\n    ipIds: [nonExistentIpId],\n})).to.be.rejectedWith(\"Failed to remove IPs from group\");",
                      "err": {},
                      "uuid": "b786d20d-7252-49cc-b994-91a8112e3568",
                      "parentUUID": "f89aa399-aa2e-4fb7-8e83-32300c444f44",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "a4efd961-8c01-4463-87df-f74b2061db79",
                    "11e3bad9-5db3-4af0-8fde-93dfd0e59413",
                    "2307ceab-b173-41b3-b139-23c4d18510f5",
                    "b786d20d-7252-49cc-b994-91a8112e3568"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 27206,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 300000
                }
              ],
              "passes": [
                "65a89304-778f-4a58-ac6b-53f9f1544155",
                "0368b86f-4f7a-4d26-bf95-f5d4b029bf52",
                "4e734363-d861-4bb0-99be-e51052ed3225",
                "85ba7a6f-138d-44a6-b680-f132db745a93",
                "c716ae08-98da-46b1-b634-ab0ce45bf870",
                "b2b2f53d-b4af-427b-bc49-b0a9815cd139"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 26874,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "c1b07b1b-2253-4056-af3f-a72d16bf82bf",
              "title": "Collect Royalty and Claim Reward",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts",
              "file": "/test/integration/group.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Collect Royalty and Claim Reward\"",
                  "fullTitle": "Group Functions Collect Royalty and Claim Reward \"before all\" hook in \"Collect Royalty and Claim Reward\"",
                  "timedOut": false,
                  "duration": 13248,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Register IP id\nconst result1 = await mintAndRegisterIpAssetWithPilTermsHelper();\nipId = result1.ipId;\nlicenseTermsId = result1.licenseTermsIds[0];\n// Register group id\ngroupIpId = await registerGroupAndAttachLicenseHelper(licenseTermsId, [ipId]);",
                  "err": {},
                  "uuid": "afcd0c8c-8cb4-49a5-bb1d-f66d5c4de891",
                  "parentUUID": "c1b07b1b-2253-4056-af3f-a72d16bf82bf",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully collect royalties",
                  "fullTitle": "Group Functions Collect Royalty and Claim Reward should successfully collect royalties",
                  "timedOut": false,
                  "duration": 22068,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Mint and register child IP id\nconst childIpId = await mintAndRegisterIpAndMakeDerivativeHelper(groupIpId, licenseTermsId);\n// Pay royalties from child IP id to group IP id and transfer to vault\nawait payRoyaltyAndTransferToVaultHelper(childIpId, groupIpId, src_1.WIP_TOKEN_ADDRESS, 100n);\n// Collect royalties\nconst result = await client.groupClient.collectRoyalties({\n    groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.collectedRoyalties).to.equal(10n);",
                  "err": {},
                  "uuid": "4b0b90d9-b3f5-4f3f-8609-872a0e99d381",
                  "parentUUID": "c1b07b1b-2253-4056-af3f-a72d16bf82bf",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully get claimable reward",
                  "fullTitle": "Group Functions Collect Royalty and Claim Reward should successfully get claimable reward",
                  "timedOut": false,
                  "duration": 41,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.groupClient.getClaimableReward({\n    groupIpId: groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n});\n(0, chai_1.expect)(result).to.deep.equal([10n]);",
                  "err": {},
                  "uuid": "20bd5961-5c88-4ad7-8eab-c7a41028ef7b",
                  "parentUUID": "c1b07b1b-2253-4056-af3f-a72d16bf82bf",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully claim reward",
                  "fullTitle": "Group Functions Collect Royalty and Claim Reward should successfully claim reward",
                  "timedOut": false,
                  "duration": 9079,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Mint license tokens to the IP id which doesn't have a royalty vault\nawait client.license.mintLicenseTokens({\n    licensorIpId: ipId,\n    licenseTermsId,\n    amount: 100,\n    maxMintingFee: 1,\n    maxRevenueShare: 100,\n});\n// Claim reward\nconst result = await client.groupClient.claimReward({\n    groupIpId: groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.claimedReward?.[0].amount[0]).to.equal(10n);",
                  "err": {},
                  "uuid": "01b7ddc7-106c-4082-8251-4a21023a42fe",
                  "parentUUID": "c1b07b1b-2253-4056-af3f-a72d16bf82bf",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail when trying to claim reward for a non-existent group",
                  "fullTitle": "Group Functions Collect Royalty and Claim Reward should fail when trying to claim reward for a non-existent group",
                  "timedOut": false,
                  "duration": 40,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const nonExistentGroupId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.claimReward({\n    groupIpId: nonExistentGroupId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n})).to.be.rejectedWith(\"Failed to claim reward\");",
                  "err": {},
                  "uuid": "68ab0e01-56bf-4a11-b513-6f29bf0840c5",
                  "parentUUID": "c1b07b1b-2253-4056-af3f-a72d16bf82bf",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail when trying to claim reward with invalid token address",
                  "fullTitle": "Group Functions Collect Royalty and Claim Reward should fail when trying to claim reward with invalid token address",
                  "timedOut": false,
                  "duration": 39,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const invalidTokenAddress = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.claimReward({\n    groupIpId: groupIpId,\n    currencyToken: invalidTokenAddress,\n    memberIpIds: [ipId],\n})).to.be.rejectedWith(\"Failed to claim reward\");",
                  "err": {},
                  "uuid": "54cd7481-4dc8-412a-bf09-ad7873883dc1",
                  "parentUUID": "c1b07b1b-2253-4056-af3f-a72d16bf82bf",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully collect royalties and claim reward in one transaction",
                  "fullTitle": "Group Functions Collect Royalty and Claim Reward should successfully collect royalties and claim reward in one transaction",
                  "timedOut": false,
                  "duration": 62493,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const ipIds = [];\nconst result1 = await mintAndRegisterIpAssetWithPilTermsHelper();\nconst result2 = await mintAndRegisterIpAssetWithPilTermsHelper();\nipIds.push(result1.ipId);\nipIds.push(result2.ipId);\nlicenseTermsId = result1.licenseTermsIds[0];\nconst groupId = await registerGroupAndAttachLicenseHelper(licenseTermsId, ipIds);\nconst childIpId1 = await mintAndRegisterIpAndMakeDerivativeHelper(groupId, licenseTermsId);\nconst childIpId2 = await mintAndRegisterIpAndMakeDerivativeHelper(groupId, licenseTermsId);\nawait payRoyaltyAndTransferToVaultHelper(childIpId1, groupId, src_1.WIP_TOKEN_ADDRESS, 100n);\nawait payRoyaltyAndTransferToVaultHelper(childIpId2, groupId, src_1.WIP_TOKEN_ADDRESS, 100n);\nconst result = await client.groupClient.collectAndDistributeGroupRoyalties({\n    groupIpId: groupId,\n    currencyTokens: [src_1.WIP_TOKEN_ADDRESS],\n    memberIpIds: ipIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.collectedRoyalties?.[0].amount).to.equal(20n);\n(0, chai_1.expect)(result.royaltiesDistributed?.[0].amount).to.equal(10n);\n(0, chai_1.expect)(result.royaltiesDistributed?.[1].amount).to.equal(10n);",
                  "err": {},
                  "uuid": "287f4628-d03d-4c0c-b80e-951ffcd23b8e",
                  "parentUUID": "c1b07b1b-2253-4056-af3f-a72d16bf82bf",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "4b0b90d9-b3f5-4f3f-8609-872a0e99d381",
                "20bd5961-5c88-4ad7-8eab-c7a41028ef7b",
                "01b7ddc7-106c-4082-8251-4a21023a42fe",
                "68ab0e01-56bf-4a11-b513-6f29bf0840c5",
                "54cd7481-4dc8-412a-bf09-ad7873883dc1",
                "287f4628-d03d-4c0c-b80e-951ffcd23b8e"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 93760,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "e352b9b9-eb24-4377-a89e-c1dc9c3c2b4f",
          "title": "IPAccount Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts",
          "file": "/test/integration/ipAccount.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"IPAccount Functions\"",
              "fullTitle": "IPAccount Functions \"before all\" hook in \"IPAccount Functions\"",
              "timedOut": false,
              "duration": 8805,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = registerResult.ipId;\ndata = (0, viem_1.encodeFunctionData)({\n    abi: generated_1.accessControllerAbi,\n    functionName: \"setTransientPermission\",\n    args: [\n        (0, viem_1.getAddress)(ipId),\n        (0, viem_1.getAddress)(util_1.TEST_WALLET_ADDRESS),\n        (0, viem_1.getAddress)(coreMetadataModule),\n        (0, viem_1.toFunctionSelector)(\"function setAll(address,string,bytes32,bytes32)\"),\n        src_1.AccessPermission.ALLOW,\n    ],\n});",
              "err": {},
              "uuid": "24224808-f62e-48e7-802e-0e459d75136b",
              "parentUUID": "e352b9b9-eb24-4377-a89e-c1dc9c3c2b4f",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [
            {
              "title": "should successfully set ip metadata",
              "fullTitle": "IPAccount Functions should successfully set ip metadata",
              "timedOut": false,
              "duration": 4433,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const txHash = await client.ipAccount.setIpMetadata({\n    ipId: ipId,\n    metadataURI: \"https://example.com\",\n    metadataHash: (0, viem_1.toHex)(\"test\", { size: 32 }),\n});\n(0, chai_1.expect)(txHash).to.be.a(\"string\");",
              "err": {},
              "uuid": "c33d6860-4be9-4265-8c95-3c98859b18ee",
              "parentUUID": "e352b9b9-eb24-4377-a89e-c1dc9c3c2b4f",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "should successfully transfer ERC20 tokens",
              "fullTitle": "IPAccount Functions should successfully transfer ERC20 tokens",
              "timedOut": false,
              "duration": 17879,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const erc20 = new generated_1.Erc20Client(util_1.publicClient, util_1.walletClient);\n// 1. Query token balance of ipId and wallet before\nconst initialErc20BalanceOfIpId = await erc20.balanceOf({\n    account: ipId,\n});\nconst initialErc20BalanceOfWallet = await erc20.balanceOf({\n    account: util_1.TEST_WALLET_ADDRESS,\n});\nconst initialWipBalanceOfIpId = await client.wipClient.balanceOf(ipId);\nconst initialWipBalanceOfWallet = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n// 2. transfer erc20 token to the ip account\nconst txHash = await erc20.mint({\n    to: ipId,\n    amount: (0, viem_1.parseEther)(\"0.002\"),\n});\nawait util_1.publicClient.waitForTransactionReceipt({\n    hash: txHash,\n});\n// 3. transfer wip to the ip account\nawait client.wipClient.deposit({\n    amount: 1n,\n});\nawait client.wipClient.transfer({\n    to: ipId,\n    amount: 1n,\n});\n// 4. transfer token of ip account to wallet address\nconst ret = await client.ipAccount.transferErc20({\n    ipId,\n    tokens: [\n        {\n            address: src_1.WIP_TOKEN_ADDRESS,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: 1n,\n        },\n        {\n            address: erc20.address,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: (0, viem_1.parseEther)(\"0.001\"),\n        },\n        {\n            address: erc20.address,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: (0, viem_1.parseEther)(\"0.001\"),\n        },\n    ],\n});\n// 5. query token balance of ipId and wallet address after\nconst finalErc20BalanceOfIpId = await erc20.balanceOf({\n    account: ipId,\n});\nconst finalWipBalanceOfIpId = await client.wipClient.balanceOf(ipId);\nconst finalErc20BalanceOfWallet = await erc20.balanceOf({\n    account: util_1.TEST_WALLET_ADDRESS,\n});\nconst finalWipBalanceOfWallet = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(ret.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(finalErc20BalanceOfIpId).to.equal(initialErc20BalanceOfIpId);\n(0, chai_1.expect)(finalWipBalanceOfIpId).to.equal(initialWipBalanceOfIpId);\n(0, chai_1.expect)(finalErc20BalanceOfWallet).to.equal(initialErc20BalanceOfWallet + (0, viem_1.parseEther)(\"0.002\"));\n(0, chai_1.expect)(finalWipBalanceOfWallet).to.equal(initialWipBalanceOfWallet + 1n);",
              "err": {},
              "uuid": "655a75f9-0020-404e-b900-61a9bbe0f6c7",
              "parentUUID": "e352b9b9-eb24-4377-a89e-c1dc9c3c2b4f",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [
            {
              "uuid": "3ac25581-97d9-47d3-87d7-6a295aab9968",
              "title": "execute",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts",
              "file": "/test/integration/ipAccount.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully execute a transaction",
                  "fullTitle": "IPAccount Functions execute should successfully execute a transaction",
                  "timedOut": false,
                  "duration": 4344,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.ipAccount.execute({\n    to: permissionAddress,\n    value: 0,\n    data: data,\n    ipId: ipId,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "01d4ec18-7d0b-4407-a3c5-3e8f7f9b0c9a",
                  "parentUUID": "3ac25581-97d9-47d3-87d7-6a295aab9968",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with invalid ipId",
                  "fullTitle": "IPAccount Functions execute should fail with invalid ipId",
                  "timedOut": false,
                  "duration": 47,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.ipAccount.execute({\n    to: permissionAddress,\n    value: 0,\n    data: data,\n    ipId: \"0x0000000000000000000000000000000000000000\",\n})).to.be.rejected;",
                  "err": {},
                  "uuid": "9b605f60-338d-4758-a647-a8b7d1a5ddbf",
                  "parentUUID": "3ac25581-97d9-47d3-87d7-6a295aab9968",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "01d4ec18-7d0b-4407-a3c5-3e8f7f9b0c9a",
                "9b605f60-338d-4758-a647-a8b7d1a5ddbf"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 4391,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "4d199d77-bc6a-43da-bfc3-5fccd2a1e734",
              "title": "executeWithSig",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts",
              "file": "/test/integration/ipAccount.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully execute with valid signature",
                  "fullTitle": "IPAccount Functions executeWithSig should successfully execute with valid signature",
                  "timedOut": false,
                  "duration": 4407,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Get the IP Account nonce (state)\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\n// Generate signature for the execute operation itself\n// We need to sign the data that will be executed, not the permission data\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\n// Execute with signature\nconst response = await client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "82b2e210-f9c2-4062-b7c0-ffd09c6d13dd",
                  "parentUUID": "4d199d77-bc6a-43da-bfc3-5fccd2a1e734",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with expired deadline",
                  "fullTitle": "IPAccount Functions executeWithSig should fail with expired deadline",
                  "timedOut": false,
                  "duration": 38,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: EXPIRED_DEADLINE,\n    signature: \"0x\",\n})).to.be.rejectedWith(\"IPAccount__ExpiredSignature\");",
                  "err": {},
                  "uuid": "4389310c-1d3b-48d4-b72d-06caa3086d22",
                  "parentUUID": "4d199d77-bc6a-43da-bfc3-5fccd2a1e734",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with invalid signature format",
                  "fullTitle": "IPAccount Functions executeWithSig should fail with invalid signature format",
                  "timedOut": false,
                  "duration": 37,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: \"0x1234567890abcdef\", // Invalid signature format\n})).to.be.rejectedWith(\"IPAccount__InvalidSignature\");",
                  "err": {},
                  "uuid": "81636d6d-ce34-4f7f-98ed-3966025bb677",
                  "parentUUID": "4d199d77-bc6a-43da-bfc3-5fccd2a1e734",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with signature from wrong signer",
                  "fullTitle": "IPAccount Functions executeWithSig should fail with signature from wrong signer",
                  "timedOut": false,
                  "duration": 89,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Generate signature with wrong signer\nconst wrongSigner = \"0x1234567890123456789012345678901234567890\";\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: wrongSigner,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\"IPAccount__InvalidSignature\");",
                  "err": {},
                  "uuid": "3ee53d91-78ab-4834-90f4-a0aedd4532f4",
                  "parentUUID": "4d199d77-bc6a-43da-bfc3-5fccd2a1e734",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with invalid ipId format",
                  "fullTitle": "IPAccount Functions executeWithSig should fail with invalid ipId format",
                  "timedOut": false,
                  "duration": 42,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: \"0x123\", // Invalid address format\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\"Invalid address: 0x123.\");",
                  "err": {},
                  "uuid": "87506933-15f4-45ad-93fc-bfdb7a971251",
                  "parentUUID": "4d199d77-bc6a-43da-bfc3-5fccd2a1e734",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail when IP account does not exist",
                  "fullTitle": "IPAccount Functions executeWithSig should fail when IP account does not exist",
                  "timedOut": false,
                  "duration": 37,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Create a real non-existent IP address (but with correct format)\nconst nonExistentIpId = \"0x1111111111111111111111111111111111111111\";\n// Generate signature for this non-existent IP\n// Note: We need to try to get nonce first, if IP doesn't exist, this step should fail\ntry {\n    const nonceResult = await client.ipAccount.getIpAccountNonce(nonExistentIpId);\n    const { signature } = await (0, src_1.getSignature)({\n        state: nonceResult,\n        to: permissionAddress,\n        encodeData: data,\n        wallet: util_1.walletClient,\n        verifyingContract: nonExistentIpId, // Use non-existent IP as verifying contract\n        deadline: VALID_DEADLINE,\n        chainId: util_1.aeneid,\n    });\n    await (0, chai_1.expect)(client.ipAccount.executeWithSig({\n        to: permissionAddress,\n        data: data,\n        ipId: nonExistentIpId,\n        signer: util_1.TEST_WALLET_ADDRESS,\n        deadline: VALID_DEADLINE,\n        signature: signature,\n    })).to.be.rejectedWith(\"IPAccount__InvalidSignature\"); // Should fail because IP doesn't exist\n}\ncatch (error) {\n    // If getting nonce fails, it means IP indeed doesn't exist, which is also our expected result\n    (0, chai_1.expect)(error.message).to.include(\"Failed to get the IP Account nonce\");\n}",
                  "err": {},
                  "uuid": "5e8af3e0-1ac5-44e2-8e05-8b40d6bddcdb",
                  "parentUUID": "4d199d77-bc6a-43da-bfc3-5fccd2a1e734",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with unauthorized signer",
                  "fullTitle": "IPAccount Functions executeWithSig should fail with unauthorized signer",
                  "timedOut": false,
                  "duration": 75,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Test various unauthorized signer scenarios\nconst unauthorizedSigner = \"0x2222222222222222222222222222222222222222\";\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: unauthorizedSigner, // Unauthorized signer\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\"IPAccount__InvalidSignature\"); // Contract returns InvalidSignature for permission issues",
                  "err": {},
                  "uuid": "a30b2a2a-536d-448c-9adc-013f58906791",
                  "parentUUID": "4d199d77-bc6a-43da-bfc3-5fccd2a1e734",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with signature for wrong data",
                  "fullTitle": "IPAccount Functions executeWithSig should fail with signature for wrong data",
                  "timedOut": false,
                  "duration": 70,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Generate signature for different data than what we execute\nconst wrongData = (0, viem_1.encodeFunctionData)({\n    abi: generated_1.accessControllerAbi,\n    functionName: \"setTransientPermission\",\n    args: [\n        (0, viem_1.getAddress)(\"0x1234567890123456789012345678901234567890\"),\n        (0, viem_1.getAddress)(util_1.TEST_WALLET_ADDRESS),\n        (0, viem_1.getAddress)(coreMetadataModule),\n        (0, viem_1.toFunctionSelector)(\"function setAll(address,string,bytes32,bytes32)\"),\n        src_1.AccessPermission.DENY,\n    ],\n});\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: wrongData, // Sign wrong data\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data, // Execute with original data, not the signed data\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\"IPAccount__InvalidSignature\"); // Should fail because data doesn't match signature",
                  "err": {},
                  "uuid": "988ef693-94d9-479e-8416-00b1851a0103",
                  "parentUUID": "4d199d77-bc6a-43da-bfc3-5fccd2a1e734",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with signature for wrong target address",
                  "fullTitle": "IPAccount Functions executeWithSig should fail with signature for wrong target address",
                  "timedOut": false,
                  "duration": 73,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Generate signature for different target address than what we execute\nconst wrongTarget = \"0x1234567890123456789012345678901234567890\";\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: wrongTarget, // Sign for wrong target\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress, // Execute with original target, not the signed target\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\"IPAccount__InvalidSignature\"); // Should fail because target doesn't match signature",
                  "err": {},
                  "uuid": "c83b5d3d-38d3-4846-b147-50a8e3c016b2",
                  "parentUUID": "4d199d77-bc6a-43da-bfc3-5fccd2a1e734",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should execute with zero value transaction",
                  "fullTitle": "IPAccount Functions executeWithSig should execute with zero value transaction",
                  "timedOut": false,
                  "duration": 8436,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Test successful execution with zero value\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nconst response = await client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n    value: 0, // Explicitly set zero value\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "aee40460-5a42-4ff2-80ce-c8ffc404681a",
                  "parentUUID": "4d199d77-bc6a-43da-bfc3-5fccd2a1e734",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "82b2e210-f9c2-4062-b7c0-ffd09c6d13dd",
                "4389310c-1d3b-48d4-b72d-06caa3086d22",
                "81636d6d-ce34-4f7f-98ed-3966025bb677",
                "3ee53d91-78ab-4834-90f4-a0aedd4532f4",
                "87506933-15f4-45ad-93fc-bfdb7a971251",
                "5e8af3e0-1ac5-44e2-8e05-8b40d6bddcdb",
                "a30b2a2a-536d-448c-9adc-013f58906791",
                "988ef693-94d9-479e-8416-00b1851a0103",
                "c83b5d3d-38d3-4846-b147-50a8e3c016b2",
                "aee40460-5a42-4ff2-80ce-c8ffc404681a"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 13304,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "3daeabb8-6fd6-4dac-8266-7e7f09156192",
              "title": "getIpAccountNonce",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts",
              "file": "/test/integration/ipAccount.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully return account nonce",
                  "fullTitle": "IPAccount Functions getIpAccountNonce should successfully return account nonce",
                  "timedOut": false,
                  "duration": 101,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.ipAccount.getIpAccountNonce(ipId);\n(0, chai_1.expect)(response).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "c5953123-fe00-4310-96a6-db809bd9c0c6",
                  "parentUUID": "3daeabb8-6fd6-4dac-8266-7e7f09156192",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with invalid ipId",
                  "fullTitle": "IPAccount Functions getIpAccountNonce should fail with invalid ipId",
                  "timedOut": false,
                  "duration": 39,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.ipAccount.getIpAccountNonce(\"0x0000000000000000000000000000000000000000\"))\n    .to.be.rejected;",
                  "err": {},
                  "uuid": "b38d595e-9b6e-4f9e-84d0-8a567c938046",
                  "parentUUID": "3daeabb8-6fd6-4dac-8266-7e7f09156192",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "c5953123-fe00-4310-96a6-db809bd9c0c6",
                "b38d595e-9b6e-4f9e-84d0-8a567c938046"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 140,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "07254224-3519-4d81-be13-534f68c36d99",
              "title": "getToken",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts",
              "file": "/test/integration/ipAccount.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully return token information",
                  "fullTitle": "IPAccount Functions getToken should successfully return token information",
                  "timedOut": false,
                  "duration": 46,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.ipAccount.getToken(ipId);\n(0, chai_1.expect)(response.chainId).to.be.a(\"bigint\");\n(0, chai_1.expect)(response.tokenContract).to.be.a(\"string\");\n(0, chai_1.expect)(response.tokenId).to.be.a(\"bigint\");\n(0, chai_1.expect)(response.tokenContract).to.equal(util_1.mockERC721);",
                  "err": {},
                  "uuid": "4224e355-bd4f-4a41-bf66-40b76cc5d1af",
                  "parentUUID": "07254224-3519-4d81-be13-534f68c36d99",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with invalid ipId",
                  "fullTitle": "IPAccount Functions getToken should fail with invalid ipId",
                  "timedOut": false,
                  "duration": 39,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.ipAccount.getToken(\"0x0000000000000000000000000000000000000000\")).to.be\n    .rejected;",
                  "err": {},
                  "uuid": "3cdc342f-f839-4ceb-b699-c2f66a16bed4",
                  "parentUUID": "07254224-3519-4d81-be13-534f68c36d99",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "4224e355-bd4f-4a41-bf66-40b76cc5d1af",
                "3cdc342f-f839-4ceb-b699-c2f66a16bed4"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 85,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [
            "c33d6860-4be9-4265-8c95-3c98859b18ee",
            "655a75f9-0020-404e-b900-61a9bbe0f6c7"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 22312,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "b6cd4608-c04f-4585-90be-97888b0b30de",
          "title": "IP Asset Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
          "file": "/test/integration/ipAsset.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"IP Asset Functions\"",
              "fullTitle": "IP Asset Functions \"before all\" hook in \"IP Asset Functions\"",
              "timedOut": false,
              "duration": 43,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();\nconst res = await client.license.registerPILTerms(src_1.PILFlavor.nonCommercialSocialRemixing());\nnoCommercialLicenseTermsId = res.licenseTermsId;",
              "err": {},
              "uuid": "5adcc4cc-ddd9-46af-ba42-c630b6501fce",
              "parentUUID": "b6cd4608-c04f-4585-90be-97888b0b30de",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "a7b4da86-2297-4ba2-a9af-95a6428270f7",
              "title": "Basic IP Asset Operations",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should register an IP Asset",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should register an IP Asset",
                  "timedOut": false,
                  "duration": 12911,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nchildIpId = response.ipId;\n(0, chai_1.expect)(childIpId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "3b2aacb6-2484-4921-a7f1-fbb4a1caf869",
                  "parentUUID": "a7b4da86-2297-4ba2-a9af-95a6428270f7",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register an IP Asset with multiple metadata fields",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should register an IP Asset with multiple metadata fields",
                  "timedOut": false,
                  "duration": 8870,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    ipMetadata: {\n        ipMetadataURI: \"ipfs://test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataURI: \"ipfs://test-nft-uri\",\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n});\nchildIpId2 = response.ipId;\n(0, chai_1.expect)(response.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(response.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "aaf5e71d-bc2f-4b93-8f6f-3cac57bda9cc",
                  "parentUUID": "a7b4da86-2297-4ba2-a9af-95a6428270f7",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not register with invalid metadata hash length",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should not register with invalid metadata hash length",
                  "timedOut": false,
                  "duration": 4503,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    ipMetadata: {\n        ipMetadataHash: \"0x123\", // Invalid length hash\n        nftMetadataHash: (0, viem_1.toHex)(\"valid-hash\", { size: 32 }),\n    },\n})).to.be.rejected;",
                  "err": {},
                  "uuid": "94f4751d-7187-4b28-ac47-0b609cf211d6",
                  "parentUUID": "a7b4da86-2297-4ba2-a9af-95a6428270f7",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not register with non-existent token ID",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should not register with non-existent token ID",
                  "timedOut": false,
                  "duration": 108,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: BigInt(Number.MAX_SAFE_INTEGER),\n})).to.be.rejected;",
                  "err": {},
                  "uuid": "04385c8b-f2a2-41d3-9e65-09b80230338c",
                  "parentUUID": "a7b4da86-2297-4ba2-a9af-95a6428270f7",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register derivative with Non-Commercial Remix PIL",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should register derivative with Non-Commercial Remix PIL",
                  "timedOut": false,
                  "duration": 25881,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nparentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [noCommercialLicenseTermsId],\n    maxMintingFee: 0,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: 0.32423,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "4e5ad812-4441-46a3-8f53-33145b1ac588",
                  "parentUUID": "a7b4da86-2297-4ba2-a9af-95a6428270f7",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register derivative with Commercial Remix PIL",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should register derivative with Commercial Remix PIL",
                  "timedOut": false,
                  "duration": 17975,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Register commercial remix PIL\nconst licenseResponse = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 10n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n}));\n// Register parent IP\nconst tokenId = await (0, util_1.getTokenId)();\nconst commercialParentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// Attach license terms to parent IP\nawait client.license.attachLicenseTerms({\n    ipId: commercialParentIpId,\n    licenseTermsId: licenseResponse.licenseTermsId,\n});\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: childIpId2,\n    parentIpIds: [commercialParentIpId],\n    licenseTermsIds: [licenseResponse.licenseTermsId],\n    maxMintingFee: 100,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: 10,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "f52b1f3b-1227-4a38-a247-72aa3e9a83b5",
                  "parentUUID": "a7b4da86-2297-4ba2-a9af-95a6428270f7",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register derivative with multiple parent IPs",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should register derivative with multiple parent IPs",
                  "timedOut": false,
                  "duration": 44082,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Create first parent IP\nconst tokenId1 = await (0, util_1.getTokenId)();\nconst parentIpId1 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n})).ipId;\n// Create second parent IP\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst parentIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId2,\n})).ipId;\n// Attach license terms to both parents\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId1,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId2,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\n// Create child IP\nconst childTokenId = await (0, util_1.getTokenId)();\nconst newChildIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId,\n})).ipId;\n// Register derivative with multiple parents\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: newChildIpId,\n    parentIpIds: [parentIpId1, parentIpId2],\n    licenseTermsIds: [noCommercialLicenseTermsId, noCommercialLicenseTermsId],\n    maxMintingFee: 0,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: 0.9999999999,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "15e158c4-7a49-4d4c-97c1-75713b78607b",
                  "parentUUID": "a7b4da86-2297-4ba2-a9af-95a6428270f7",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register derivative with license tokens",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should register derivative with license tokens",
                  "timedOut": false,
                  "duration": 17767,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nconst ipId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: noCommercialLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 1,\n});\nconst response = await client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "a0616d3c-11f9-4780-9bb8-90d8e4ba025b",
                  "parentUUID": "a7b4da86-2297-4ba2-a9af-95a6428270f7",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return true if IP asset is registered",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should return true if IP asset is registered",
                  "timedOut": false,
                  "duration": 31,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const isRegistered = await client.ipAsset.isRegistered(parentIpId);\n(0, chai_1.expect)(isRegistered).to.equal(true);",
                  "err": {},
                  "uuid": "96282ba5-8595-4a9c-8080-f053b24190b8",
                  "parentUUID": "a7b4da86-2297-4ba2-a9af-95a6428270f7",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return false if IP asset is not registered",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should return false if IP asset is not registered",
                  "timedOut": false,
                  "duration": 33,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const isRegistered = await client.ipAsset.isRegistered(\"0x1234567890123456789012345678901234567890\");\n(0, chai_1.expect)(isRegistered).to.equal(false);",
                  "err": {},
                  "uuid": "e145e611-f94f-4515-b395-f8573021124c",
                  "parentUUID": "a7b4da86-2297-4ba2-a9af-95a6428270f7",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "3b2aacb6-2484-4921-a7f1-fbb4a1caf869",
                "aaf5e71d-bc2f-4b93-8f6f-3cac57bda9cc",
                "94f4751d-7187-4b28-ac47-0b609cf211d6",
                "04385c8b-f2a2-41d3-9e65-09b80230338c",
                "4e5ad812-4441-46a3-8f53-33145b1ac588",
                "f52b1f3b-1227-4a38-a247-72aa3e9a83b5",
                "15e158c4-7a49-4d4c-97c1-75713b78607b",
                "a0616d3c-11f9-4780-9bb8-90d8e4ba025b",
                "96282ba5-8595-4a9c-8080-f053b24190b8",
                "e145e611-f94f-4515-b395-f8573021124c"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 132161,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "2958d165-4fd5-4322-9157-0cdb47428029",
              "title": "SPG NFT Operations",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"SPG NFT Operations\"",
                  "fullTitle": "IP Asset Functions SPG NFT Operations \"before all\" hook in \"SPG NFT Operations\"",
                  "timedOut": false,
                  "duration": 9636,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Setup NFT collection\nconst txData = await client.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\n// Setup license terms\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContract,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];\n// Setup ERC20\nconst mockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\nawait mockERC20.approve(generated_1.derivativeWorkflowsAddress[util_1.aeneid], viem_1.maxUint256);\nawait mockERC20.approve(generated_1.royaltyTokenDistributionWorkflowsAddress[util_1.aeneid], viem_1.maxUint256);\nawait mockERC20.mint(util_1.TEST_WALLET_ADDRESS, 100000n);",
                  "err": {},
                  "uuid": "7cc531a6-a746-4be1-aceb-b1ce88a90f6a",
                  "parentUUID": "2958d165-4fd5-4322-9157-0cdb47428029",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should register IP Asset with metadata",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register IP Asset with metadata",
                  "timedOut": false,
                  "duration": 16948,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst response = await client.ipAsset.register({\n    nftContract,\n    tokenId,\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(response.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "4a4c89d6-4e9c-4826-93c4-7f34ec911513",
                  "parentUUID": "2958d165-4fd5-4322-9157-0cdb47428029",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register derivative IP",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register derivative IP",
                  "timedOut": false,
                  "duration": 9126,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenChildId = await (0, util_1.mintBySpg)(nftContract);\nconst result = await client.ipAsset.registerDerivativeIp({\n    nftContract: nftContract,\n    tokenId: tokenChildId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 0,\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "15da1cf7-172f-4e78-a48f-48206b3b7b2d",
                  "parentUUID": "2958d165-4fd5-4322-9157-0cdb47428029",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register IP and attach PIL terms",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register IP and attach PIL terms",
                  "timedOut": false,
                  "duration": 13233,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: nftContract,\n    tokenId,\n    deadline: 1000n,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.commercialUse({\n                defaultMintingFee: 10000n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 10000n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"undefined\");",
                  "err": {},
                  "uuid": "42b27f16-ee11-482d-b4a1-4377f173fbb3",
                  "parentUUID": "2958d165-4fd5-4322-9157-0cdb47428029",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register IP and attach PIL terms with license terms max limit",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register IP and attach PIL terms with license terms max limit",
                  "timedOut": false,
                  "duration": 13479,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 10000n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);",
                  "err": {},
                  "uuid": "985184a9-2e2e-4e5a-9b6f-2fd6b45eb4b2",
                  "parentUUID": "2958d165-4fd5-4322-9157-0cdb47428029",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint and register IP and make derivative",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should mint and register IP and make derivative",
                  "timedOut": false,
                  "duration": 8830,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "642da78b-5f75-4415-9f1f-df2a034c554d",
                  "parentUUID": "2958d165-4fd5-4322-9157-0cdb47428029",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint and register IP",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should mint and register IP",
                  "timedOut": false,
                  "duration": 8498,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: nftContract,\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n    allowDuplicates: false,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "fc4b2d3d-0d49-4b2a-9e19-f09f391317d0",
                  "parentUUID": "2958d165-4fd5-4322-9157-0cdb47428029",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint and register IP and make derivative with license tokens",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should mint and register IP and make derivative with license tokens",
                  "timedOut": false,
                  "duration": 17395,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], mintLicenseTokensResult.licenseTokenIds[0]);\nconst result = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: nftContract,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "5bee653e-4430-4ff4-9c2a-adaa0a0fc4ca",
                  "parentUUID": "2958d165-4fd5-4322-9157-0cdb47428029",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register IP and make derivative with license tokens",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register IP and make derivative with license tokens",
                  "timedOut": false,
                  "duration": 22178,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], mintLicenseTokensResult.licenseTokenIds[0]);\nconst result = await client.ipAsset.registerIpAndMakeDerivativeWithLicenseTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "85b34cfa-f3c5-466a-8570-5995c5360996",
                  "parentUUID": "2958d165-4fd5-4322-9157-0cdb47428029",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register IP and attach license terms and distribute royalty tokens",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens",
                  "timedOut": false,
                  "duration": 18196,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 10,\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 0.00020302,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);",
                  "err": {},
                  "uuid": "1cffcd50-3546-44c4-bd0c-740153f1bd61",
                  "parentUUID": "2958d165-4fd5-4322-9157-0cdb47428029",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register IP and attach license terms and distribute royalty tokens with license terms max limit",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens with license terms max limit",
                  "timedOut": false,
                  "duration": 14481,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 12.232131,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);",
                  "err": {},
                  "uuid": "cd8cba0b-ab36-49c0-8e20-e65948146353",
                  "parentUUID": "2958d165-4fd5-4322-9157-0cdb47428029",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register IP and attach license terms and distribute royalty tokens with complex royalty shares",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens with complex royalty shares",
                  "timedOut": false,
                  "duration": 13683,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: generated_1.erc20Address[util_1.aeneid],\n                uri: \"test case\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 43.000301,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 17.0003011,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 2.000301,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 32.0003012,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"undefined\");",
                  "err": {},
                  "uuid": "dcf8e072-bce9-48d3-9880-ac810fe85d59",
                  "parentUUID": "2958d165-4fd5-4322-9157-0cdb47428029",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register derivative and attach license terms and distribute royalty tokens",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register derivative and attach license terms and distribute royalty tokens",
                  "timedOut": false,
                  "duration": 13540,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 0,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "f0a700c1-3a1f-41f3-9f07-1e3a0a13f907",
                  "parentUUID": "2958d165-4fd5-4322-9157-0cdb47428029",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint and register IP and attach PIL terms and distribute royalty tokens without licensing config",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should mint and register IP and attach PIL terms and distribute royalty tokens without licensing config",
                  "timedOut": false,
                  "duration": 4815,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: nftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.2,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "03870517-d840-4820-9e21-b99c0076a45f",
                  "parentUUID": "2958d165-4fd5-4322-9157-0cdb47428029",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint and register IP and attach PIL terms and distribute royalty tokens with license terms max limit",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should mint and register IP and attach PIL terms and distribute royalty tokens with license terms max limit",
                  "timedOut": false,
                  "duration": 5353,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: nftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n            maxLicenseTokens: 100,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 11n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.434,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(3);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);",
                  "err": {},
                  "uuid": "e80b7b16-aabb-406a-85a5-7e14e8fbeecb",
                  "parentUUID": "2958d165-4fd5-4322-9157-0cdb47428029",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "4a4c89d6-4e9c-4826-93c4-7f34ec911513",
                "15da1cf7-172f-4e78-a48f-48206b3b7b2d",
                "42b27f16-ee11-482d-b4a1-4377f173fbb3",
                "985184a9-2e2e-4e5a-9b6f-2fd6b45eb4b2",
                "642da78b-5f75-4415-9f1f-df2a034c554d",
                "fc4b2d3d-0d49-4b2a-9e19-f09f391317d0",
                "5bee653e-4430-4ff4-9c2a-adaa0a0fc4ca",
                "85b34cfa-f3c5-466a-8570-5995c5360996",
                "1cffcd50-3546-44c4-bd0c-740153f1bd61",
                "cd8cba0b-ab36-49c0-8e20-e65948146353",
                "dcf8e072-bce9-48d3-9880-ac810fe85d59",
                "f0a700c1-3a1f-41f3-9f07-1e3a0a13f907",
                "03870517-d840-4820-9e21-b99c0076a45f",
                "e80b7b16-aabb-406a-85a5-7e14e8fbeecb"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 179755,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "b21e22ce-5701-4832-830b-ac4f98088b35",
              "title": "SPG With Minting Fees with Public Minting SPG NFT Contract",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"SPG With Minting Fees with Public Minting SPG NFT Contract\"",
                  "fullTitle": "IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract \"before all\" hook in \"SPG With Minting Fees with Public Minting SPG NFT Contract\"",
                  "timedOut": false,
                  "duration": 13712,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// ensure we start with no wip since we will be wrapping them\nconst wipBalance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nif (wipBalance > 0n) {\n    await client.wipClient.withdraw({\n        amount: wipBalance,\n    });\n}\n// create a nft collection that requires minting fee\nconst rsp = await client.nftClient.createNFTCollection({\n    name: \"Premium Collection\",\n    symbol: \"PC\",\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \"test-uri\",\n    mintFee: 100n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nnftContractWithMintingFee = rsp.spgNftContract;\n// create parent ip with minting fee\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContractWithMintingFee,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 150n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: true,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: BigInt(0),\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: BigInt(0),\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test\",\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 150n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];",
                  "err": {},
                  "uuid": "883ce293-3e1a-4164-af2e-c179b0dfa588",
                  "parentUUID": "b21e22ce-5701-4832-830b-ac4f98088b35",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should auto wrap ip when mint and register derivative",
                  "fullTitle": "IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative",
                  "timedOut": false,
                  "duration": 5190,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const userBalanceBefore = await client.getWalletBalance();\nconst rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContractWithMintingFee, // pay 100 here\n    derivData: {\n        parentIpIds: [parentIpId], // pay 150 here\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    ipMetadata: {\n        ipMetadataURI: \"test\",\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \"test\",\n        nftMetadataHash: viem_1.zeroHash,\n    },\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(rsp.ipId).to.be.a(\"string\");\nconst userBalanceAfter = await client.getWalletBalance();\nconst cost = 150n + 100n;\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - cost));\n// user should not have any WIP tokens since we swap the exact amount\nconst wipBalance = await client.ipAsset.wipClient.balanceOf({\n    owner: util_1.TEST_WALLET_ADDRESS,\n});\n(0, chai_1.expect)(wipBalance.result).to.be.equal(0n);",
                  "err": {},
                  "uuid": "d7962f09-e094-44c5-8e95-171d245e5c16",
                  "parentUUID": "b21e22ce-5701-4832-830b-ac4f98088b35",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should auto wrap ip when mint and register derivative with license tokens",
                  "fullTitle": "IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative with license tokens",
                  "timedOut": false,
                  "duration": 30631,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenIds[0]);\n(0, chai_1.expect)(licenseTokenIds).to.be.an(\"array\");\nconst { txHash, ipId } = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: nftContractWithMintingFee,\n    licenseTokenIds: licenseTokenIds,\n    maxRts: 0,\n    ipMetadata: {\n        ipMetadataURI: \"test\",\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \"test\",\n        nftMetadataHash: viem_1.zeroHash,\n    },\n});\n(0, chai_1.expect)(txHash).to.be.a(\"string\");\n(0, chai_1.expect)(ipId).to.be.a(\"string\");\nconst isRegistered = await client.ipAsset.isRegistered(ipId);\n(0, chai_1.expect)(isRegistered).to.equal(true);",
                  "err": {},
                  "uuid": "560dc8a9-264d-4707-99de-1e50365ec66a",
                  "parentUUID": "b21e22ce-5701-4832-830b-ac4f98088b35",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should auto wrap ip when registering derivative",
                  "fullTitle": "IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when registering derivative",
                  "timedOut": false,
                  "duration": 13580,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nconst balanceBefore = await client.getWalletBalance();\nconst rsp = await client.ipAsset.registerDerivativeIp({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(rsp.ipId).to.be.a(\"string\");\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 150n));",
                  "err": {},
                  "uuid": "6e3c5f86-30c7-4eca-9549-f971b7fa5e4f",
                  "parentUUID": "b21e22ce-5701-4832-830b-ac4f98088b35",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should spend existing wip when register derivative and distribute loyalty tokens",
                  "fullTitle": "IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should spend existing wip when register derivative and distribute loyalty tokens",
                  "timedOut": false,
                  "duration": 18059,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nawait client.wipClient.deposit({\n    amount: 150n,\n});\nconst rsp = await client.ipAsset.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 4.000301,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(rsp.ipRoyaltyVault).to.be.a(\"string\");\n(0, chai_1.expect)(rsp.distributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(rsp.ipId).to.be.a(\"string\");\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.be.equal(0n);",
                  "err": {},
                  "uuid": "0293bd1f-364a-4602-90e6-41496eb19f9e",
                  "parentUUID": "b21e22ce-5701-4832-830b-ac4f98088b35",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should auto wrap ip when mint and register derivative and distribute loyalty tokens",
                  "fullTitle": "IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative and distribute loyalty tokens",
                  "timedOut": false,
                  "duration": 9054,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens({\n    spgNftContract: nftContractWithMintingFee,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    ipMetadata: {\n        ipMetadataURI: \"test\",\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \"test\",\n        nftMetadataHash: viem_1.zeroHash,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 0.34343234234,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(rsp.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "3648cb00-b818-49a1-bfb1-5ba50f6ed00a",
                  "parentUUID": "b21e22ce-5701-4832-830b-ac4f98088b35",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "d7962f09-e094-44c5-8e95-171d245e5c16",
                "560dc8a9-264d-4707-99de-1e50365ec66a",
                "6e3c5f86-30c7-4eca-9549-f971b7fa5e4f",
                "0293bd1f-364a-4602-90e6-41496eb19f9e",
                "3648cb00-b818-49a1-bfb1-5ba50f6ed00a"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 76514,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "4bdb8caf-df4b-45e9-a07d-994b8d6a2270",
              "title": "IP Asset Registration with Private Minting SPG NFT Contracts",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"IP Asset Registration with Private Minting SPG NFT Contracts\"",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts \"before all\" hook in \"IP Asset Registration with Private Minting SPG NFT Contracts\"",
                  "timedOut": false,
                  "duration": 8384,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \"Private Minting Collection\",\n    symbol: \"PMC\",\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 3n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \"\",\n});\nspgNftContractWithPrivateMinting = privateMintingCollectionResult.spgNftContract;",
                  "err": {},
                  "uuid": "55daf3a5-d033-48d5-88a0-152261ab1ebb",
                  "parentUUID": "4bdb8caf-df4b-45e9-a07d-994b8d6a2270",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully when call mint and register ip asset with pil terms",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip asset with pil terms",
                  "timedOut": false,
                  "duration": 17897,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 6n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                commercialRevShare: 90,\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"array\");\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];",
                  "err": {},
                  "uuid": "0ae40d24-e6e7-4f02-8e49-eef8b4274554",
                  "parentUUID": "4bdb8caf-df4b-45e9-a07d-994b8d6a2270",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully when call mint and register ip asset with pil terms with license terms max limit",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip asset with pil terms with license terms max limit",
                  "timedOut": false,
                  "duration": 18062,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 5n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 5n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n    ipMetadata: {\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);",
                  "err": {},
                  "uuid": "7ac2c9e1-0268-4e17-a10d-dbe15ecad345",
                  "parentUUID": "4bdb8caf-df4b-45e9-a07d-994b8d6a2270",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully when call mint and register ip and make derivative",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and make derivative",
                  "timedOut": false,
                  "duration": 17415,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 100n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "3282e49c-5f2f-4f98-bcb1-6f09b68da061",
                  "parentUUID": "4bdb8caf-df4b-45e9-a07d-994b8d6a2270",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully when call mint and register ip",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip",
                  "timedOut": false,
                  "duration": 12991,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n    allowDuplicates: false,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "ee39d69f-72c7-4cfb-8854-8ca29cc8fe3b",
                  "parentUUID": "4bdb8caf-df4b-45e9-a07d-994b8d6a2270",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully when call mint and register ip and make derivative with license tokens",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and make derivative with license tokens",
                  "timedOut": false,
                  "duration": 22182,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst licenseTokenId = mintLicenseTokensResult.licenseTokenIds[0];\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenId);\nconst result = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    licenseTokenIds: [licenseTokenId],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "d9b8b054-7b9f-4ff7-be1f-8a4134776c2a",
                  "parentUUID": "4bdb8caf-df4b-45e9-a07d-994b8d6a2270",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully when call mint and register ip and attach pil terms and distribute royalty tokens",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and attach pil terms and distribute royalty tokens",
                  "timedOut": false,
                  "duration": 13285,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.434,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "57cf396d-4472-4718-b5d0-58beb8b2d93a",
                  "parentUUID": "4bdb8caf-df4b-45e9-a07d-994b8d6a2270",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should succeed when call mint and register ip and make derivative and distribute royalty tokens",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should succeed when call mint and register ip and make derivative and distribute royalty tokens",
                  "timedOut": false,
                  "duration": 26684,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: true,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\nconst newParentIpId = result.ipId;\nconst licenseId = result.licenseTermsIds[0];\nconst rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    derivData: {\n        parentIpIds: [newParentIpId],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.434,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(rsp.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "4588a1dc-eacc-48a3-9a09-1bd083447b8d",
                  "parentUUID": "4bdb8caf-df4b-45e9-a07d-994b8d6a2270",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "0ae40d24-e6e7-4f02-8e49-eef8b4274554",
                "7ac2c9e1-0268-4e17-a10d-dbe15ecad345",
                "3282e49c-5f2f-4f98-bcb1-6f09b68da061",
                "ee39d69f-72c7-4cfb-8854-8ca29cc8fe3b",
                "d9b8b054-7b9f-4ff7-be1f-8a4134776c2a",
                "57cf396d-4472-4718-b5d0-58beb8b2d93a",
                "4588a1dc-eacc-48a3-9a09-1bd083447b8d"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 128516,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "57001f47-e449-45d3-a723-b4e3c05d8cae",
              "title": "Batch Operations",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Batch Operations\"",
                  "fullTitle": "IP Asset Functions Batch Operations \"before all\" hook in \"Batch Operations\"",
                  "timedOut": false,
                  "duration": 13146,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\nconst tokenId = await (0, util_1.getTokenId)();\nparentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;",
                  "err": {},
                  "uuid": "6a9bf6ad-0b4f-4250-bcb6-adeba4cf26a9",
                  "parentUUID": "57001f47-e449-45d3-a723-b4e3c05d8cae",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should batch register derivative",
                  "fullTitle": "IP Asset Functions Batch Operations should batch register derivative",
                  "timedOut": false,
                  "duration": 26878,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const childTokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId,\n})).ipId;\nconst childTokenId2 = await (0, util_1.getTokenId)();\nconst childIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId2,\n})).ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nconst result = await client.ipAsset.batchRegisterDerivative({\n    args: [\n        {\n            childIpId: childIpId,\n            parentIpIds: [parentIpId],\n            licenseTermsIds: [noCommercialLicenseTermsId],\n        },\n        {\n            childIpId: childIpId2,\n            parentIpIds: [parentIpId],\n            licenseTermsIds: [noCommercialLicenseTermsId],\n            maxMintingFee: 10000000,\n            maxRts: 5 * 10 ** 6,\n            maxRevenueShare: 0,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "b5cfa5b9-104f-4f4f-bf66-c2947cbddb6f",
                  "parentUUID": "57001f47-e449-45d3-a723-b4e3c05d8cae",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should batch mint and register IP asset with PIL terms",
                  "fullTitle": "IP Asset Functions Batch Operations should batch mint and register IP asset with PIL terms",
                  "timedOut": false,
                  "duration": 9414,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.batchMintAndRegisterIpAssetWithPilTerms({\n    args: [\n        {\n            spgNftContract: nftContract,\n            licenseTermsData: [\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 8n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \"\",\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 8n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                    maxLicenseTokens: 100,\n                },\n                {\n                    terms: src_1.PILFlavor.commercialRemix({\n                        defaultMintingFee: 100n,\n                        commercialRevShare: 10,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                    }),\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 100n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                },\n            ],\n        },\n        {\n            spgNftContract: nftContract,\n            licenseTermsData: [\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 8n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \"\",\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 8n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                    maxLicenseTokens: 100,\n                },\n            ],\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.results).to.be.an(\"array\");\n(0, chai_1.expect)(result.results[0].licenseTermsIds).to.be.an(\"array\").and.length(2);\n(0, chai_1.expect)(result.results[0].maxLicenseTokensTxHashes).to.be.an(\"array\").and.length(1);\n(0, chai_1.expect)(result.results[1].licenseTermsIds).to.be.an(\"array\").and.length(1);\n(0, chai_1.expect)(result.results[1].maxLicenseTokensTxHashes).to.be.an(\"array\").and.length(1);",
                  "err": {},
                  "uuid": "400a40c6-5662-4b20-ae85-5ad4b1918803",
                  "parentUUID": "57001f47-e449-45d3-a723-b4e3c05d8cae",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should batch mint and register IP asset and make derivative",
                  "fullTitle": "IP Asset Functions Batch Operations should batch mint and register IP asset and make derivative",
                  "timedOut": false,
                  "duration": 4873,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract: nftContract,\n            derivData: {\n                parentIpIds: [parentIpId],\n                licenseTermsIds: [noCommercialLicenseTermsId],\n                maxMintingFee: 0,\n                maxRts: 5 * 10 ** 6,\n                maxRevenueShare: 0,\n            },\n        },\n        {\n            spgNftContract: nftContract,\n            derivData: {\n                parentIpIds: [parentIpId],\n                licenseTermsIds: [noCommercialLicenseTermsId],\n                maxMintingFee: 0,\n                maxRts: 5 * 10 ** 6,\n                maxRevenueShare: 0,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.results).to.be.an(\"array\");",
                  "err": {},
                  "uuid": "40e9ea4b-9105-4580-8aab-21fed8375905",
                  "parentUUID": "57001f47-e449-45d3-a723-b4e3c05d8cae",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should batch register giving parameters",
                  "fullTitle": "IP Asset Functions Batch Operations should batch register giving parameters",
                  "timedOut": false,
                  "duration": 30656,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst spgTokenId1 = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst spgTokenId2 = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst result = await client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId,\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2,\n        },\n        {\n            nftContract,\n            tokenId: spgTokenId1,\n            ipMetadata: {\n                ipMetadataURI: \"test-uri2\",\n                ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash2\", { size: 32 }),\n                nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash2\", { size: 32 }),\n            },\n        },\n        {\n            nftContract,\n            tokenId: spgTokenId2,\n            ipMetadata: {\n                ipMetadataURI: \"test-uri\",\n                ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n                nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.results).to.be.an(\"array\");\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "c2144ba9-67aa-4d96-b6da-dcc31673b935",
                  "parentUUID": "57001f47-e449-45d3-a723-b4e3c05d8cae",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "b5cfa5b9-104f-4f4f-bf66-c2947cbddb6f",
                "400a40c6-5662-4b20-ae85-5ad4b1918803",
                "40e9ea4b-9105-4580-8aab-21fed8375905",
                "c2144ba9-67aa-4d96-b6da-dcc31673b935"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 71821,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "ce979168-f594-4436-afe9-3c80e0fd48d3",
              "title": "Error Cases",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Error Cases\"",
                  "fullTitle": "IP Asset Functions Error Cases \"before all\" hook in \"Error Cases\"",
                  "timedOut": false,
                  "duration": 8616,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;",
                  "err": {},
                  "uuid": "00fa6010-2469-4c48-865e-384ad5fb143e",
                  "parentUUID": "ce979168-f594-4436-afe9-3c80e0fd48d3",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should fail to register unowned NFT",
                  "fullTitle": "IP Asset Functions Error Cases should fail to register unowned NFT",
                  "timedOut": false,
                  "duration": 103,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: nftContract,\n    tokenId: 999999n, // Non-existent token\n})).to.be.rejected;",
                  "err": {},
                  "uuid": "f5cb9c05-d767-4275-b3c2-cf339112e720",
                  "parentUUID": "ce979168-f594-4436-afe9-3c80e0fd48d3",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "f5cb9c05-d767-4275-b3c2-cf339112e720"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 103,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "7b32e8f8-efa3-4809-9946-7d57958575da",
              "title": "Other Edge Cases",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Other Edge Cases\"",
                  "fullTitle": "IP Asset Functions Other Edge Cases \"before all\" hook in \"Other Edge Cases\"",
                  "timedOut": false,
                  "duration": 17358,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst parentIpResponse = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nparentIpId = parentIpResponse.ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});",
                  "err": {},
                  "uuid": "c24609ee-1e28-4329-b1a1-3fb7ef742c39",
                  "parentUUID": "7b32e8f8-efa3-4809-9946-7d57958575da",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "1c433ceb-42aa-4348-9278-3197d7c4a530",
                  "title": "License Token Edge Cases",
                  "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
                  "file": "/test/integration/ipAsset.test.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should fail when trying to use non-existent license token",
                      "fullTitle": "IP Asset Functions Other Edge Cases License Token Edge Cases should fail when trying to use non-existent license token",
                      "timedOut": false,
                      "duration": 8857,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tokenId = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId,\n    })).ipId,\n    licenseTokenIds: [BigInt(999999)], // Non-existent token\n    maxRts: 5 * 10 ** 6,\n})).to.be.rejected;",
                      "err": {},
                      "uuid": "f6011269-83c6-4850-91ec-a47d58bf2fca",
                      "parentUUID": "1c433ceb-42aa-4348-9278-3197d7c4a530",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should fail when trying to use same license token twice",
                      "fullTitle": "IP Asset Functions Other Edge Cases License Token Edge Cases should fail when trying to use same license token twice",
                      "timedOut": false,
                      "duration": 26552,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: noCommercialLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 1,\n});\nconst tokenId1 = await (0, util_1.getTokenId)();\nawait client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n    })).ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 0,\n});\nconst tokenId2 = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n    })).ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n})).to.be.rejected; // Should fail as token already used",
                      "err": {},
                      "uuid": "72f7cda4-af36-4129-8329-3ce695346764",
                      "parentUUID": "1c433ceb-42aa-4348-9278-3197d7c4a530",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "f6011269-83c6-4850-91ec-a47d58bf2fca",
                    "72f7cda4-af36-4129-8329-3ce695346764"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 35409,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 300000
                },
                {
                  "uuid": "2dfec4d1-db7c-40ac-9969-e5430074afdd",
                  "title": "Batch Operation Edge Cases",
                  "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
                  "file": "/test/integration/ipAsset.test.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should handle partial failures in batch registration",
                      "fullTitle": "IP Asset Functions Other Edge Cases Batch Operation Edge Cases should handle partial failures in batch registration",
                      "timedOut": false,
                      "duration": 13239,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nawait client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n});\nawait (0, chai_1.expect)(client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId1, // Already registered\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2, // New registration\n        },\n    ],\n})).to.be.rejected;",
                      "err": {},
                      "uuid": "5849f8b1-2dea-4d7f-821a-28cea8191451",
                      "parentUUID": "2dfec4d1-db7c-40ac-9969-e5430074afdd",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "5849f8b1-2dea-4d7f-821a-28cea8191451"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 13239,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 300000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "6c5ff90b-691c-4d4f-9199-cc289d4aa88b",
              "title": "Batch Register IP Assets With Optimized Workflows",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Batch Register IP Assets With Optimized Workflows\"",
                  "fullTitle": "IP Asset Functions Batch Register IP Assets With Optimized Workflows \"before all\" hook in \"Batch Register IP Assets With Optimized Workflows\"",
                  "timedOut": false,
                  "duration": 40010,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Create a public minting NFT collection\nconst publicMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \"Public Minting Collection\",\n    symbol: \"PMC\",\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \"\",\n});\nspgNftContractWithPublicMintingWithWip = publicMintingCollectionResult.spgNftContract;\n// Create a private minting NFT collection\nconst privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \"Private Minting Collection\",\n    symbol: \"PRC\",\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: generated_1.erc20Address[util_1.aeneid],\n    contractURI: \"\",\n});\nspgNftContractWithPrivateMintingWithErc20 = privateMintingCollectionResult.spgNftContract;\n// Register a commercial remix PIL license\nconst commercialRemixPILResult = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 10n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n}));\nlicenseTermsIdWithWIP = commercialRemixPILResult.licenseTermsId;\n// Register a commercial use PIL license\nconst commercialUsePILResult = await client.license.registerPILTerms({\n    transferable: true,\n    royaltyPolicy: \"0xBe54FB168b3c982b7AaE60dB6CF75Bd8447b390E\",\n    defaultMintingFee: 5n,\n    expiration: 0n,\n    commercialUse: true,\n    commercialAttribution: true,\n    commercializerChecker: viem_1.zeroAddress,\n    commercializerCheckerData: viem_1.zeroAddress,\n    commercialRevShare: 10,\n    commercialRevCeiling: 0n,\n    derivativesAllowed: true,\n    derivativesAttribution: true,\n    derivativesApproval: false,\n    derivativesReciprocal: true,\n    derivativeRevCeiling: 0n,\n    currency: generated_1.erc20Address[util_1.aeneid],\n    uri: \"https://github.com/piplabs/pil-document/blob/ad67bb632a310d2557f8abcccd428e4c9c798db1/off-chain-terms/CommercialRemix.json\",\n});\nlicenseTermsIdWithErc20 = commercialUsePILResult.licenseTermsId;\n// Mint and register IP with public minting contract\nconst publicMintingIpResult = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPublicMintingWithWip,\n});\nparentIpId1 = publicMintingIpResult.ipId;\n// Attach license terms to the first IP\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId1,\n    licenseTermsId: licenseTermsIdWithWIP,\n});\n// Mint and register IP with private minting contract\nconst privateMintingIpResult = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n});\nparentIpId2 = privateMintingIpResult.ipId;\n// Attach license terms to the second IP\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId2,\n    licenseTermsId: licenseTermsIdWithErc20,\n});",
                  "err": {},
                  "uuid": "f8cd6562-c54d-4b90-af68-415ee1a9c0b6",
                  "parentUUID": "6c5ff90b-691c-4d4f-9199-cc289d4aa88b",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully batch register multiple IP assets with SPG NFT contracts",
                  "fullTitle": "IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully batch register multiple IP assets with SPG NFT contracts",
                  "timedOut": false,
                  "duration": 38669,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10 WIP tokens + 10 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15 WIP tokens + 5 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the ERC20 token is used\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 0 WIP tokens + 10 ERC20 tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall due to the private minting\n     * - Two license terms\n     * - `maxLicenseTokens` is set to 1000n for first license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 1000n,\n            },\n            {\n                terms: src_1.PILFlavor.commercialUse({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 3n,\n                    override: {\n                        commercialRevShare: 90,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesReciprocal: true,\n                        commercialAttribution: false,\n                    },\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 3n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     * - One license terms\n     * - `maxLicenseTokens` is set to 100n for license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 0n,\n                    commercialRevShare: 90,\n                    override: {\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesReciprocal: true,\n                        commercialAttribution: false,\n                    },\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 100n,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 20(10+10) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 3.000301,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10 ERC20 tokens +5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.434,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the mint tokens is given `msg.sender` as the recipient\n     * - Two license terms\n     * - `maxLicenseTokens` is set to 80n and 10n for license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"test case\",\n                },\n                maxLicenseTokens: 80n,\n            },\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 100n,\n                    commercialRevShare: 0,\n                    override: {\n                        derivativesReciprocal: true,\n                        commercialAttribution: false,\n                        expiration: 1000n,\n                    },\n                }),\n                maxLicenseTokens: 10n,\n            },\n        ],\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 1.211,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens + 10 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the mint tokens is given `msg.sender` as the recipient\n     * - One license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.creativeCommonsAttribution({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    override: {\n                        defaultMintingFee: 10000n,\n                    },\n                }),\n            },\n        ],\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 1.231,\n            },\n        ],\n    },\n];\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\n/**\n * Transaction breakdown:\n *\n * 1. derivativeWorkflowsClient: 2 args\n *    - First arg:\n *      - 10WIP tokens +10 ERC20 tokens\n *    - Second arg:\n *      - 15WIP tokens + 5 ERC20 tokens\n *\n * 2. licenseAttachmentWorkflowsClient: 1 args\n *    - 10 ERC20 tokens\n *    - Two license terms attached\n *    - First license terms: maxLicenseTokens: 1000n\n *\n * 3. multicall3Client: 2 args\n *    - First arg:\n *      - 10 WIP tokens\n *      - One license terms\n *      - First license terms: maxLicenseTokens: 100n\n *    - Second arg:\n *      - 20 WIP tokens\n *\n * 3. multicall3Client: 2 args\n *    - First arg:\n *      - 10 WIP tokens\n *      - One license terms\n *      - First license terms: maxLicenseTokens: 100n\n *    - Second arg:\n *      - 20 WIP tokens\n *\n * 4. royaltyTokenDistributionWorkflowsClient: 3 args\n *    - First arg:\n *      - 10 ERC20+ 5 ERC20 tokens\n *    - Second arg:\n *      - 15 WIP tokens\n *      - Two license terms\n *      - First license terms: maxLicenseTokens: 80n\n *      - Second license terms: maxLicenseTokens: 10n\n *    - Third arg:\n *      - 10 ERC20 tokens\n *      - One license terms\n *\n * Summary:\n * - Total transactions: 4 (4 unique transaction hashes)\n * - Total IP assets registered: 8\n */\nconst totalFeesForWIP = 10 + 15 + 10 + 20 + 15;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFeesForWIP)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(4);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) => a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes).equal(undefined);\n// Derivative workflow\n// First arg\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(undefined);\n// Second arg\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(undefined);\n// license attachment workflow\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n// multicall3 workflow\n// First arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(2);\n// First arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n// Second arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(undefined);\n// royalty token distribution workflow\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(3);\n// First arg\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(undefined);\n// Second arg\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(2);\n// Third arg\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(undefined);",
                  "err": {},
                  "uuid": "f936e099-cac8-40ad-a813-2a1c1736db50",
                  "parentUUID": "6c5ff90b-691c-4d4f-9199-cc289d4aa88b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully batch register multiple IP assets with NFT contracts",
                  "fullTitle": "IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully batch register multiple IP assets with NFT contracts",
                  "timedOut": false,
                  "duration": 72954,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst tokenId4 = await (0, util_1.getTokenId)();\nconst tokenId5 = await (0, util_1.getTokenId)();\nconst tokenId6 = await (0, util_1.getTokenId)();\nconst tokenId7 = await (0, util_1.getTokenId)();\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst requests = [\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerIpAndAttachPilTerms  workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall\n     * - Two license terms\n     * - `maxLicenseTokens` is set to 100n for second license terms\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId3,\n        deadline: 1000n,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 0n,\n                    commercialRevShare: 100,\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"test case\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 10000n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 100n,\n            },\n        ],\n    },\n    /**\n     * registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Two license terms\n     * - Need to distribute royalty tokens\n     * - `maxLicenseTokens` is set to 10n for first license terms\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId4,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \"test case\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 1n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n            {\n                terms: src_1.PILFlavor.creativeCommonsAttribution({\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 6n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n        ],\n        ipMetadata: {\n            ipMetadataURI: \"test-uri\",\n            ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n            nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 43.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 17.0003011,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 2.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 30.0003012,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId5,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId6,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId7,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.434,\n            },\n        ],\n    },\n];\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\n/**\n * Transaction breakdown:\n * 1. royaltyTokenDistributionWorkflowsClient: 4 args\n *  - First arg:\n *    - 10 WIP tokens\n *    - Need to distribute royalty tokens\n *  - Second arg:\n *    - 5 ERC20 tokens\n *    - Need to distribute royalty tokens\n *  - Third arg:\n *    - 0 WIP tokens\n *    - Two license terms\n *    - First license terms: maxLicenseTokens: 10n\n *    - Need to distribute royalty tokens\n *  - Fourth arg:\n *    - 5 ERC20 tokens\n *    - Need to distribute royalty tokens\n * 2. licenseAttachmentWorkflowsClient: 1 arg\n *  - 0 WIP tokens\n *  - Two license terms\n *  - Second license terms: maxLicenseTokens: 100n\n * 3. derivativeWorkflowsClient: 2 args\n *  - First arg:\n *    - 5 ERC20 tokens\n *  - Second arg:\n *    - 10 WIP tokens\n *\n * Summary:\n * - Total transactions: 3 (3 unique transaction hashes)\n * - Total IP assets registered: 7\n */\nconst totalFees = 10 + 10;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(3);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) => a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).equal(1);\n// royaltyTokenDistributionWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(4);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[0].ipRoyaltyVault?.length).equal(4);\n// licenseAttachmentWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipRoyaltyVault?.length).equal(0);\n//derivativeWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipRoyaltyVault?.length).equal(0);",
                  "err": {},
                  "uuid": "53232cc7-25e4-4761-a0ff-b3176e644925",
                  "parentUUID": "6c5ff90b-691c-4d4f-9199-cc289d4aa88b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully register IP assets using a combination of NFT contracts and SPG NFT contracts",
                  "fullTitle": "IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully register IP assets using a combination of NFT contracts and SPG NFT contracts",
                  "timedOut": false,
                  "duration": 55592,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst tokenId4 = await (0, util_1.getTokenId)();\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10 WIP tokens +5 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall3 due to contains ERC20 token\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10 ERC20 tokens+ 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.434,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 20(10+10) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.4341111111,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10 ERC20 tokens+10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.2312332,\n            },\n        ],\n    },\n    /**\n     * registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     * - One license terms\n     * - `maxLicenseTokens` is set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \"test case\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 1n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n        ipMetadata: {\n            ipMetadataURI: \"test-uri\",\n            ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n            nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 43.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 17.0003011,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 2.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 30.0003012,\n            },\n        ],\n    },\n    /**\n     * registerIpAndAttachPilTerms  workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall\n     * - Two license terms\n     * - The second request has `maxLicenseTokens` set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId3,\n        deadline: 1000n,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 0n,\n                    commercialRevShare: 100,\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"test case\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 10000n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId4,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n];\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\n/**\n * Transaction breakdown:\n * 1. derivativeWorkflowsClient:3 args\n * - First arg\n *   - 10 WIP tokens+ 5 ERC20 tokens\n * - Second arg\n *   - 10 ERC20 + 10 WIP tokens\n * - Third arg\n *   - 10 WIP tokens\n *\n * 2. royaltyTokenDistributionWorkflowsClient: 3 args\n *  - First arg\n *    - 15 ERC20 tokens\n *  - Second arg\n *    - 5 ERC20 tokens\n *    - Need to distribute royalty tokens\n *  - Third arg\n *    - 0 WIP tokens\n *    - One license terms\n *    - First license terms: maxLicenseTokens: 10n\n *    - Need to distribute royalty tokens\n *\n * 3. licenseAttachmentWorkflowsClient: 1 arg\n * - 0 WIP tokens\n * - Two license terms\n * - Second license terms: maxLicenseTokens: 100n\n *\n * Summary:\n * - Total transactions: 4 (4 unique transaction hashes)\n * - Total IP assets registered: 8\n */\nconst totalFeesWithWIP = 10 + 10 + 10;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFeesWithWIP)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(4);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) => a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).equal(1);\n// derivativeWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[0].ipRoyaltyVault?.length).equal(0);\n// royaltyTokenDistributionWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipRoyaltyVault?.length).equal(2);\n//licenseAttachmentWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipRoyaltyVault?.length).equal(0);",
                  "err": {},
                  "uuid": "320e9b06-b39e-40ec-9782-fcaf6bca6c6f",
                  "parentUUID": "6c5ff90b-691c-4d4f-9199-cc289d4aa88b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully register IP assets with multicall disabled",
                  "fullTitle": "IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully register IP assets with multicall disabled",
                  "timedOut": false,
                  "duration": 46339,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15(10+5) WIP tokens\n     * - Uses `derivativeWorkflowsClient` to call the this method\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` to call the this method\n     * - One license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` to call the this method\n     * - Two license terms\n     * - The first request has `maxLicenseTokens` set to 10n\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 10n,\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient`to call the this method\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.4341212321,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient`to call the this method\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 3.000301,\n            },\n        ],\n    },\n];\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n    options: {\n        wipOptions: {\n            useMulticallWhenPossible: false,\n        },\n    },\n});\n/**\n * Transaction breakdown:\n *  1. derivativeWorkflowsClient:1 arg\n *    - 15 WIP\n * 2. licenseAttachmentWorkflowsClient: 2 args\n *    - First arg\n *      - 0 WIP tokens\n *      - One license terms\n *    - Second arg\n *      - 10  WIP tokens\n *      - Two license terms\n *      - First license terms: maxLicenseTokens: 10n\n * 3. royaltyTokenDistributionWorkflowsClient: 2 args\n *    - First arg\n *      - 5 ERC20 tokens\n *      - Need to distribute royalty tokens\n *    - Second arg\n *      - 5 ERC20 tokens\n *      - Need to distribute royalty tokens\n * Summary:\n * - Total transactions: 5 (5 unique transaction hashes) due to the multicall disabled\n * - Total IP assets registered: 5\n * - Two distribute royalty tokens transactions\n */\nconst totalFees = 15 + 10;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(requests.length);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) => a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).equal(2);\n//derivativeWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipRoyaltyVault?.length).equal(0);\n//licenseAttachmentWorkflowsClient\n//First arg\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n//Second arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n//royaltyTokenDistributionWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipRoyaltyVault?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[4].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[4].ipRoyaltyVault?.length).equal(1);",
                  "err": {},
                  "uuid": "f72ebb60-90ef-45f1-bf10-a2637b6ff307",
                  "parentUUID": "6c5ff90b-691c-4d4f-9199-cc289d4aa88b",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "f936e099-cac8-40ad-a813-2a1c1736db50",
                "53232cc7-25e4-4761-a0ff-b3176e644925",
                "320e9b06-b39e-40ec-9782-fcaf6bca6c6f",
                "f72ebb60-90ef-45f1-bf10-a2637b6ff307"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 213554,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "ec61a87c-ab6c-47c8-859a-2d4a3f43c2d4",
              "title": "Batch Mint and Register IP Asset",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Batch Mint and Register IP Asset\"",
                  "fullTitle": "IP Asset Functions Batch Mint and Register IP Asset \"before all\" hook in \"Batch Mint and Register IP Asset\"",
                  "timedOut": false,
                  "duration": 8790,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const publicMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContractWithPublicMinting = publicMintingCollectionResult.spgNftContract;\nconst privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 20n,\n    mintFeeToken: generated_1.erc20Address[util_1.aeneid],\n});\nspgNftContractWithPrivateMinting = privateMintingCollectionResult.spgNftContract;\nconst { address } = await (0, BIP32_1.getDerivedStoryClient)();\nanotherWalletAddress = address;",
                  "err": {},
                  "uuid": "5221ec3a-2dea-44aa-a577-57d9aa914013",
                  "parentUUID": "ec61a87c-ab6c-47c8-859a-2d4a3f43c2d4",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully when public minting of spgNftContract",
                  "fullTitle": "IP Asset Functions Batch Mint and Register IP Asset should successfully when public minting of spgNftContract",
                  "timedOut": false,
                  "duration": 4917,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst { registrationResults } = await client.ipAsset.batchMintAndRegisterIp({\n    requests: [\n        { spgNftContract: spgNftContractWithPublicMinting },\n        { spgNftContract: spgNftContractWithPublicMinting, recipient: anotherWalletAddress },\n        { spgNftContract: spgNftContractWithPublicMinting, allowDuplicates: false },\n    ],\n});\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(registrationResults.length).equal(1);\n(0, chai_1.expect)(registrationResults[0].ipIdsAndTokenIds.length).equal(3);",
                  "err": {},
                  "uuid": "123c4113-09eb-4d41-b4be-48f494eeb084",
                  "parentUUID": "ec61a87c-ab6c-47c8-859a-2d4a3f43c2d4",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully when private minting of spgNftContract",
                  "fullTitle": "IP Asset Functions Batch Mint and Register IP Asset should successfully when private minting of spgNftContract",
                  "timedOut": false,
                  "duration": 9354,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst { registrationResults } = await client.ipAsset.batchMintAndRegisterIp({\n    requests: [\n        { spgNftContract: spgNftContractWithPrivateMinting },\n        { spgNftContract: spgNftContractWithPrivateMinting, recipient: anotherWalletAddress },\n        {\n            spgNftContract: spgNftContractWithPrivateMinting,\n            allowDuplicates: false,\n            recipient: anotherWalletAddress,\n        },\n    ],\n});\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(registrationResults.length).equal(1);\n(0, chai_1.expect)(registrationResults[0].ipIdsAndTokenIds.length).equal(3);",
                  "err": {},
                  "uuid": "10cccace-574c-4d34-b1df-5101d4bf2b41",
                  "parentUUID": "ec61a87c-ab6c-47c8-859a-2d4a3f43c2d4",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully when hybrid private minting and public minting of spgNftContract",
                  "fullTitle": "IP Asset Functions Batch Mint and Register IP Asset should successfully when hybrid private minting and public minting of spgNftContract",
                  "timedOut": false,
                  "duration": 13594,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst { registrationResults } = await client.ipAsset.batchMintAndRegisterIp({\n    requests: [\n        { spgNftContract: spgNftContractWithPublicMinting },\n        { spgNftContract: spgNftContractWithPrivateMinting, recipient: anotherWalletAddress },\n        { spgNftContract: spgNftContractWithPrivateMinting, allowDuplicates: false },\n        { spgNftContract: spgNftContractWithPublicMinting, recipient: anotherWalletAddress },\n    ],\n});\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(registrationResults.length).equal(2);\n(0, chai_1.expect)(registrationResults[0].ipIdsAndTokenIds.length).equal(2);\n(0, chai_1.expect)(registrationResults[1].ipIdsAndTokenIds.length).equal(2);",
                  "err": {},
                  "uuid": "30d52ef1-a9cc-4b5d-8271-9be2cf710870",
                  "parentUUID": "ec61a87c-ab6c-47c8-859a-2d4a3f43c2d4",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail when private minting of spgNftContract but caller does not have the minter role",
                  "fullTitle": "IP Asset Functions Batch Mint and Register IP Asset should fail when private minting of spgNftContract but caller does not have the minter role",
                  "timedOut": false,
                  "duration": 4583,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Register a new SPG NFT contract with private minting with clientB\nconst { address, clientB } = await (0, BIP32_1.getDerivedStoryClient)();\nconst { spgNftContract: privateMintingContractOfClientB } = await clientB.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: address,\n    contractURI: \"test-uri\",\n});\nawait (0, chai_1.expect)(client.ipAsset.batchMintAndRegisterIp({\n    requests: [{ spgNftContract: privateMintingContractOfClientB }],\n})).to.be.rejectedWith(\"does not have the minter role\");",
                  "err": {},
                  "uuid": "ab157fec-440e-4e11-af50-bbacc5a20a31",
                  "parentUUID": "ec61a87c-ab6c-47c8-859a-2d4a3f43c2d4",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "123c4113-09eb-4d41-b4be-48f494eeb084",
                "10cccace-574c-4d34-b1df-5101d4bf2b41",
                "30d52ef1-a9cc-4b5d-8271-9be2cf710870",
                "ab157fec-440e-4e11-af50-bbacc5a20a31"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 32448,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "8cf870e0-da88-4b36-a0d4-02b446a1dacc",
              "title": "Register ip asset with minted and mint nft",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "1769bafa-46e0-4c48-a93a-4d814353d309",
                  "title": "Register IP Asset with Minted NFT",
                  "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
                  "file": "/test/integration/ipAsset.test.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should successfully when give license terms data and royalty shares",
                      "fullTitle": "IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when give license terms data and royalty shares",
                      "timedOut": false,
                      "duration": 18031,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \"minted\", nftContract: util_1.mockERC721, tokenId: tokenId },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 2.000000001,\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds.length).to.be.equal(1);\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipRoyaltyVault).to.be.a(\"string\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);",
                      "err": {},
                      "uuid": "3daf7ef5-ef94-42d2-90a2-826d40b7e754",
                      "parentUUID": "1769bafa-46e0-4c48-a93a-4d814353d309",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when give license terms data without royalty shares",
                      "fullTitle": "IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when give license terms data without royalty shares",
                      "timedOut": false,
                      "duration": 9348,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \"minted\", nftContract: util_1.mockERC721, tokenId: tokenId },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "9877728b-edb0-46df-b170-5f7823994120",
                      "parentUUID": "1769bafa-46e0-4c48-a93a-4d814353d309",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when without license terms data, royalty shares, ip metadata",
                      "fullTitle": "IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when without license terms data, royalty shares, ip metadata",
                      "timedOut": false,
                      "duration": 8806,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \"minted\", nftContract: util_1.mockERC721, tokenId: tokenId },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "9e5ee079-018c-4b95-a7a4-60bf6a4a3dab",
                      "parentUUID": "1769bafa-46e0-4c48-a93a-4d814353d309",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when without license terms data and royalty shares, with ip metadata",
                      "fullTitle": "IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when without license terms data and royalty shares, with ip metadata",
                      "timedOut": false,
                      "duration": 8956,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \"minted\", nftContract: util_1.mockERC721, tokenId: tokenId },\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n        nftMetadataURI: \"test-nft-uri\",\n    },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "98ec75ef-27ea-4faa-8812-2b8d332434ed",
                      "parentUUID": "1769bafa-46e0-4c48-a93a-4d814353d309",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "3daf7ef5-ef94-42d2-90a2-826d40b7e754",
                    "9877728b-edb0-46df-b170-5f7823994120",
                    "9e5ee079-018c-4b95-a7a4-60bf6a4a3dab",
                    "98ec75ef-27ea-4faa-8812-2b8d332434ed"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 45141,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 300000
                },
                {
                  "uuid": "abecf18d-57b0-4a5d-ab7c-f763d42aa344",
                  "title": "Register IP Asset by minting a new NFT",
                  "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
                  "file": "/test/integration/ipAsset.test.ts",
                  "beforeHooks": [
                    {
                      "title": "\"before all\" hook in \"Register IP Asset by minting a new NFT\"",
                      "fullTitle": "IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT \"before all\" hook in \"Register IP Asset by minting a new NFT\"",
                      "timedOut": false,
                      "duration": 4371,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST_FOR_MINT\",\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \"test-uri\",\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContract = txData.spgNftContract;",
                      "err": {},
                      "uuid": "c334c427-b5b4-463b-93df-ee913526f725",
                      "parentUUID": "abecf18d-57b0-4a5d-ab7c-f763d42aa344",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should successfully when give license terms data and royalty shares",
                      "fullTitle": "IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT should successfully when give license terms data and royalty shares",
                      "timedOut": false,
                      "duration": 14204,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgNftContract },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 0.000001,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.ipRoyaltyVault).to.be.a(\"string\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "ef98a254-6058-4a44-80c9-3ba33252e018",
                      "parentUUID": "abecf18d-57b0-4a5d-ab7c-f763d42aa344",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when give license terms data without royalty shares",
                      "fullTitle": "IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT should successfully when give license terms data without royalty shares",
                      "timedOut": false,
                      "duration": 9801,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgNftContract },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);",
                      "err": {},
                      "uuid": "0f8c4bed-a2b6-461b-9d4d-4ba0d47ddfc7",
                      "parentUUID": "abecf18d-57b0-4a5d-ab7c-f763d42aa344",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when without license terms data and royalty shares",
                      "fullTitle": "IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT should successfully when without license terms data and royalty shares",
                      "timedOut": false,
                      "duration": 17127,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgNftContract },\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n        nftMetadataURI: \"test-nft-uri\",\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "5c926535-20c0-4a2f-9373-c5c5f73e8882",
                      "parentUUID": "abecf18d-57b0-4a5d-ab7c-f763d42aa344",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "ef98a254-6058-4a44-80c9-3ba33252e018",
                    "0f8c4bed-a2b6-461b-9d4d-4ba0d47ddfc7",
                    "5c926535-20c0-4a2f-9373-c5c5f73e8882"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 41132,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 300000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "d77acb9b-aa0e-4d32-9dd1-898b71d2ba77",
              "title": "Register derivative IP Asset",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Register derivative IP Asset\"",
                  "fullTitle": "IP Asset Functions Register derivative IP Asset \"before all\" hook in \"Register derivative IP Asset\"",
                  "timedOut": false,
                  "duration": 9132,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\nparentIpId = result.ipId;\ncommercialRemixLicenseTermsId = result.licenseTermsIds[0];",
                  "err": {},
                  "uuid": "6e579704-050d-41de-8a2a-6b038f7504ae",
                  "parentUUID": "d77acb9b-aa0e-4d32-9dd1-898b71d2ba77",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "d523ec42-4a03-40e1-8dd2-d15a6a4c374b",
                  "title": "Register derivative IP Asset with Minted NFT",
                  "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
                  "file": "/test/integration/ipAsset.test.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should successfully when give derivData and royalty shares",
                      "fullTitle": "IP Asset Functions Register derivative IP Asset Register derivative IP Asset with Minted NFT should successfully when give derivData and royalty shares",
                      "timedOut": false,
                      "duration": 26307,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \"minted\", nftContract: util_1.mockERC721, tokenId: tokenId },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipRoyaltyVault).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.equal(BigInt(tokenId));",
                      "err": {},
                      "uuid": "98348e9f-9ff6-4e9c-8a2f-edb6ee77de66",
                      "parentUUID": "d523ec42-4a03-40e1-8dd2-d15a6a4c374b",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully given derivData",
                      "fullTitle": "IP Asset Functions Register derivative IP Asset Register derivative IP Asset with Minted NFT should successfully given derivData",
                      "timedOut": false,
                      "duration": 17714,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \"minted\", nftContract: util_1.mockERC721, tokenId: tokenId },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.equal(BigInt(tokenId));\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                      "err": {},
                      "uuid": "0d42fc98-ca39-4474-a43d-be723885f306",
                      "parentUUID": "d523ec42-4a03-40e1-8dd2-d15a6a4c374b",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully given licenseTokenIds and maxRts",
                      "fullTitle": "IP Asset Functions Register derivative IP Asset Register derivative IP Asset with Minted NFT should successfully given licenseTokenIds and maxRts",
                      "timedOut": false,
                      "duration": 22215,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: commercialRemixLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenIds[0]);\nconst tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \"minted\", nftContract: util_1.mockERC721, tokenId: tokenId },\n    licenseTokenIds: licenseTokenIds,\n    maxRts: 100,\n    maxMintingFee: 10000n,\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.equal(BigInt(tokenId));\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                      "err": {},
                      "uuid": "30fb3ab6-df01-43e0-940b-624ad100681f",
                      "parentUUID": "d523ec42-4a03-40e1-8dd2-d15a6a4c374b",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "98348e9f-9ff6-4e9c-8a2f-edb6ee77de66",
                    "0d42fc98-ca39-4474-a43d-be723885f306",
                    "30fb3ab6-df01-43e0-940b-624ad100681f"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 66236,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 300000
                },
                {
                  "uuid": "34f7760e-f63f-4abb-9188-cabb145e86e9",
                  "title": "Register derivative IP Asset by minting a new NFT",
                  "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
                  "file": "/test/integration/ipAsset.test.ts",
                  "beforeHooks": [
                    {
                      "title": "\"before all\" hook in \"Register derivative IP Asset by minting a new NFT\"",
                      "fullTitle": "IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT \"before all\" hook in \"Register derivative IP Asset by minting a new NFT\"",
                      "timedOut": false,
                      "duration": 4359,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST_FOR_MINT\",\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \"test-uri\",\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContract = txData.spgNftContract;",
                      "err": {},
                      "uuid": "a87a98d4-94f9-4a3d-aca0-ccfadc4b9c83",
                      "parentUUID": "34f7760e-f63f-4abb-9188-cabb145e86e9",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should successfully when give derivData and royalty shares",
                      "fullTitle": "IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT should successfully when give derivData and royalty shares",
                      "timedOut": false,
                      "duration": 21836,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \"mint\", spgNftContract },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 1.23,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "c4adfc5a-a695-441d-ad2b-8a5ad70ad2c0",
                      "parentUUID": "34f7760e-f63f-4abb-9188-cabb145e86e9",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when give licenseTokenIds and maxRts",
                      "fullTitle": "IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT should successfully when give licenseTokenIds and maxRts",
                      "timedOut": false,
                      "duration": 22351,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: commercialRemixLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenIds[0]);\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \"mint\", spgNftContract },\n    licenseTokenIds: licenseTokenIds,\n    maxRts: 100,\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "1f63e70e-0b13-4b8e-ba16-357c389a6580",
                      "parentUUID": "34f7760e-f63f-4abb-9188-cabb145e86e9",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when give derivData",
                      "fullTitle": "IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT should successfully when give derivData",
                      "timedOut": false,
                      "duration": 9373,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \"mint\", spgNftContract },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "6e5f376c-3b5b-4ada-862d-8f578480b19b",
                      "parentUUID": "34f7760e-f63f-4abb-9188-cabb145e86e9",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "c4adfc5a-a695-441d-ad2b-8a5ad70ad2c0",
                    "1f63e70e-0b13-4b8e-ba16-357c389a6580",
                    "6e5f376c-3b5b-4ada-862d-8f578480b19b"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 53560,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 300000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "f3db7281-a8e5-4f0b-b006-339476a873fe",
              "title": "Link Derivative",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Link Derivative\"",
                  "fullTitle": "IP Asset Functions Link Derivative \"before all\" hook in \"Link Derivative\"",
                  "timedOut": false,
                  "duration": 17247,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\nparentIpId = result.ipId;\ncommercialRemixLicenseTermsId = result.licenseTermsIds[0];",
                  "err": {},
                  "uuid": "95d7ceb2-ae24-43cf-bd80-5fbfb7befa8b",
                  "parentUUID": "f3db7281-a8e5-4f0b-b006-339476a873fe",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully when give childIpId and licenseTokenIds",
                  "fullTitle": "IP Asset Functions Link Derivative should successfully when give childIpId and licenseTokenIds",
                  "timedOut": false,
                  "duration": 18109,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: commercialRemixLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "35da45fe-c0fc-4c9c-8f4a-13e5da17b9db",
                  "parentUUID": "f3db7281-a8e5-4f0b-b006-339476a873fe",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully when give parentIpId and licenseTokenIds",
                  "fullTitle": "IP Asset Functions Link Derivative should successfully when give parentIpId and licenseTokenIds",
                  "timedOut": false,
                  "duration": 22010,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [commercialRemixLicenseTermsId],\n    maxMintingFee: 0,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: 0,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "b34f8a08-155f-445b-a51a-f921732ec8e1",
                  "parentUUID": "f3db7281-a8e5-4f0b-b006-339476a873fe",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "35da45fe-c0fc-4c9c-8f4a-13e5da17b9db",
                "b34f8a08-155f-445b-a51a-f921732ec8e1"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 40119,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "b5f9b5f3-4732-4bc8-9560-a45c448b0d1a",
              "title": "with ERC20 and WIP token fee",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"with ERC20 and WIP token fee\"",
                  "fullTitle": "IP Asset Functions with ERC20 and WIP token fee \"before all\" hook in \"with ERC20 and WIP token fee\"",
                  "timedOut": false,
                  "duration": 30910,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "spgContractWith100WIP = (await client.nftClient.createNFTCollection({\n    name: \"100 WIP\",\n    symbol: \"100WIP\",\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 100n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \"\",\n})).spgNftContract;\nspgContractWith10ERC20 = (await client.nftClient.createNFTCollection({\n    name: \"10 ERC20\",\n    symbol: \"10ERC20\",\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 100n,\n    mintFeeToken: generated_1.erc20Address[util_1.aeneid],\n    contractURI: \"\",\n})).spgNftContract;\nconst result1 = await client.ipAsset.registerIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgContractWith100WIP },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\nparentIpIdForWIP = result1.ipId;\nlicenseTermsIdFor100WIP = result1.licenseTermsIds[0];\nconst result2 = await client.ipAsset.registerIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgContractWith10ERC20 },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10n,\n                commercialRevShare: 10,\n                currency: generated_1.erc20Address[util_1.aeneid],\n            }),\n        },\n    ],\n});\nparentIpIdForERC20 = result2.ipId;\nlicenseTermsIdFor10ERC20 = result2.licenseTermsIds[0];",
                  "err": {},
                  "uuid": "35e05433-8daf-464d-8c2b-6d12a257d88b",
                  "parentUUID": "b5f9b5f3-4732-4bc8-9560-a45c448b0d1a",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "41240cac-5a91-482a-8716-28d34dfc6ef0",
                  "title": "SpgNftContract with ERC20 token",
                  "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
                  "file": "/test/integration/ipAsset.test.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should successfully when register ip with license terms data and royalty shares for ERC20",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register ip with license terms data and royalty shares for ERC20",
                      "timedOut": false,
                      "duration": 8916,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgContractWith10ERC20 },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "a703b34e-ef6b-4884-9820-dc310d025927",
                      "parentUUID": "41240cac-5a91-482a-8716-28d34dfc6ef0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when register ip with license terms data",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register ip with license terms data",
                      "timedOut": false,
                      "duration": 4817,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgContractWith10ERC20 },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: generated_1.erc20Address[util_1.aeneid],\n            }),\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "8190eba7-14e0-418c-92b6-5dc369b90b92",
                      "parentUUID": "41240cac-5a91-482a-8716-28d34dfc6ef0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when register ip with spgNftContract",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register ip with spgNftContract",
                      "timedOut": false,
                      "duration": 4566,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgContractWith10ERC20 },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "eb1d89d8-cc37-4b7b-aa57-1b6f5551752c",
                      "parentUUID": "41240cac-5a91-482a-8716-28d34dfc6ef0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when register derivative ip with derivData and royalty shares for ERC20",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register derivative ip with derivData and royalty shares for ERC20",
                      "timedOut": false,
                      "duration": 4900,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForERC20],\n        licenseTermsIds: [licenseTermsIdFor10ERC20],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "6ca0f036-17e8-498d-be18-20da7eca344f",
                      "parentUUID": "41240cac-5a91-482a-8716-28d34dfc6ef0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when register derivative ip with license token ids and derivData",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register derivative ip with license token ids and derivData",
                      "timedOut": false,
                      "duration": 9482,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsIdFor10ERC20,\n    licensorIpId: parentIpIdForERC20,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForERC20],\n        licenseTermsIds: [licenseTermsIdFor10ERC20],\n    },\n    licenseTokenIds: licenseTokenIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "159ca033-35bf-40b9-b76b-625cfc182b04",
                      "parentUUID": "41240cac-5a91-482a-8716-28d34dfc6ef0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when register derivative ip with derivData",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register derivative ip with derivData",
                      "timedOut": false,
                      "duration": 4939,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForERC20],\n        licenseTermsIds: [licenseTermsIdFor10ERC20],\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "a57a281d-7dde-47ec-9a21-96a423ff7b6b",
                      "parentUUID": "41240cac-5a91-482a-8716-28d34dfc6ef0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when link derivative ip given childIpId and license token ids",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when link derivative ip given childIpId and license token ids",
                      "timedOut": false,
                      "duration": 21513,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpIdForERC20],\n    licenseTermsIds: [licenseTermsIdFor10ERC20],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                      "err": {},
                      "uuid": "cb21817c-194a-4f41-8fc9-34043963cf5e",
                      "parentUUID": "41240cac-5a91-482a-8716-28d34dfc6ef0",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "a703b34e-ef6b-4884-9820-dc310d025927",
                    "8190eba7-14e0-418c-92b6-5dc369b90b92",
                    "eb1d89d8-cc37-4b7b-aa57-1b6f5551752c",
                    "6ca0f036-17e8-498d-be18-20da7eca344f",
                    "159ca033-35bf-40b9-b76b-625cfc182b04",
                    "a57a281d-7dde-47ec-9a21-96a423ff7b6b",
                    "cb21817c-194a-4f41-8fc9-34043963cf5e"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 59133,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 300000
                },
                {
                  "uuid": "679dac84-66f8-4d03-bede-e1a9afdc2011",
                  "title": "SpgNftContract with WIP token",
                  "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
                  "file": "/test/integration/ipAsset.test.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should successfully when register ip with license terms data and royalty shares for WIP",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register ip with license terms data and royalty shares for WIP",
                      "timedOut": false,
                      "duration": 0,
                      "state": "pending",
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": true,
                      "context": null,
                      "code": "",
                      "err": {},
                      "uuid": "7d08fd39-a5fc-4ad1-aa30-7a5ad9fae81f",
                      "parentUUID": "679dac84-66f8-4d03-bede-e1a9afdc2011",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when register ip with license terms data",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register ip with license terms data",
                      "timedOut": false,
                      "duration": 4899,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgContractWith100WIP },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "ea0e9349-dfab-4278-a7fd-c31ee2a26e95",
                      "parentUUID": "679dac84-66f8-4d03-bede-e1a9afdc2011",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when register ip with spgNftContract",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register ip with spgNftContract",
                      "timedOut": false,
                      "duration": 21469,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgContractWith100WIP },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "39454d6a-420c-49b9-9220-4bb67f510cdb",
                      "parentUUID": "679dac84-66f8-4d03-bede-e1a9afdc2011",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when register derivative ip with derivData and royalty shares for WIP",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register derivative ip with derivData and royalty shares for WIP",
                      "timedOut": false,
                      "duration": 9073,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgContractWith100WIP },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "b15bc316-40d5-48fa-8dc0-58f62c2b9cf8",
                      "parentUUID": "679dac84-66f8-4d03-bede-e1a9afdc2011",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when register derivative ip with license token ids and derivData",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register derivative ip with license token ids and derivData",
                      "timedOut": false,
                      "duration": 13821,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsIdFor100WIP,\n    licensorIpId: parentIpIdForWIP,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgContractWith100WIP },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n    licenseTokenIds: licenseTokenIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "3014f74d-38dc-4ef9-83da-1dbf3752e22e",
                      "parentUUID": "679dac84-66f8-4d03-bede-e1a9afdc2011",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when register derivative ip with derivData",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register derivative ip with derivData",
                      "timedOut": false,
                      "duration": 5009,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgContractWith100WIP },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "3bdd9fe9-7d23-4e90-9e0f-5d1d6eec6db6",
                      "parentUUID": "679dac84-66f8-4d03-bede-e1a9afdc2011",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when link derivative ip given childIpId and license token ids",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when link derivative ip given childIpId and license token ids",
                      "timedOut": false,
                      "duration": 17943,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpIdForWIP],\n    licenseTermsIds: [licenseTermsIdFor100WIP],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                      "err": {},
                      "uuid": "dd65408d-2201-40c3-b842-816260bed545",
                      "parentUUID": "679dac84-66f8-4d03-bede-e1a9afdc2011",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "ea0e9349-dfab-4278-a7fd-c31ee2a26e95",
                    "39454d6a-420c-49b9-9220-4bb67f510cdb",
                    "b15bc316-40d5-48fa-8dc0-58f62c2b9cf8",
                    "3014f74d-38dc-4ef9-83da-1dbf3752e22e",
                    "3bdd9fe9-7d23-4e90-9e0f-5d1d6eec6db6",
                    "dd65408d-2201-40c3-b842-816260bed545"
                  ],
                  "failures": [],
                  "pending": [
                    "7d08fd39-a5fc-4ad1-aa30-7a5ad9fae81f"
                  ],
                  "skipped": [],
                  "duration": 72214,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 300000
                },
                {
                  "uuid": "e433fecc-2019-41ff-b19f-572d2d4434be",
                  "title": "Mixed ERC20 and WIP token",
                  "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
                  "file": "/test/integration/ipAsset.test.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should successfully when register derivative ip with derivData and royalty shares for mixed ERC20 and WIP",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee Mixed ERC20 and WIP token should successfully when register derivative ip with derivData and royalty shares for mixed ERC20 and WIP",
                      "timedOut": false,
                      "duration": 9379,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "c68142b8-ccf5-426c-a4e4-895f8af22e66",
                      "parentUUID": "e433fecc-2019-41ff-b19f-572d2d4434be",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully when register derivative ip with license token ids and derivData",
                      "fullTitle": "IP Asset Functions with ERC20 and WIP token fee Mixed ERC20 and WIP token should successfully when register derivative ip with license token ids and derivData",
                      "timedOut": false,
                      "duration": 22195,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsIdFor100WIP,\n    licensorIpId: parentIpIdForWIP,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \"mint\", spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n    licenseTokenIds: licenseTokenIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                      "err": {},
                      "uuid": "3358683a-393a-4c5f-a54c-401c9fbb32c0",
                      "parentUUID": "e433fecc-2019-41ff-b19f-572d2d4434be",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "c68142b8-ccf5-426c-a4e4-895f8af22e66",
                    "3358683a-393a-4c5f-a54c-401c9fbb32c0"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 31574,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 300000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "fa170ee5-f4b8-455b-a6ff-08b55193187e",
          "title": "License Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts",
          "file": "/test/integration/license.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"License Functions\"",
              "fullTitle": "License Functions \"before all\" hook in \"License Functions\"",
              "timedOut": false,
              "duration": 37,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();\nconst derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nclientB = derivedClient.clientB;",
              "err": {},
              "uuid": "2832240c-f020-427e-bc1c-7ee019708a37",
              "parentUUID": "fa170ee5-f4b8-455b-a6ff-08b55193187e",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "eecbacd1-762e-4258-bc9d-fcda1d005b8e",
              "title": "register license with different types",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts",
              "file": "/test/integration/license.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should register license ",
                  "fullTitle": "License Functions register license with different types should register license ",
                  "timedOut": false,
                  "duration": 35,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.registerPILTerms({\n    defaultMintingFee: 0,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    transferable: false,\n    royaltyPolicy: viem_1.zeroAddress,\n    commercialUse: false,\n    commercialAttribution: false,\n    commercializerChecker: viem_1.zeroAddress,\n    commercializerCheckerData: \"0x\",\n    commercialRevShare: 0,\n    derivativesAllowed: false,\n    derivativesAttribution: false,\n    derivativesApproval: false,\n    derivativesReciprocal: false,\n    uri: \"\",\n    expiration: 0,\n    commercialRevCeiling: 0,\n    derivativeRevCeiling: 0,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "d390ece4-81de-45e3-9c39-5bf8c9fff2a6",
                  "parentUUID": "eecbacd1-762e-4258-bc9d-fcda1d005b8e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register license with non commercial social remixing PIL",
                  "fullTitle": "License Functions register license with different types should register license with non commercial social remixing PIL",
                  "timedOut": false,
                  "duration": 34,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.registerNonComSocialRemixingPIL();\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "40b1c86d-b45e-4dac-9c1a-dbea6c2dce9e",
                  "parentUUID": "eecbacd1-762e-4258-bc9d-fcda1d005b8e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register license with commercial use",
                  "fullTitle": "License Functions register license with different types should register license with commercial use",
                  "timedOut": false,
                  "duration": 38,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.registerCommercialUsePIL({\n    defaultMintingFee: \"1\",\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "20f599ed-c3f6-4c9e-a6cb-976bfce39097",
                  "parentUUID": "eecbacd1-762e-4258-bc9d-fcda1d005b8e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register license with commercial Remix use",
                  "fullTitle": "License Functions register license with different types should register license with commercial Remix use",
                  "timedOut": false,
                  "duration": 44,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.registerCommercialRemixPIL({\n    defaultMintingFee: \"1\",\n    commercialRevShare: 100,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "1d039170-3b34-487b-9d02-d222e6bb9097",
                  "parentUUID": "eecbacd1-762e-4258-bc9d-fcda1d005b8e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register license with creative commons attribution PIL",
                  "fullTitle": "License Functions register license with different types should register license with creative commons attribution PIL",
                  "timedOut": false,
                  "duration": 36,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.registerCreativeCommonsAttributionPIL({\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicyAddress: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "bd0e2ed0-f760-4081-8cf3-4272bfea2e9d",
                  "parentUUID": "eecbacd1-762e-4258-bc9d-fcda1d005b8e",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "d390ece4-81de-45e3-9c39-5bf8c9fff2a6",
                "40b1c86d-b45e-4dac-9c1a-dbea6c2dce9e",
                "20f599ed-c3f6-4c9e-a6cb-976bfce39097",
                "1d039170-3b34-487b-9d02-d222e6bb9097",
                "bd0e2ed0-f760-4081-8cf3-4272bfea2e9d"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 187,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "b78ad5a6-95b4-4f8e-b96b-22d28ff00d42",
              "title": "attach License Terms and mint license tokens",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts",
              "file": "/test/integration/license.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"attach License Terms and mint license tokens\"",
                  "fullTitle": "License Functions attach License Terms and mint license tokens \"before all\" hook in \"attach License Terms and mint license tokens\"",
                  "timedOut": false,
                  "duration": 13100,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "tokenId = await (0, util_1.getTokenId)();\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nconst mockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\nawait mockERC20.approve(generated_1.licensingModuleAddress[util_1.aeneid], viem_1.maxUint256);\nipId = registerResult.ipId;\nconst registerLicenseResult = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 0n,\n    commercialRevShare: 100,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n}));\nlicenseId = registerLicenseResult.licenseTermsId;\nconst paidLicenseResult = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 100n,\n    commercialRevShare: 10,\n    currency: generated_1.erc20Address[util_1.aeneid],\n}));\npaidLicenseId = paidLicenseResult.licenseTermsId;",
                  "err": {},
                  "uuid": "4f39d350-c3e6-4327-a0b8-562908fd9e7c",
                  "parentUUID": "b78ad5a6-95b4-4f8e-b96b-22d28ff00d42",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should attach License Terms",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should attach License Terms",
                  "timedOut": false,
                  "duration": 4466,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "e7b22f20-445a-41cf-b452-0505156bde08",
                  "parentUUID": "b78ad5a6-95b4-4f8e-b96b-22d28ff00d42",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to attach another license terms",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should be able to attach another license terms",
                  "timedOut": false,
                  "duration": 4507,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: paidLicenseId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "36e6e407-6d48-4c19-b9fa-3a022edd4368",
                  "parentUUID": "b78ad5a6-95b4-4f8e-b96b-22d28ff00d42",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint license tokens with ip owner",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should mint license tokens with ip owner",
                  "timedOut": false,
                  "duration": 4546,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseId,\n    licensorIpId: ipId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\"array\");",
                  "err": {},
                  "uuid": "245eb6c6-2677-44e5-8295-93aeb77b9dd9",
                  "parentUUID": "b78ad5a6-95b4-4f8e-b96b-22d28ff00d42",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint license tokens with non ip owner",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should mint license tokens with non ip owner",
                  "timedOut": false,
                  "duration": 21908,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// register ip with another wallet account\nconst tokenIdB = await (0, util_1.getTokenId)();\nconst registerResult = await clientB.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenIdB,\n});\nconst ipIdB = registerResult.ipId;\n// attach license terms to the ip\nawait client.license.attachLicenseTerms({\n    ipId: ipIdB,\n    licenseTermsId: licenseId,\n});\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseId,\n    licensorIpId: ipIdB,\n    maxMintingFee: 10000000,\n    maxRevenueShare: 100,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\"array\");",
                  "err": {},
                  "uuid": "da10bc2d-9ac8-4abc-9496-f207b9311897",
                  "parentUUID": "b78ad5a6-95b4-4f8e-b96b-22d28ff00d42",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint license token with default license terms",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should mint license token with default license terms",
                  "timedOut": false,
                  "duration": 4543,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// get default license terms id\nconst licenseRegistryReadOnlyClient = new generated_1.LicenseRegistryReadOnlyClient(util_1.publicClient);\nconst { licenseTermsId: defaultLicenseTermsId } = await licenseRegistryReadOnlyClient.getDefaultLicenseTerms();\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: defaultLicenseTermsId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 1,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\"array\");",
                  "err": {},
                  "uuid": "6e8f8678-125b-4136-bc77-5ca3ef1557c8",
                  "parentUUID": "b78ad5a6-95b4-4f8e-b96b-22d28ff00d42",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint license tokens with fee and pay with IP",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should mint license tokens with fee and pay with IP",
                  "timedOut": false,
                  "duration": 8813,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const balanceBefore = await client.getWalletBalance();\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: paidLicenseId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 50,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 100n));",
                  "err": {},
                  "uuid": "2b3b52d7-4870-4dee-b8ef-e835b892b04d",
                  "parentUUID": "b78ad5a6-95b4-4f8e-b96b-22d28ff00d42",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should get license terms",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should get license terms",
                  "timedOut": false,
                  "duration": 38,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.getLicenseTerms(licenseId);\n(0, chai_1.expect)(result).to.be.an(\"object\");",
                  "err": {},
                  "uuid": "d4d1a7c2-7305-43d9-9fb6-38ffa77d53fe",
                  "parentUUID": "b78ad5a6-95b4-4f8e-b96b-22d28ff00d42",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should predict minting license fee",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should predict minting license fee",
                  "timedOut": false,
                  "duration": 115,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.predictMintingLicenseFee({\n    licenseTermsId: licenseId,\n    licensorIpId: ipId,\n    amount: 1,\n});\n(0, chai_1.expect)(result.currencyToken).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenAmount).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "2086683f-645a-44f2-90e0-7792d35ac76a",
                  "parentUUID": "b78ad5a6-95b4-4f8e-b96b-22d28ff00d42",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [
                {
                  "uuid": "586f0269-7925-40fb-ac81-cdc0cfa86b2d",
                  "title": "licensing config and max license tokens",
                  "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts",
                  "file": "/test/integration/license.test.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should set licensing config",
                      "fullTitle": "License Functions attach License Terms and mint license tokens licensing config and max license tokens should set licensing config",
                      "timedOut": false,
                      "duration": 8529,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.license.setLicensingConfig({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n    licensingConfig,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.success).to.equal(true);",
                      "err": {},
                      "uuid": "23ec995e-2c6e-4430-b5d3-4935b360df71",
                      "parentUUID": "586f0269-7925-40fb-ac81-cdc0cfa86b2d",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should get licensing config",
                      "fullTitle": "License Functions attach License Terms and mint license tokens licensing config and max license tokens should get licensing config",
                      "timedOut": false,
                      "duration": 38,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.license.getLicensingConfig({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n});\n(0, chai_1.expect)(result).to.deep.equal({\n    ...licensingConfig,\n    expectMinimumGroupRewardShare: 1 * 10 ** 6,\n});",
                      "err": {},
                      "uuid": "3cba3b32-787c-4ae6-ba58-5d042acb09c4",
                      "parentUUID": "586f0269-7925-40fb-ac81-cdc0cfa86b2d",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should set max license tokens",
                      "fullTitle": "License Functions attach License Terms and mint license tokens licensing config and max license tokens should set max license tokens",
                      "timedOut": false,
                      "duration": 8908,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.license.setMaxLicenseTokens({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n    maxLicenseTokens: 100,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                      "err": {},
                      "uuid": "f8340074-c930-41ca-ae42-e44bcab78e45",
                      "parentUUID": "586f0269-7925-40fb-ac81-cdc0cfa86b2d",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "23ec995e-2c6e-4430-b5d3-4935b360df71",
                    "3cba3b32-787c-4ae6-ba58-5d042acb09c4",
                    "f8340074-c930-41ca-ae42-e44bcab78e45"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 17475,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 300000
                }
              ],
              "passes": [
                "e7b22f20-445a-41cf-b452-0505156bde08",
                "36e6e407-6d48-4c19-b9fa-3a022edd4368",
                "245eb6c6-2677-44e5-8295-93aeb77b9dd9",
                "da10bc2d-9ac8-4abc-9496-f207b9311897",
                "6e8f8678-125b-4136-bc77-5ca3ef1557c8",
                "2b3b52d7-4870-4dee-b8ef-e835b892b04d",
                "d4d1a7c2-7305-43d9-9fb6-38ffa77d53fe",
                "2086683f-645a-44f2-90e0-7792d35ac76a"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 48936,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "ac4d7076-35f0-4c53-8c20-949e55037c0c",
              "title": "register pil terms and attach",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts",
              "file": "/test/integration/license.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"register pil terms and attach\"",
                  "fullTitle": "License Functions register pil terms and attach \"before all\" hook in \"register pil terms and attach\"",
                  "timedOut": false,
                  "duration": 8814,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "tokenId = (await (0, util_1.getTokenId)());\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId,\n});\nipId = registerResult.ipId;",
                  "err": {},
                  "uuid": "fae5023e-93fd-4c70-8782-3662c8af29f6",
                  "parentUUID": "ac4d7076-35f0-4c53-8c20-949e55037c0c",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should register PIL terms and attach",
                  "fullTitle": "License Functions register pil terms and attach should register PIL terms and attach",
                  "timedOut": false,
                  "duration": 4673,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.registerPilTermsAndAttach({\n    ipId: ipId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 0n,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.nonCommercialSocialRemixing(),\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"undefined\");",
                  "err": {},
                  "uuid": "27b77781-b86d-47f8-a3ed-6b642a73f396",
                  "parentUUID": "ac4d7076-35f0-4c53-8c20-949e55037c0c",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register PIL terms and attach with license terms max limit",
                  "fullTitle": "License Functions register pil terms and attach should register PIL terms and attach with license terms max limit",
                  "timedOut": false,
                  "duration": 9366,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.registerPilTermsAndAttach({\n    ipId: ipId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 0n,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 1,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 0n,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);",
                  "err": {},
                  "uuid": "67e4695f-fb32-43bf-93b0-5d5188bb8a9f",
                  "parentUUID": "ac4d7076-35f0-4c53-8c20-949e55037c0c",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "27b77781-b86d-47f8-a3ed-6b642a73f396",
                "67e4695f-fb32-43bf-93b0-5d5188bb8a9f"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 14039,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "0aa7949f-3cf4-4bfe-83e8-f75a36b89921",
              "title": "Creative Commons Attribution License Tests",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts",
              "file": "/test/integration/license.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Creative Commons Attribution License Tests\"",
                  "fullTitle": "License Functions Creative Commons Attribution License Tests \"before all\" hook in \"Creative Commons Attribution License Tests\"",
                  "timedOut": false,
                  "duration": 12923,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "tokenId = await (0, util_1.getTokenId)();\n// Register an IP asset\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = registerResult.ipId;\n// Create a Creative Commons Attribution license\nconst ccLicenseResult = await client.license.registerCreativeCommonsAttributionPIL({\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicyAddress: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n});\nccLicenseTermsId = ccLicenseResult.licenseTermsId;",
                  "err": {},
                  "uuid": "dd40fd77-3df8-4c48-83b9-e7350fa2261b",
                  "parentUUID": "0aa7949f-3cf4-4bfe-83e8-f75a36b89921",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should verify the license terms match Creative Commons Attribution specifications",
                  "fullTitle": "License Functions Creative Commons Attribution License Tests should verify the license terms match Creative Commons Attribution specifications",
                  "timedOut": false,
                  "duration": 36,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const licenseTerms = await client.license.getLicenseTerms(ccLicenseTermsId);\n(0, chai_1.expect)(licenseTerms.terms.transferable).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.commercialUse).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesAllowed).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesAttribution).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesReciprocal).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesApproval).to.equal(false);\n(0, chai_1.expect)(licenseTerms.terms.commercialAttribution).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.commercialRevShare).to.equal(0);\n(0, chai_1.expect)(licenseTerms.terms.defaultMintingFee).to.equal(0n);\n(0, chai_1.expect)(licenseTerms.terms.royaltyPolicy).to.equal(generated_1.royaltyPolicyLapAddress[util_1.aeneid]);\n(0, chai_1.expect)(licenseTerms.terms.expiration).to.equal(0n);",
                  "err": {},
                  "uuid": "0b7d8f72-4363-4ce0-aca5-eb358970cd43",
                  "parentUUID": "0aa7949f-3cf4-4bfe-83e8-f75a36b89921",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should attach Creative Commons Attribution license to an IP",
                  "fullTitle": "License Functions Creative Commons Attribution License Tests should attach Creative Commons Attribution license to an IP",
                  "timedOut": false,
                  "duration": 8565,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const attachResult = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: ccLicenseTermsId,\n});\n(0, chai_1.expect)(attachResult.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(attachResult.success).to.equal(true);\nconst licenseRegistryReadOnlyClient = new generated_1.LicenseRegistryReadOnlyClient(util_1.publicClient);\nconst hasLicense = await licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({\n    ipId: ipId,\n    licenseTemplate: client.ipAsset.licenseTemplateClient.address,\n    licenseTermsId: ccLicenseTermsId,\n});\n(0, chai_1.expect)(hasLicense).to.equal(true);",
                  "err": {},
                  "uuid": "308b0caf-ad1f-4fc2-a6df-86012a4eb910",
                  "parentUUID": "0aa7949f-3cf4-4bfe-83e8-f75a36b89921",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint CC-BY license tokens with no minting fee",
                  "fullTitle": "License Functions Creative Commons Attribution License Tests should mint CC-BY license tokens with no minting fee",
                  "timedOut": false,
                  "duration": 8759,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Get wallet balance before minting\nconst balanceBefore = await client.getWalletBalance();\n// Predict the minting fee (should be zero for CC-BY)\nconst feePredict = await client.license.predictMintingLicenseFee({\n    licenseTermsId: ccLicenseTermsId,\n    licensorIpId: ipId,\n    amount: 1,\n});\n// CC-BY licenses should have zero minting fee\n(0, chai_1.expect)(feePredict.tokenAmount).to.equal(0n);\nconst mintResult = await client.license.mintLicenseTokens({\n    licenseTermsId: ccLicenseTermsId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 0,\n});\n(0, chai_1.expect)(mintResult.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(mintResult.licenseTokenIds).to.be.a(\"array\");\nconst balanceAfter = await client.getWalletBalance();\n// Verify no fee was charged just gas\n// This checks that any difference is very small (just gas costs)\nconst balanceDiff = balanceBefore - balanceAfter;\nconst gasUsed = mintResult.receipt.gasUsed;\nconst effectiveGasPrice = mintResult.receipt.effectiveGasPrice;\nconst totalGas = gasUsed * effectiveGasPrice;\n// Confirms the balance diff only reflects gas cost, since license fee is zero.\n(0, chai_1.expect)(balanceDiff).to.equal(totalGas); // Small amount for gas",
                  "err": {},
                  "uuid": "50b3782b-0886-4de7-ad4d-3b08c78ce331",
                  "parentUUID": "0aa7949f-3cf4-4bfe-83e8-f75a36b89921",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "0b7d8f72-4363-4ce0-aca5-eb358970cd43",
                "308b0caf-ad1f-4fc2-a6df-86012a4eb910",
                "50b3782b-0886-4de7-ad4d-3b08c78ce331"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 17360,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "2c7ed71e-7632-45bc-b06b-1f3058c8466b",
          "title": "nftClient Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts",
          "file": "/test/integration/nftClient.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"nftClient Functions\"",
              "fullTitle": "nftClient Functions \"before all\" hook in \"nftClient Functions\"",
              "timedOut": false,
              "duration": 3,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();",
              "err": {},
              "uuid": "7e7d062b-933a-4220-a49a-d9b9090461de",
              "parentUUID": "2c7ed71e-7632-45bc-b06b-1f3058c8466b",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "701fdf5e-75a7-4013-9fc1-72b5035349da",
              "title": "createNFTCollection",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts",
              "file": "/test/integration/nftClient.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully create public nft collection with minimal params",
                  "fullTitle": "nftClient Functions createNFTCollection should successfully create public nft collection with minimal params",
                  "timedOut": false,
                  "duration": 4343,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\"string\");\n(0, chai_1.expect)(txData.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "5d350e85-fda9-4e4c-b835-629bca2d1238",
                  "parentUUID": "701fdf5e-75a7-4013-9fc1-72b5035349da",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully create collection with custom mint fee",
                  "fullTitle": "nftClient Functions createNFTCollection should successfully create collection with custom mint fee",
                  "timedOut": false,
                  "duration": 4359,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"paid-collection\",\n    symbol: \"PAID\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFee: 10000000,\n    mintFeeToken: generated_1.erc20Address[mockData_1.aeneid],\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\"string\");\nspgNftContract = txData.spgNftContract;",
                  "err": {},
                  "uuid": "06b44ccc-ac4e-4496-81b4-4506fb407b8b",
                  "parentUUID": "701fdf5e-75a7-4013-9fc1-72b5035349da",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully create private collection",
                  "fullTitle": "nftClient Functions createNFTCollection should successfully create private collection",
                  "timedOut": false,
                  "duration": 4358,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"private-collection\",\n    symbol: \"PRIV\",\n    maxSupply: 100,\n    isPublicMinting: false, // private minting\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: false, // starts closed\n    contractURI: \"test-uri\",\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "d9009431-e7c1-45d0-8ee7-57fdbd37bd51",
                  "parentUUID": "701fdf5e-75a7-4013-9fc1-72b5035349da",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully create collection with baseURI",
                  "fullTitle": "nftClient Functions createNFTCollection should successfully create collection with baseURI",
                  "timedOut": false,
                  "duration": 4362,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"uri-collection\",\n    symbol: \"URI\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    baseURI: \"ipfs://QmTest/\",\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "8ec6172c-fbe4-483b-8af5-df97deb2ff13",
                  "parentUUID": "701fdf5e-75a7-4013-9fc1-72b5035349da",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully create collection with custom owner",
                  "fullTitle": "nftClient Functions createNFTCollection should successfully create collection with custom owner",
                  "timedOut": false,
                  "duration": 4359,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"owned-collection\",\n    symbol: \"OWN\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    owner: util_1.TEST_WALLET_ADDRESS,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "551952b3-1f34-4635-8519-2118112e71fb",
                  "parentUUID": "701fdf5e-75a7-4013-9fc1-72b5035349da",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully get encoded transaction data",
                  "fullTitle": "nftClient Functions createNFTCollection should successfully get encoded transaction data",
                  "timedOut": false,
                  "duration": 1,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"encoded-collection\",\n    symbol: \"ENC\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    txOptions: {\n        encodedTxDataOnly: true,\n    },\n});\n(0, chai_1.expect)(txData.encodedTxData).to.be.an(\"object\");\n(0, chai_1.expect)(txData.encodedTxData?.data).to.be.a(\"string\");\n(0, chai_1.expect)(txData.encodedTxData?.to).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "bf585d9f-39f4-4168-a7d5-b518c4c7c17c",
                  "parentUUID": "701fdf5e-75a7-4013-9fc1-72b5035349da",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with invalid mint fee token",
                  "fullTitle": "nftClient Functions createNFTCollection should fail with invalid mint fee token",
                  "timedOut": false,
                  "duration": 2,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.nftClient.createNFTCollection({\n    name: \"invalid-fee-collection\",\n    symbol: \"INV\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFee: 1000000000000000000,\n    mintFeeToken: \"0x0000000000000000000000000000000000000000\",\n})).to.be.rejectedWith(\"Invalid mint fee token address\");",
                  "err": {},
                  "uuid": "6e1e24cb-00b1-4bb9-9296-caed32509b82",
                  "parentUUID": "701fdf5e-75a7-4013-9fc1-72b5035349da",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "5d350e85-fda9-4e4c-b835-629bca2d1238",
                "06b44ccc-ac4e-4496-81b4-4506fb407b8b",
                "d9009431-e7c1-45d0-8ee7-57fdbd37bd51",
                "8ec6172c-fbe4-483b-8af5-df97deb2ff13",
                "551952b3-1f34-4635-8519-2118112e71fb",
                "bf585d9f-39f4-4168-a7d5-b518c4c7c17c",
                "6e1e24cb-00b1-4bb9-9296-caed32509b82"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 21784,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "1b9a0742-26ab-4c3f-84de-a14e83ba29d3",
              "title": "Mint Fee",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts",
              "file": "/test/integration/nftClient.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully get mint fee token",
                  "fullTitle": "nftClient Functions Mint Fee should successfully get mint fee token",
                  "timedOut": false,
                  "duration": 34,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const mintFeeToken = await client.nftClient.getMintFeeToken(spgNftContract);\n(0, chai_1.expect)(mintFeeToken).to.equal(generated_1.erc20Address[mockData_1.aeneid]);",
                  "err": {},
                  "uuid": "d1e597e4-abf1-4b07-9e56-36d055a2fabf",
                  "parentUUID": "1b9a0742-26ab-4c3f-84de-a14e83ba29d3",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully get mint fee",
                  "fullTitle": "nftClient Functions Mint Fee should successfully get mint fee",
                  "timedOut": false,
                  "duration": 29,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const mintFee = await client.nftClient.getMintFee(spgNftContract);\n(0, chai_1.expect)(mintFee).to.equal(10000000n);",
                  "err": {},
                  "uuid": "cbfc72ba-3cd8-40e8-94c3-629b153f4572",
                  "parentUUID": "1b9a0742-26ab-4c3f-84de-a14e83ba29d3",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "d1e597e4-abf1-4b07-9e56-36d055a2fabf",
                "cbfc72ba-3cd8-40e8-94c3-629b153f4572"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 63,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "d1df0ef8-dcce-468c-a94b-7b0267bae5f0",
              "title": "set and get tokenURI",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts",
              "file": "/test/integration/nftClient.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully set token URI",
                  "fullTitle": "nftClient Functions set and get tokenURI should successfully set token URI",
                  "timedOut": false,
                  "duration": 13147,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Setup: Approve the contract for ERC20 transfers\nconst erc20Client = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[mockData_1.aeneid]);\nconst txHash = await erc20Client.approve(spgNftContract, viem_1.maxUint256);\nawait util_1.publicClient.waitForTransactionReceipt({ hash: txHash });\n// Mint a new token with initial metadata\nconst tokenId = await (0, util_1.mintBySpg)(spgNftContract, \"ipfs://QmTest/\");\n(0, chai_1.expect)(tokenId).to.be.a(\"bigint\");\n// Update the token URI\nconst updatedMetadata = \"ipfs://QmUpdated/metadata.json\";\nconst result = await client.nftClient.setTokenURI({\n    tokenId: tokenId,\n    tokenURI: updatedMetadata,\n    spgNftContract,\n});\n// Verify the transaction\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n// Verification that the URI was updated\nconst tokenURI = await client.nftClient.getTokenURI({\n    tokenId,\n    spgNftContract,\n});\n(0, chai_1.expect)(tokenURI).to.equal(updatedMetadata);",
                  "err": {},
                  "uuid": "862d7ddb-3a12-4c03-a62a-37f402ba43e2",
                  "parentUUID": "d1df0ef8-dcce-468c-a94b-7b0267bae5f0",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "862d7ddb-3a12-4c03-a62a-37f402ba43e2"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 13147,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "f0d87270-bb02-41be-9ca9-6a099672b72a",
              "title": "Error Cases",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts",
              "file": "/test/integration/nftClient.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "fails with invalid token ID",
                  "fullTitle": "nftClient Functions Error Cases fails with invalid token ID",
                  "timedOut": false,
                  "duration": 4387,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const erc20Client = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[mockData_1.aeneid]);\nconst txHash = await erc20Client.approve(spgNftContract, viem_1.maxUint256);\nawait util_1.publicClient.waitForTransactionReceipt({ hash: txHash });\nconst invalidTokenId = 999999999999999n;\nconst updatedMetadata = \"ipfs://QmUpdated/metadata.json\";\nawait (0, chai_1.expect)(client.nftClient.setTokenURI({\n    tokenId: invalidTokenId,\n    tokenURI: updatedMetadata,\n    spgNftContract,\n})).to.be.rejectedWith(\"Failed to set token URI\");",
                  "err": {},
                  "uuid": "774b7471-149d-4363-8d16-6b624d66f6a1",
                  "parentUUID": "f0d87270-bb02-41be-9ca9-6a099672b72a",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "774b7471-149d-4363-8d16-6b624d66f6a1"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 4387,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "f1e2137f-6264-455b-844e-e9d3deb26690",
          "title": "Permission Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts",
          "file": "/test/integration/permission.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Permission Functions\"",
              "fullTitle": "Permission Functions \"before all\" hook in \"Permission Functions\"",
              "timedOut": false,
              "duration": 8819,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = response.ipId;",
              "err": {},
              "uuid": "3c48bf66-11a5-42ac-8352-ec5ac9f127be",
              "parentUUID": "f1e2137f-6264-455b-844e-e9d3deb26690",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "3d266899-cd10-4179-8cac-300e768ec765",
              "title": "Single Permission Operations",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts",
              "file": "/test/integration/permission.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should set permission successfully",
                  "fullTitle": "Permission Functions Single Permission Operations should set permission successfully",
                  "timedOut": false,
                  "duration": 4502,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.permission.setPermission({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n    func: \"function setAll(address,string,bytes32,bytes32)\",\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(response.success).to.equal(true);",
                  "err": {},
                  "uuid": "f866809d-cc2d-4983-a222-74074aad8765",
                  "parentUUID": "3d266899-cd10-4179-8cac-300e768ec765",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should set all permissions successfully",
                  "fullTitle": "Permission Functions Single Permission Operations should set all permissions successfully",
                  "timedOut": false,
                  "duration": 4367,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.permission.setAllPermissions({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    permission: permission_1.AccessPermission.ALLOW,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(response.success).to.equal(true);",
                  "err": {},
                  "uuid": "29acf2b1-43a0-42b5-b78a-a8f190788a81",
                  "parentUUID": "3d266899-cd10-4179-8cac-300e768ec765",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "f866809d-cc2d-4983-a222-74074aad8765",
                "29acf2b1-43a0-42b5-b78a-a8f190788a81"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 8869,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "e0fcc4bd-04f0-4a14-bfe6-90f7d7e8345a",
              "title": "Permission Signatures",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts",
              "file": "/test/integration/permission.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should create set permission signature",
                  "fullTitle": "Permission Functions Permission Signatures should create set permission signature",
                  "timedOut": false,
                  "duration": 4432,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.permission.createSetPermissionSignature({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    func: \"function setAll(address,string,bytes32,bytes32)\",\n    permission: permission_1.AccessPermission.ALLOW,\n    deadline: 60000n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(response.success).to.equal(true);",
                  "err": {},
                  "uuid": "3b4e0f5e-b06b-44cb-88b5-306f58b7abad",
                  "parentUUID": "e0fcc4bd-04f0-4a14-bfe6-90f7d7e8345a",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "3b4e0f5e-b06b-44cb-88b5-306f58b7abad"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 4432,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "cf134ef4-579f-4f16-af4b-4668a6654d49",
              "title": "Batch Operations",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts",
              "file": "/test/integration/permission.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should set batch permissions successfully",
                  "fullTitle": "Permission Functions Batch Operations should set batch permissions successfully",
                  "timedOut": false,
                  "duration": 4374,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.permission.setBatchPermissions({\n    permissions: [\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.ALLOW,\n            func: \"function setAll(address,string,bytes32,bytes32)\",\n        },\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.DENY,\n            func: \"function freezeMetadata(address)\",\n        },\n    ],\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(response.success).to.equal(true);",
                  "err": {},
                  "uuid": "bd63db37-1cf1-40a0-ba00-214381a58f91",
                  "parentUUID": "cf134ef4-579f-4f16-af4b-4668a6654d49",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should create batch permission signature",
                  "fullTitle": "Permission Functions Batch Operations should create batch permission signature",
                  "timedOut": false,
                  "duration": 4438,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.permission.createBatchPermissionSignature({\n    ipId: ipId,\n    permissions: [\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.ALLOW,\n            func: \"function setAll(address,string,bytes32,bytes32)\",\n        },\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.DENY,\n            func: \"function freezeMetadata(address)\",\n        },\n    ],\n    deadline: 60000n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(response.success).to.equal(true);",
                  "err": {},
                  "uuid": "4ed4afff-3b21-4b7d-a2e9-2747fc9269a3",
                  "parentUUID": "cf134ef4-579f-4f16-af4b-4668a6654d49",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "bd63db37-1cf1-40a0-ba00-214381a58f91",
                "4ed4afff-3b21-4b7d-a2e9-2747fc9269a3"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 8812,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "8b0aa724-8d9b-471c-83f6-f8ee5724c2ac",
              "title": "Error Cases",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts",
              "file": "/test/integration/permission.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should fail when setting permission for unregistered IP",
                  "fullTitle": "Permission Functions Error Cases should fail when setting permission for unregistered IP",
                  "timedOut": false,
                  "duration": 31,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const unregisteredIpId = \"0x1234567890123456789012345678901234567890\";\nawait (0, chai_1.expect)(client.permission.setPermission({\n    ipId: unregisteredIpId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n})).to.be.rejectedWith(`IP id with ${unregisteredIpId} is not registered.`);",
                  "err": {},
                  "uuid": "5fb1566c-bdfe-4241-abd2-aba43c3fa031",
                  "parentUUID": "8b0aa724-8d9b-471c-83f6-f8ee5724c2ac",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with invalid function signature",
                  "fullTitle": "Permission Functions Error Cases should fail with invalid function signature",
                  "timedOut": false,
                  "duration": 34,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.permission.setPermission({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n    func: \"invalid_function_signature\",\n})).to.be.rejected;",
                  "err": {},
                  "uuid": "4701741a-8e4a-4aa6-8ab6-2567b7d5507b",
                  "parentUUID": "8b0aa724-8d9b-471c-83f6-f8ee5724c2ac",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "5fb1566c-bdfe-4241-abd2-aba43c3fa031",
                "4701741a-8e4a-4aa6-8ab6-2567b7d5507b"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 65,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "4222cd32-b362-4dfa-a138-1432efa0eb3b",
          "title": "Royalty Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts",
          "file": "/test/integration/royalty.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Royalty Functions\"",
              "fullTitle": "Royalty Functions \"before all\" hook in \"Royalty Functions\"",
              "timedOut": false,
              "duration": 26966,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();\nmockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\n// Setup initial state\nparentIpId = await getIpId();\nchildIpId = await getIpId();\nlicenseTermsId = await getCommercialPolicyId();\n// Setup relationships and approvals\nawait attachLicenseTerms(parentIpId, licenseTermsId);\nawait mockERC20.mint(util_1.TEST_WALLET_ADDRESS, (0, viem_1.parseEther)(\"10\"));\nawait mockERC20.approve(generated_1.royaltyModuleAddress[util_1.aeneid], viem_1.maxUint256);\n// Register derivative\nawait client.ipAsset.registerDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [licenseTermsId],\n    maxMintingFee: 0,\n    maxRts: 0,\n    maxRevenueShare: 0,\n});",
              "err": {},
              "uuid": "873e7c49-e0f2-4606-9250-91f793e4fb09",
              "parentUUID": "4222cd32-b362-4dfa-a138-1432efa0eb3b",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "6363b1e5-18d0-4b33-99bd-78b25ca8f127",
              "title": "Royalty Payments",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts",
              "file": "/test/integration/royalty.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully pay royalty on behalf",
                  "fullTitle": "Royalty Functions Royalty Payments should successfully pay royalty on behalf",
                  "timedOut": false,
                  "duration": 8506,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: parentIpId,\n    payerIpId: childIpId,\n    token: generated_1.erc20Address[util_1.aeneid],\n    amount: 1,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "c206bda9-f439-469b-bb9d-7d4e63e4ce1f",
                  "parentUUID": "6363b1e5-18d0-4b33-99bd-78b25ca8f127",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should auto convert IP to WIP when paying WIP on behalf",
                  "fullTitle": "Royalty Functions Royalty Payments should auto convert IP to WIP when paying WIP on behalf",
                  "timedOut": false,
                  "duration": 4647,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const balanceBefore = await client.getWalletBalance();\nconst response = await client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: parentIpId,\n    payerIpId: childIpId,\n    token: common_1.WIP_TOKEN_ADDRESS,\n    amount: 100n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 100n));",
                  "err": {},
                  "uuid": "c1bff49c-c62e-4b2f-850d-f5ea2349d816",
                  "parentUUID": "6363b1e5-18d0-4b33-99bd-78b25ca8f127",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail to pay royalty with unregistered receiver",
                  "fullTitle": "Royalty Functions Royalty Payments should fail to pay royalty with unregistered receiver",
                  "timedOut": false,
                  "duration": 30,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const unregisteredIpId = \"0x1234567890123456789012345678901234567890\";\nawait (0, chai_1.expect)(client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: unregisteredIpId,\n    payerIpId: childIpId,\n    token: generated_1.erc20Address[util_1.aeneid],\n    amount: 10 * 10 ** 2,\n})).to.be.rejectedWith(`The receiver IP with id ${unregisteredIpId} is not registered.`);",
                  "err": {},
                  "uuid": "b510bd1b-01b6-46a7-aaf3-59bdb0aa50f1",
                  "parentUUID": "6363b1e5-18d0-4b33-99bd-78b25ca8f127",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow the royalty vault to transfer its native tokens to a wallet address",
                  "fullTitle": "Royalty Functions Royalty Payments should allow the royalty vault to transfer its native tokens to a wallet address",
                  "timedOut": false,
                  "duration": 4502,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const royaltyVaultAddress = await client.royalty.getRoyaltyVaultAddress(parentIpId);\nconst royaltyVaultToken = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, royaltyVaultAddress);\nconst transferAmount = BigInt(10 * 10 ** 6); // 10 million tokens\n// Check initial balances of the vault token\nconst initialTargetBalance = await royaltyVaultToken.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst initialParentBalance = await royaltyVaultToken.balanceOf(parentIpId);\n(0, chai_1.expect)(Number(initialParentBalance)).greaterThanOrEqual(Number(transferAmount));\nconst transferResult = await client.ipAccount.execute({\n    to: royaltyVaultAddress,\n    value: 0,\n    ipId: parentIpId,\n    data: (0, viem_1.encodeFunctionData)({\n        abi: viem_1.erc20Abi,\n        functionName: \"transfer\",\n        args: [util_1.TEST_WALLET_ADDRESS, transferAmount],\n    }),\n});\n(0, chai_1.expect)(transferResult.txHash).to.be.a(\"string\");\n// Check final balances to confirm the transfer worked\nconst finalTargetBalance = await royaltyVaultToken.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst finalParentBalance = await royaltyVaultToken.balanceOf(parentIpId);\n(0, chai_1.expect)(finalTargetBalance).to.equal(initialTargetBalance + transferAmount, \"Target wallet balance should increase by the transfer amount\");\n(0, chai_1.expect)(Number(finalParentBalance)).equal(Number(initialParentBalance - transferAmount));",
                  "err": {},
                  "uuid": "0fe8b8ef-86d5-4d4e-b2d2-d0e42570ad64",
                  "parentUUID": "6363b1e5-18d0-4b33-99bd-78b25ca8f127",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "c206bda9-f439-469b-bb9d-7d4e63e4ce1f",
                "c1bff49c-c62e-4b2f-850d-f5ea2349d816",
                "b510bd1b-01b6-46a7-aaf3-59bdb0aa50f1",
                "0fe8b8ef-86d5-4d4e-b2d2-d0e42570ad64"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 17685,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "41986046-1560-4b17-a8a8-c6a1a4d94762",
              "title": "Revenue Queries",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts",
              "file": "/test/integration/royalty.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should return claimable revenue amount",
                  "fullTitle": "Royalty Functions Revenue Queries should return claimable revenue amount",
                  "timedOut": false,
                  "duration": 98,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.royalty.claimableRevenue({\n    ipId: parentIpId,\n    claimer: util_1.TEST_WALLET_ADDRESS,\n    token: generated_1.erc20Address[util_1.aeneid],\n});\n(0, chai_1.expect)(response).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "f045e559-96c5-4088-8d38-8baf8979905a",
                  "parentUUID": "41986046-1560-4b17-a8a8-c6a1a4d94762",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail to get royalty vault address for unregistered IP",
                  "fullTitle": "Royalty Functions Revenue Queries should fail to get royalty vault address for unregistered IP",
                  "timedOut": false,
                  "duration": 34,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const unregisteredIpId = \"0x1234567890123456789012345678901234567890\";\nawait (0, chai_1.expect)(client.royalty.getRoyaltyVaultAddress(unregisteredIpId)).to.be.rejectedWith(`The royalty vault IP with id ${unregisteredIpId} is not registered.`);",
                  "err": {},
                  "uuid": "45ced30c-38ff-4eba-b489-a3850757db88",
                  "parentUUID": "41986046-1560-4b17-a8a8-c6a1a4d94762",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "f045e559-96c5-4088-8d38-8baf8979905a",
                "45ced30c-38ff-4eba-b489-a3850757db88"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 132,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "cd8a3c37-1e09-481c-a555-ef1c1f51654f",
              "title": "Error Cases",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts",
              "file": "/test/integration/royalty.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should return zero for claimable revenue with invalid token",
                  "fullTitle": "Royalty Functions Error Cases should return zero for claimable revenue with invalid token",
                  "timedOut": false,
                  "duration": 110,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.royalty.claimableRevenue({\n    ipId: parentIpId,\n    claimer: util_1.TEST_WALLET_ADDRESS,\n    token: \"0x0000000000000000000000000000000000000000\",\n});\n(0, chai_1.expect)(response).to.equal(0n);",
                  "err": {},
                  "uuid": "584a8481-dc42-47c6-8092-161c4216b8c2",
                  "parentUUID": "cd8a3c37-1e09-481c-a555-ef1c1f51654f",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "584a8481-dc42-47c6-8092-161c4216b8c2"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 110,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "06467244-816c-4086-9d30-a5694e699726",
              "title": "ClaimAllRevenue With WIP",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts",
              "file": "/test/integration/royalty.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"ClaimAllRevenue With WIP\"",
                  "fullTitle": "Royalty Functions ClaimAllRevenue With WIP \"before all\" hook in \"ClaimAllRevenue With WIP\"",
                  "timedOut": false,
                  "duration": 27826,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// set up\n// minting Fee: 100, 10% LAP rev share, A expect to get 120 WIP\n// A -> B -> C -> D\nconst txData = await client.nftClient.createNFTCollection({\n    name: \"free-collection\",\n    symbol: \"FREE\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: viem_1.zeroAddress,\n});\nspgNftContract = txData.spgNftContract;\nconst retA = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 100n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 100n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nipA = retA.ipId;\nlicenseId = retA.licenseTermsIds[0];\nconst retB = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipA],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\nipB = retB.ipId;\nconst retC = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipB],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\nipC = retC.ipId;\nawait client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipC],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});",
                  "err": {},
                  "uuid": "90477c04-3548-44a2-9f33-9bab5c11028c",
                  "parentUUID": "06467244-816c-4086-9d30-a5694e699726",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should claim all revenue",
                  "fullTitle": "Royalty Functions ClaimAllRevenue With WIP should claim all revenue",
                  "timedOut": false,
                  "duration": 13116,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const ret = await client.royalty.claimAllRevenue({\n    ancestorIpId: ipA,\n    claimer: ipA,\n    childIpIds: [ipB, ipC],\n    royaltyPolicies: [generated_1.royaltyPolicyLapAddress[util_1.aeneid], generated_1.royaltyPolicyLapAddress[util_1.aeneid]],\n    currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n});\n(0, chai_1.expect)(ret.txHashes).to.be.an(\"array\");\n(0, chai_1.expect)(ret.claimedTokens[0].amount).to.equal(120n);",
                  "err": {},
                  "uuid": "d85bd175-785c-4ea7-b5bf-31f3bd0ce6ed",
                  "parentUUID": "06467244-816c-4086-9d30-a5694e699726",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "d85bd175-785c-4ea7-b5bf-31f3bd0ce6ed"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 13116,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "70e5e6f0-ce58-4477-812f-0dfecec5318b",
              "title": "BatchClaimAllRevenue With WIP",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts",
              "file": "/test/integration/royalty.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"BatchClaimAllRevenue With WIP\"",
                  "fullTitle": "Royalty Functions BatchClaimAllRevenue With WIP \"before all\" hook in \"BatchClaimAllRevenue With WIP\"",
                  "timedOut": false,
                  "duration": 53939,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nanotherAddress = derivedClient.address;\nawait client.wipClient.deposit({\n    amount: (0, viem_1.parseEther)(\"5\"),\n});\n/**\n * Asset Hierarchy Setup for Revenue Collection Tests\n *\n * Overview:\n * This test setup creates two distinct IP asset hierarchies (IpA and IpB) to demonstrate\n * different revenue collection scenarios using LAP (Licensing Agreement Policy) and LRP\n * (Licensing Revenue Policy) respectively.\n *\n * IpA Hierarchy (LAP - Licensing Agreement Policy):                           IpB Hierarchy (LRP - Licensing Revenue Policy):\n *           \n *  IpA (Parent) - Total Expected Revenue: 130 WIP                         IpB (Parent) - Total Expected Revenue: 330 WIP              \n *           \n *  Revenue Sources:                                                       Revenue Sources:                                            \n *   Minting Fee: 100 WIP                                                Minting Fee: 150 WIP                                    \n *   Revenue Share (ipA2->ipA1): 10 WIP (10% LAP)                        LRP Revenue Share: 10%                                  \n *   Revenue Share (ipA3->ipA2): 10 WIP (10% LAP)                        Total Revenue: 330 WIP                                  \n *   Direct Payment (ipA3): 10 WIP (10% LAP)                                From ipB1: 150 WIP + 10% revenue share               \n *                                                                             From ipB2: 150 WIP + 10% revenue share               \n *                                                                                                                                     \n * | Ownership Distribution:                                               |                                                             \n *   Wallet Address: 50%  65 WIP                                        Revenue Flow:                                               \n *   Another Address: 50% 65 WIP                                        ipB3                                                        \n *                                                                          ipB1                                                  \n *  Revenue Flow:                                                           ipB2 > ipB (collects 330 WIP)                       \n *  ipA3                                                                                                                               \n *   > ipA2 (20% LAP) > ipA1 (10% LAP) > ipA                                                                                    \n *        > Direct Payment: 100 WIP                                                                                                 \n *           \n */\nconst txData = await client.nftClient.createNFTCollection({\n    name: \"free-collection\",\n    symbol: \"FREE\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: viem_1.zeroAddress,\n});\nspgNftContract = txData.spgNftContract;\n// 1. Register ipA\nconst ret1A = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 100n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 100n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 50,\n        },\n        {\n            recipient: anotherAddress,\n            percentage: 50,\n        },\n    ],\n});\nipA = ret1A.ipId;\nlicenseId = ret1A.licenseTermsIds[0];\n// 2. Register ipB\nconst ret1B = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n                defaultMintingFee: 150n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 150n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nipB = ret1B.ipId;\nlicenseId1 = ret1B.licenseTermsIds[0];\n// 3. Register ipA1 from ipA and ipB1 from ipB\nconst { results: ret2 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB],\n                licenseTermsIds: [licenseId1],\n            },\n        },\n    ],\n});\nipA1 = ret2[0].ipId;\nipB1 = ret2[1].ipId;\n// 4. Register ipA2 from ipA1 and ipB2 from ipB\nconst { results: ret3 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA1],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB],\n                licenseTermsIds: [licenseId1],\n            },\n        },\n    ],\n});\nipA2 = ret3[0].ipId;\nipB2 = ret3[1].ipId;\n// 5. Register ipA3 from ipA2 and ipB3 from ipB1 and ipB2\nconst { results: ret4 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA2],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB1, ipB2],\n                licenseTermsIds: [licenseId1, licenseId1],\n            },\n        },\n    ],\n});\nipA3 = ret4[0].ipId;\n// 6. Pay royalty on behalf of ipA2 to ipA3\nawait client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: ipA2,\n    payerIpId: ipA3,\n    token: common_1.WIP_TOKEN_ADDRESS,\n    amount: 100n,\n});\nconst balance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nawait client.wipClient.withdraw({\n    amount: balance,\n});",
                  "err": {},
                  "uuid": "5859f472-5c72-471d-ab3c-74db88580eb3",
                  "parentUUID": "70e5e6f0-ce58-4477-812f-0dfecec5318b",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should batch claim all revenue",
                  "fullTitle": "Royalty Functions BatchClaimAllRevenue With WIP should batch claim all revenue",
                  "timedOut": false,
                  "duration": 13237,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const anotherAddressWipBalanceBefore = await client.wipClient.balanceOf(anotherAddress);\nconst result = await client.royalty.batchClaimAllRevenue({\n    ancestorIps: [\n        {\n            ipId: ipA,\n            claimer: util_1.TEST_WALLET_ADDRESS,\n            childIpIds: [ipA1, ipA2],\n            royaltyPolicies: [generated_1.royaltyPolicyLapAddress[util_1.aeneid], generated_1.royaltyPolicyLapAddress[util_1.aeneid]],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n        },\n        {\n            ipId: ipA,\n            claimer: anotherAddress,\n            childIpIds: [],\n            royaltyPolicies: [],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS],\n        },\n        {\n            ipId: ipB,\n            claimer: ipB,\n            childIpIds: [ipB1, ipB2],\n            royaltyPolicies: [generated_1.royaltyPolicyLrpAddress[util_1.aeneid], generated_1.royaltyPolicyLrpAddress[util_1.aeneid]],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n        },\n    ],\n});\nconst anotherAddressWipBalanceAfter = await client.wipClient.balanceOf(anotherAddress);\nconst walletWipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(result.txHashes).to.be.an(\"array\");\n(0, chai_1.expect)(result.claimedTokens[0].amount).to.equal(65n);\n(0, chai_1.expect)(result.claimedTokens[1].amount).to.equal(65n);\n(0, chai_1.expect)(result.claimedTokens[2].amount).to.equal(330n);\n(0, chai_1.expect)(walletWipBalanceAfter).to.equal(0n);\n(0, chai_1.expect)(anotherAddressWipBalanceAfter).to.equal(anotherAddressWipBalanceBefore + 65n);\n// Note: The final wallet balance cannot be precisely calculated because:\n// The test involves multiple transactions (claimAllRevenue, token transfers, etc.)\n// batchClaimAllRevenue only returns receipts for claimAllRevenue calls\n// Additional gas costs and token transfers occur outside the returned receipts",
                  "err": {},
                  "uuid": "a06783e5-6957-443d-b79d-f3a39f1cba75",
                  "parentUUID": "70e5e6f0-ce58-4477-812f-0dfecec5318b",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "a06783e5-6957-443d-b79d-f3a39f1cba75"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 13237,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "13d0e164-895f-4902-9eca-a76b4d1fb6d0",
          "title": "WIP Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts",
          "file": "/test/integration/wip.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"WIP Functions\"",
              "fullTitle": "WIP Functions \"before all\" hook in \"WIP Functions\"",
              "timedOut": false,
              "duration": 3,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();",
              "err": {},
              "uuid": "4d41e782-b44e-4fd3-b36b-f00bace966f5",
              "parentUUID": "13d0e164-895f-4902-9eca-a76b4d1fb6d0",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "c85025ca-36bd-47d8-a654-bb528a088952",
              "title": "deposit",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts",
              "file": "/test/integration/wip.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should deposit 0.01 WIP",
                  "fullTitle": "WIP Functions deposit should deposit 0.01 WIP",
                  "timedOut": false,
                  "duration": 4460,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const ipAmt = (0, viem_1.parseEther)(\"0.01\");\nconst balanceBefore = await client.getWalletBalance();\nconst wipBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst rsp = await client.wipClient.deposit({\n    amount: ipAmt,\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\"string\");\nconst balanceAfter = await client.getWalletBalance();\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.equal(wipBefore + ipAmt);\nconst gasCost = rsp.receipt.gasUsed * rsp.receipt.effectiveGasPrice;\n(0, chai_1.expect)(balanceAfter).to.equal(balanceBefore - ipAmt - gasCost);",
                  "err": {},
                  "uuid": "6a50f000-7ffd-470d-a70c-d8be89bb1e5a",
                  "parentUUID": "c85025ca-36bd-47d8-a654-bb528a088952",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "6a50f000-7ffd-470d-a70c-d8be89bb1e5a"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 4460,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "aba504a0-385b-4db9-8c3d-fd259c025d9b",
              "title": "transfer",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts",
              "file": "/test/integration/wip.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should transfer WIP",
                  "fullTitle": "WIP Functions transfer should transfer WIP",
                  "timedOut": false,
                  "duration": 4342,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const rsp = await client.wipClient.transfer({\n    to: util_1.TEST_WALLET_ADDRESS,\n    amount: (0, viem_1.parseEther)(\"0.01\"),\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\"string\");\n//Due to approve cannot approve msy.sender, so skip transferFrom test",
                  "err": {},
                  "uuid": "e9140d4d-d37f-4415-a560-8b7688f5c0fe",
                  "parentUUID": "aba504a0-385b-4db9-8c3d-fd259c025d9b",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "e9140d4d-d37f-4415-a560-8b7688f5c0fe"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 4342,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "24361fea-a64b-4e23-b392-6773380a9885",
              "title": "withdraw",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts",
              "file": "/test/integration/wip.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should withdrawal WIP",
                  "fullTitle": "WIP Functions withdraw should withdrawal WIP",
                  "timedOut": false,
                  "duration": 4508,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const balanceBefore = await client.getWalletBalance();\nconst wipBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst rsp = await client.wipClient.withdraw({\n    amount: wipBefore,\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\"string\");\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.equal(0n);\nconst balanceAfter = await client.getWalletBalance();\nconst gasCost = rsp.receipt.gasUsed * rsp.receipt.effectiveGasPrice;\n(0, chai_1.expect)(balanceAfter).to.equal(balanceBefore + wipBefore - gasCost);",
                  "err": {},
                  "uuid": "bccc80fd-a11d-4f27-ad36-c91b964580cb",
                  "parentUUID": "24361fea-a64b-4e23-b392-6773380a9885",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "bccc80fd-a11d-4f27-ad36-c91b964580cb"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 4508,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 300000
    }
  ],
  "meta": {
    "mocha": {
      "version": "10.8.2"
    },
    "mochawesome": {
      "options": {
        "quiet": false,
        "reportFilename": "mochawesome",
        "saveHtml": true,
        "saveJson": true,
        "consoleReporter": "spec",
        "useInlineDiffs": false,
        "code": true
      },
      "version": "7.1.4"
    },
    "marge": {
      "options": null,
      "version": "6.3.2"
    }
  }
}