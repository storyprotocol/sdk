{
  "stats": {
    "suites": 48,
    "tests": 138,
    "passes": 138,
    "pending": 0,
    "failures": 0,
    "start": "2025-08-07T23:42:54.999Z",
    "end": "2025-08-08T00:15:06.210Z",
    "duration": 1931211,
    "testsRegistered": 138,
    "passPercent": 100,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false
  },
  "results": [
    {
      "uuid": "b4fe2e15-cb96-43f6-8d44-ff53ee6b0a44",
      "title": "",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "7c982653-9b97-4f39-a91c-067be9a9482e",
          "title": "Dispute Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts",
          "file": "/test/integration/dispute.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Dispute Functions\"",
              "fullTitle": "Dispute Functions \"before all\" hook in \"Dispute Functions\"",
              "timedOut": false,
              "duration": 9044,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "clientA = (0, util_1.getStoryClient)();\nconst derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nclientB = derivedClient.clientB;\nminimumBond = await (0, oov3_1.getMinimumBond)(util_1.publicClient, new generated_1.ArbitrationPolicyUmaClient(util_1.publicClient, util_1.walletClient), src_1.WIP_TOKEN_ADDRESS);\nconst txData = await clientA.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nconst nftContract = txData.spgNftContract;\nipIdB = (await clientB.ipAsset.mintAndRegisterIp({\n    spgNftContract: nftContract,\n})).ipId;",
              "err": {},
              "uuid": "cf38b11e-50ea-4295-88b8-b3fd7a368c64",
              "parentUUID": "7c982653-9b97-4f39-a91c-067be9a9482e",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [
            {
              "title": "it should not cancel a dispute (yet)",
              "fullTitle": "Dispute Functions it should not cancel a dispute (yet)",
              "timedOut": false,
              "duration": 13207,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const raiseResponse = await clientA.dispute.raiseDispute({\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 2592000,\n    bond: minimumBond,\n});\nawait (0, chai_1.expect)(clientA.dispute.cancelDispute({\n    disputeId: raiseResponse.disputeId,\n})).to.be.rejected;",
              "err": {},
              "uuid": "4d9f5ff5-c3cb-49e7-9b67-5be022b1d662",
              "parentUUID": "7c982653-9b97-4f39-a91c-067be9a9482e",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [
            {
              "uuid": "6af18dc1-1596-40f9-b433-223e8381e20c",
              "title": "raiseDispute and counter dispute",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts",
              "file": "/test/integration/dispute.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should raise a dispute",
                  "fullTitle": "Dispute Functions raiseDispute and counter dispute should raise a dispute",
                  "timedOut": false,
                  "duration": 9039,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const raiseDisputeRequest = {\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 2592000,\n    bond: minimumBond,\n};\nconst response = await clientA.dispute.raiseDispute(raiseDisputeRequest);\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(response.disputeId).to.be.a(\"bigint\");\ndisputeId = response.disputeId;",
                  "err": {},
                  "uuid": "5c30116f-5ac1-4cfd-ab30-c44465d80211",
                  "parentUUID": "6af18dc1-1596-40f9-b433-223e8381e20c",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should validate all enum values defined in DisputeTargetTag",
                  "fullTitle": "Dispute Functions raiseDispute and counter dispute should validate all enum values defined in DisputeTargetTag",
                  "timedOut": false,
                  "duration": 161,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const allTags = Object.values(src_1.DisputeTargetTag);\nfor (const tag of allTags) {\n    const tagHex = (0, viem_1.toHex)(tag, { size: 32 });\n    const { allowed } = await clientA.dispute.disputeModuleClient.isWhitelistedDisputeTag({\n        tag: tagHex,\n    });\n    if (tag === src_1.DisputeTargetTag.IN_DISPUTE) {\n        (0, chai_1.expect)(allowed).equal(false);\n    }\n    else {\n        (0, chai_1.expect)(allowed).equal(true);\n    }\n}",
                  "err": {},
                  "uuid": "d1109cab-0572-4966-84a8-e21fe90ad70b",
                  "parentUUID": "6af18dc1-1596-40f9-b433-223e8381e20c",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should raise disputes with different DisputeTargetTag enum values",
                  "fullTitle": "Dispute Functions raiseDispute and counter dispute should raise disputes with different DisputeTargetTag enum values",
                  "timedOut": false,
                  "duration": 36381,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const allTags = Object.values(src_1.DisputeTargetTag);\nfor (const tag of allTags) {\n    const raiseDisputeRequest = {\n        targetIpId: ipIdB,\n        cid: await generateCID(),\n        targetTag: tag,\n        liveness: 2592000,\n        bond: minimumBond,\n    };\n    if (tag === src_1.DisputeTargetTag.IN_DISPUTE) {\n        await (0, chai_1.expect)(clientA.dispute.raiseDispute(raiseDisputeRequest)).to.be.rejectedWith(\"The target tag IN_DISPUTE is not whitelisted\");\n    }\n    else {\n        const response = await clientA.dispute.raiseDispute(raiseDisputeRequest);\n        (0, chai_1.expect)(response.txHash).to.be.a(\"string\");\n        (0, chai_1.expect)(response.disputeId).to.be.a(\"bigint\");\n    }\n}",
                  "err": {},
                  "uuid": "286908fc-863f-422c-92a6-c3b7983f2f52",
                  "parentUUID": "6af18dc1-1596-40f9-b433-223e8381e20c",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should reject a dispute with an invalid tag not defined in the enum",
                  "fullTitle": "Dispute Functions raiseDispute and counter dispute should reject a dispute with an invalid tag not defined in the enum",
                  "timedOut": false,
                  "duration": 141,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(clientA.dispute.raiseDispute({\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: \"INVALID_TAG\",\n    liveness: 2592000,\n    bond: minimumBond,\n})).to.be.rejectedWith(\"The target tag INVALID_TAG is not whitelisted\");",
                  "err": {},
                  "uuid": "ebbb7132-4a09-4109-b9a2-d1a6732b9608",
                  "parentUUID": "6af18dc1-1596-40f9-b433-223e8381e20c",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to counter existing dispute once",
                  "fullTitle": "Dispute Functions raiseDispute and counter dispute should be able to counter existing dispute once",
                  "timedOut": false,
                  "duration": 13508,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const assertionId = await clientB.dispute.disputeIdToAssertionId(disputeId);\nconst counterEvidenceCID = await generateCID();\nconst ret = await clientB.dispute.disputeAssertion({\n    ipId: ipIdB,\n    assertionId,\n    counterEvidenceCID,\n});\n(0, chai_1.expect)(ret.txHash).to.be.a(\"string\");\n// should throw error if attempting to dispute assertion again\nawait (0, chai_1.expect)(clientB.dispute.disputeAssertion({\n    ipId: ipIdB,\n    assertionId,\n    counterEvidenceCID,\n})).to.be.rejected;",
                  "err": {},
                  "uuid": "2f1887f6-263d-4226-8efc-d6730dae9838",
                  "parentUUID": "6af18dc1-1596-40f9-b433-223e8381e20c",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "5c30116f-5ac1-4cfd-ab30-c44465d80211",
                "d1109cab-0572-4966-84a8-e21fe90ad70b",
                "286908fc-863f-422c-92a6-c3b7983f2f52",
                "ebbb7132-4a09-4109-b9a2-d1a6732b9608",
                "2f1887f6-263d-4226-8efc-d6730dae9838"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 59230,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "a2def5d1-c702-4125-aaf5-99d77c35ce3b",
              "title": "Dispute resolution",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts",
              "file": "/test/integration/dispute.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"Dispute resolution\"",
                  "fullTitle": "Dispute Functions Dispute resolution \"before each\" hook in \"Dispute resolution\"",
                  "timedOut": false,
                  "duration": 34627,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Setup NFT collection\nconst txData = await clientA.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\n// Get parent IP ID and license terms ID\nconst ipIdAndLicenseResponse = await clientA.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContract,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: src_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: generated_1.evenSplitGroupPoolAddress[util_1.aeneid],\n            },\n        },\n    ],\n});\nparentIpId = ipIdAndLicenseResponse.ipId;\nlicenseTermsId = ipIdAndLicenseResponse.licenseTermsIds[0];\n//Create a derivative ip\nconst derivativeIpIdResponse1 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\nchildIpId = derivativeIpIdResponse1.ipId;\n// Create a second derivative ip\nconst derivativeIpIdResponse2 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\nchildIpId2 = derivativeIpIdResponse2.ipId;\n// Raise a dispute\nconst response = await clientA.dispute.raiseDispute({\n    targetIpId: parentIpId,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 1,\n    bond: minimumBond,\n});\ndisputeId = response.disputeId;\n// This timeout guarantees that the assertion is expired\n// its intended to be longer than the current block time\n// so it won't be included in the same block\nawait new Promise((resolve) => setTimeout(resolve, 3000));",
                  "err": {},
                  "uuid": "f2792439-fe75-4ba2-87c3-f6da3f13b28b",
                  "parentUUID": "a2def5d1-c702-4125-aaf5-99d77c35ce3b",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should tag infringing ip",
                  "fullTitle": "Dispute Functions Dispute resolution should tag infringing ip",
                  "timedOut": false,
                  "duration": 12795,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Tag derivative IP as infringing\nconst results = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: childIpId2,\n            disputeId: disputeId,\n        },\n    ],\n});\n(0, chai_1.expect)(results[0].txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "ce707bf1-a5b3-484d-bb20-0ed1f1759827",
                  "parentUUID": "a2def5d1-c702-4125-aaf5-99d77c35ce3b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should tag a single IP as infringing without using multicall",
                  "fullTitle": "Dispute Functions Dispute resolution should tag a single IP as infringing without using multicall",
                  "timedOut": false,
                  "duration": 12821,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "/**\n * Test Flow:\n * 1. Set judgment on an existing dispute to mark it as valid (did in `before each` block)\n * 2. Verify the dispute state changed correctly after judgment\n * 3. Try to tag a derivative IP using the judged dispute\n */\n// Step 1: Set judgment on an existing dispute to mark it as valid\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Step 2: Verify dispute state\n// The disputes() function returns multiple values about the dispute:\n// - targetTag: the tag we wanted to apply when raising the dispute\n// - currentTag: the current state of the dispute after judgment\n// After a successful judgment, currentTag should equal targetTag\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag); // Verify judgment was recorded correctly\n// Step 3: Attempt to tag a derivative IP\n// This will fail if:\n// - The dispute is not in a valid state (still IN_DISPUTE or cleared)\n// - The IP we're trying to tag is not actually a derivative of the disputed IP\n// - The dispute has already been used to tag this IP\nconst response = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId, // The derivative IP to tag\n            disputeId: disputeId, // Using the judged dispute as basis for tagging\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: false, // Force single transaction instead of batch\n    },\n});\n// Verify we got the expected response\n(0, chai_1.expect)(response).to.have.lengthOf(1);\n(0, chai_1.expect)(response[0].txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "3569f528-16d4-4d1d-ac6e-f472424f8244",
                  "parentUUID": "a2def5d1-c702-4125-aaf5-99d77c35ce3b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should tag multiple IPs as infringing using multicall",
                  "fullTitle": "Dispute Functions Dispute resolution should tag multiple IPs as infringing using multicall",
                  "timedOut": false,
                  "duration": 25645,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const disputeResponse = await clientA.dispute.raiseDispute({\n    targetIpId: parentIpId,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 1,\n    bond: minimumBond,\n});\nconst testDisputeId = disputeResponse.disputeId;\nconst derivativeResponse2 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nconst newChildIpId = derivativeResponse2.ipId;\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, testDisputeId);\n// This timeout guarantees that the assertion is expired\n// its intended to be longer than the current block time\n// so it won't be included in the same block\nawait new Promise((resolve) => setTimeout(resolve, 3000));\nconst { currentTag, targetTag } = await getDisputeState(testDisputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst response = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: testDisputeId,\n        },\n        {\n            ipId: newChildIpId,\n            disputeId: testDisputeId,\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: true,\n    },\n});\n(0, chai_1.expect)(response).to.have.lengthOf(1);\n(0, chai_1.expect)(response[0].txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "8cd32ac9-b7f8-4a58-ae8c-125eec489620",
                  "parentUUID": "a2def5d1-c702-4125-aaf5-99d77c35ce3b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should tag multiple IPs without multicall when specified",
                  "fullTitle": "Dispute Functions Dispute resolution should tag multiple IPs without multicall when specified",
                  "timedOut": false,
                  "duration": 18453,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Create two new derivative IPs sequentially\nconst derivativeResponse3 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nconst derivativeResponse4 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst responses = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: derivativeResponse3.ipId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: derivativeResponse4.ipId,\n            disputeId: disputeId,\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: false,\n    },\n});\n(0, chai_1.expect)(responses).to.have.lengthOf(2);\n(0, chai_1.expect)(responses[0].txHash).to.be.a(\"string\");\n(0, chai_1.expect)(responses[1].txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "62f4d16d-1d36-42df-8365-dafe59f517eb",
                  "parentUUID": "a2def5d1-c702-4125-aaf5-99d77c35ce3b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail when trying to tag with invalid dispute ID",
                  "fullTitle": "Dispute Functions Dispute resolution should fail when trying to tag with invalid dispute ID",
                  "timedOut": false,
                  "duration": 36,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: 999999n,\n        },\n    ],\n})).to.be.rejected;",
                  "err": {},
                  "uuid": "5495704f-f29a-4678-87be-1c79a2aad4f8",
                  "parentUUID": "a2def5d1-c702-4125-aaf5-99d77c35ce3b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should resolve a dispute successfully when initiated by dispute initiator",
                  "fullTitle": "Dispute Functions Dispute resolution should resolve a dispute successfully when initiated by dispute initiator",
                  "timedOut": false,
                  "duration": 12831,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst response = await clientA.dispute.resolveDispute({\n    disputeId: disputeId,\n    data: \"0x\",\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "f942f387-ec24-48e9-bcac-81fa2919c335",
                  "parentUUID": "a2def5d1-c702-4125-aaf5-99d77c35ce3b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail when non-initiator tries to resolve the dispute",
                  "fullTitle": "Dispute Functions Dispute resolution should fail when non-initiator tries to resolve the dispute",
                  "timedOut": false,
                  "duration": 33,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(clientB.dispute.resolveDispute({\n    disputeId: disputeId,\n    data: \"0x\",\n})).to.be.rejectedWith(\"NotDisputeInitiator\");",
                  "err": {},
                  "uuid": "09059d5f-a00b-4eaf-837a-bf586c2cf109",
                  "parentUUID": "a2def5d1-c702-4125-aaf5-99d77c35ce3b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should propagate IMPROPER_REGISTRATION tag to derivative IPs",
                  "fullTitle": "Dispute Functions Dispute resolution should propagate IMPROPER_REGISTRATION tag to derivative IPs",
                  "timedOut": false,
                  "duration": 12862,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Verify the dispute state changed correctly\nconst { currentTag: parentCurrentTag, targetTag: parentTargetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(parentCurrentTag).to.equal(parentTargetTag);\n// Propagate the tag to both derivative IPs\nconst results = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: childIpId2,\n            disputeId: disputeId,\n        },\n    ],\n});\nconst logData = results[0].receipt?.logs[0].data;\nconst firstWord = logData.slice(0, 66);\nconst childDisputeId = BigInt(firstWord);\n// Verify successful tagging\n(0, chai_1.expect)(results[0].txHash).to.be.a(\"string\");\nconst { currentTag: childCurrentTag } = await getDisputeState(childDisputeId);\n// Convert the IMPROPER_USAGE tag to hex for comparison\nconst improperUsageTagHex = (0, viem_1.toHex)(src_1.DisputeTargetTag.IMPROPER_REGISTRATION, { size: 32 });\n// Verify both child IPs have the IMPROPER_USAGE tag by\n// fetching and comparing their dispute tags\n(0, chai_1.expect)(parentCurrentTag).to.equal(parentTargetTag);\n(0, chai_1.expect)(childCurrentTag).to.equal(improperUsageTagHex);",
                  "err": {},
                  "uuid": "420247a5-0008-4419-b65a-a4f333a9d5c8",
                  "parentUUID": "a2def5d1-c702-4125-aaf5-99d77c35ce3b",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "ce707bf1-a5b3-484d-bb20-0ed1f1759827",
                "3569f528-16d4-4d1d-ac6e-f472424f8244",
                "8cd32ac9-b7f8-4a58-ae8c-125eec489620",
                "62f4d16d-1d36-42df-8365-dafe59f517eb",
                "5495704f-f29a-4678-87be-1c79a2aad4f8",
                "f942f387-ec24-48e9-bcac-81fa2919c335",
                "09059d5f-a00b-4eaf-837a-bf586c2cf109",
                "420247a5-0008-4419-b65a-a4f333a9d5c8"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 95476,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [
            "4d9f5ff5-c3cb-49e7-9b67-5be022b1d662"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 13207,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "7a57d486-da94-491b-80b8-036c80f9a19f",
          "title": "Group Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts",
          "file": "/test/integration/group.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Group Functions\"",
              "fullTitle": "Group Functions \"before all\" hook in \"Group Functions\"",
              "timedOut": false,
              "duration": 4359,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();\n// Create NFT Collection\nspgNftContract = (await client.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \"test-uri\",\n})).spgNftContract;",
              "err": {},
              "uuid": "03d37933-32f1-49f2-a5ad-c17c374729c1",
              "parentUUID": "7a57d486-da94-491b-80b8-036c80f9a19f",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "0319e9af-4d1b-4b3a-a210-5418222901d3",
              "title": "Group Operations",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts",
              "file": "/test/integration/group.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Group Operations\"",
                  "fullTitle": "Group Functions Group Operations \"before all\" hook in \"Group Operations\"",
                  "timedOut": false,
                  "duration": 13177,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Create initial IP with license terms\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    allowDuplicates: false,\n    licenseTermsData,\n});\nlicenseTermsId = result.licenseTermsIds[0];\nipId = result.ipId;\n// Set licensing config\nawait client.license.setLicensingConfig({\n    ipId,\n    licenseTermsId,\n    licenseTemplate: generated_1.piLicenseTemplateAddress[util_1.aeneid],\n    licensingConfig: {\n        isSet: true,\n        mintingFee: 0n,\n        licensingHook: viem_1.zeroAddress,\n        hookData: viem_1.zeroAddress,\n        commercialRevShare: 0,\n        disabled: false,\n        expectMinimumGroupRewardShare: 0,\n        expectGroupRewardPool: groupPoolAddress,\n    },\n});",
                  "err": {},
                  "uuid": "d4cb72df-c20c-481f-a0e1-1e6c08f5db2e",
                  "parentUUID": "0319e9af-4d1b-4b3a-a210-5418222901d3",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully register group and attach license",
                  "fullTitle": "Group Functions Group Operations should successfully register group and attach license",
                  "timedOut": false,
                  "duration": 4360,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.groupClient.registerGroupAndAttachLicense({\n    groupPool: groupPoolAddress,\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n});\ngroupId = result.groupId;\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.groupId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "ca689b4d-f8b0-4da6-83df-1cf0edf44de2",
                  "parentUUID": "0319e9af-4d1b-4b3a-a210-5418222901d3",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully mint, register IP, attach license and add to group",
                  "fullTitle": "Group Functions Group Operations should successfully mint, register IP, attach license and add to group",
                  "timedOut": false,
                  "duration": 8597,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.groupClient.mintAndRegisterIpAndAttachLicenseAndAddToGroup({\n    groupId,\n    spgNftContract,\n    licenseData: [\n        {\n            licenseTermsId,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: groupPoolAddress,\n            },\n        },\n    ],\n    maxAllowedRewardShare: 5,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "433c4026-ca43-4816-9846-a4ef2d820532",
                  "parentUUID": "0319e9af-4d1b-4b3a-a210-5418222901d3",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully register a basic group",
                  "fullTitle": "Group Functions Group Operations should successfully register a basic group",
                  "timedOut": false,
                  "duration": 4356,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.groupClient.registerGroup({\n    groupPool: groupPoolAddress,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.groupId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "3deae901-3a1b-45ff-8b69-7978831264b0",
                  "parentUUID": "0319e9af-4d1b-4b3a-a210-5418222901d3",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully register existing IP with license and add to group",
                  "fullTitle": "Group Functions Group Operations should successfully register existing IP with license and add to group",
                  "timedOut": false,
                  "duration": 13005,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(spgNftContract, \"test-metadata\");\nconst result = await client.groupClient.registerIpAndAttachLicenseAndAddToGroup({\n    groupId,\n    nftContract: spgNftContract,\n    tokenId,\n    maxAllowedRewardShare: 5,\n    licenseData: [\n        {\n            licenseTermsId,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: groupPoolAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "51eec78a-3249-43fa-94d6-2c87050625ed",
                  "parentUUID": "0319e9af-4d1b-4b3a-a210-5418222901d3",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully register group with license and add multiple IPs",
                  "fullTitle": "Group Functions Group Operations should successfully register group with license and add multiple IPs",
                  "timedOut": false,
                  "duration": 4444,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.groupClient.registerGroupAndAttachLicenseAndAddIps({\n    groupPool: groupPoolAddress,\n    maxAllowedRewardShare: 5,\n    ipIds: [ipId],\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.groupId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "5cc6f33b-b64a-44e8-8b1d-2b6e14055597",
                  "parentUUID": "0319e9af-4d1b-4b3a-a210-5418222901d3",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail when trying to add unregistered IP to group",
                  "fullTitle": "Group Functions Group Operations should fail when trying to add unregistered IP to group",
                  "timedOut": false,
                  "duration": 57,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.groupClient.registerGroupAndAttachLicenseAndAddIps({\n    groupPool: groupPoolAddress,\n    maxAllowedRewardShare: 5,\n    ipIds: [viem_1.zeroAddress], // Invalid IP address\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n})).to.be.rejectedWith(\"Failed to register group and attach license and add ips\");",
                  "err": {},
                  "uuid": "adc8b0aa-4cee-456d-bf6f-829ba79d5ff7",
                  "parentUUID": "0319e9af-4d1b-4b3a-a210-5418222901d3",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [
                {
                  "uuid": "98645589-cdd5-4bad-aed0-a832b764edeb",
                  "title": "Add IPs to Group and Remove IPs from Group",
                  "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts",
                  "file": "/test/integration/group.test.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should successfully add multiple IPs to group",
                      "fullTitle": "Group Functions Group Operations Add IPs to Group and Remove IPs from Group should successfully add multiple IPs to group",
                      "timedOut": false,
                      "duration": 13665,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const registerResult = await client.ipAsset.batchMintAndRegisterIpAssetWithPilTerms({\n    args: [\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n    ],\n});\nipIds = registerResult.results?.map((result) => result.ipId) ?? [];\nconst result = await client.groupClient.addIpsToGroup({\n    groupIpId: groupId,\n    ipIds: ipIds,\n    maxAllowedRewardSharePercentage: 5,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                      "err": {},
                      "uuid": "0b88be16-c090-423b-bb5d-56da26e6fd38",
                      "parentUUID": "98645589-cdd5-4bad-aed0-a832b764edeb",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should successfully remove IPs from group",
                      "fullTitle": "Group Functions Group Operations Add IPs to Group and Remove IPs from Group should successfully remove IPs from group",
                      "timedOut": false,
                      "duration": 4412,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.groupClient.removeIpsFromGroup({\n    groupIpId: groupId,\n    ipIds: ipIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                      "err": {},
                      "uuid": "35a99ef9-6bed-4765-80b8-8f917e2a54cc",
                      "parentUUID": "98645589-cdd5-4bad-aed0-a832b764edeb",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should fail when trying to remove IPs from a non-existent group",
                      "fullTitle": "Group Functions Group Operations Add IPs to Group and Remove IPs from Group should fail when trying to remove IPs from a non-existent group",
                      "timedOut": false,
                      "duration": 4730,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const registerResult = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData,\n});\nconst testIpId = registerResult.ipId;\nconst nonExistentGroupId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.removeIpsFromGroup({\n    groupIpId: nonExistentGroupId,\n    ipIds: [testIpId],\n})).to.be.rejectedWith(\"Failed to remove IPs from group\");",
                      "err": {},
                      "uuid": "38315cac-e0c4-426a-bfdc-c652881ad292",
                      "parentUUID": "98645589-cdd5-4bad-aed0-a832b764edeb",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should fail when trying to remove non-existent IPs from a group",
                      "fullTitle": "Group Functions Group Operations Add IPs to Group and Remove IPs from Group should fail when trying to remove non-existent IPs from a group",
                      "timedOut": false,
                      "duration": 4441,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const groupResult = await client.groupClient.registerGroup({\n    groupPool: groupPoolAddress,\n});\nconst testGroupId = groupResult.groupId;\nconst nonExistentIpId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.removeIpsFromGroup({\n    groupIpId: testGroupId,\n    ipIds: [nonExistentIpId],\n})).to.be.rejectedWith(\"Failed to remove IPs from group\");",
                      "err": {},
                      "uuid": "58f3eb33-4490-4f03-9ff4-6c3c56c266ed",
                      "parentUUID": "98645589-cdd5-4bad-aed0-a832b764edeb",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "0b88be16-c090-423b-bb5d-56da26e6fd38",
                    "35a99ef9-6bed-4765-80b8-8f917e2a54cc",
                    "38315cac-e0c4-426a-bfdc-c652881ad292",
                    "58f3eb33-4490-4f03-9ff4-6c3c56c266ed"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 27248,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 300000
                }
              ],
              "passes": [
                "ca689b4d-f8b0-4da6-83df-1cf0edf44de2",
                "433c4026-ca43-4816-9846-a4ef2d820532",
                "3deae901-3a1b-45ff-8b69-7978831264b0",
                "51eec78a-3249-43fa-94d6-2c87050625ed",
                "5cc6f33b-b64a-44e8-8b1d-2b6e14055597",
                "adc8b0aa-4cee-456d-bf6f-829ba79d5ff7"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 34819,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "2fdce954-debe-41a2-b9f7-49f548eb7d99",
              "title": "Collect Royalty and Claim Reward",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts",
              "file": "/test/integration/group.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Collect Royalty and Claim Reward\"",
                  "fullTitle": "Group Functions Collect Royalty and Claim Reward \"before all\" hook in \"Collect Royalty and Claim Reward\"",
                  "timedOut": false,
                  "duration": 9094,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Register IP id\nconst result1 = await mintAndRegisterIpAssetWithPilTermsHelper();\nipId = result1.ipId;\nlicenseTermsId = result1.licenseTermsIds[0];\n// Register group id\ngroupIpId = await registerGroupAndAttachLicenseHelper(licenseTermsId, [ipId]);",
                  "err": {},
                  "uuid": "3603cc24-fc29-422c-8106-05ee8058e380",
                  "parentUUID": "2fdce954-debe-41a2-b9f7-49f548eb7d99",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully collect royalties",
                  "fullTitle": "Group Functions Collect Royalty and Claim Reward should successfully collect royalties",
                  "timedOut": false,
                  "duration": 17995,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Mint and register child IP id\nconst childIpId = await mintAndRegisterIpAndMakeDerivativeHelper(groupIpId, licenseTermsId);\n// Pay royalties from child IP id to group IP id and transfer to vault\nawait payRoyaltyAndTransferToVaultHelper(childIpId, groupIpId, src_1.WIP_TOKEN_ADDRESS, 100n);\n// Collect royalties\nconst result = await client.groupClient.collectRoyalties({\n    groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.collectedRoyalties).to.equal(10n);",
                  "err": {},
                  "uuid": "33661327-b7d6-44db-b213-692f3c02a33c",
                  "parentUUID": "2fdce954-debe-41a2-b9f7-49f548eb7d99",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully get claimable reward",
                  "fullTitle": "Group Functions Collect Royalty and Claim Reward should successfully get claimable reward",
                  "timedOut": false,
                  "duration": 37,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.groupClient.getClaimableReward({\n    groupIpId: groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n});\n(0, chai_1.expect)(result).to.deep.equal([10n]);",
                  "err": {},
                  "uuid": "888af94b-7d3e-4d0b-86d0-b4710400fb01",
                  "parentUUID": "2fdce954-debe-41a2-b9f7-49f548eb7d99",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully claim reward",
                  "fullTitle": "Group Functions Collect Royalty and Claim Reward should successfully claim reward",
                  "timedOut": false,
                  "duration": 13028,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Mint license tokens to the IP id which doesn't have a royalty vault\nawait client.license.mintLicenseTokens({\n    licensorIpId: ipId,\n    licenseTermsId,\n    amount: 100,\n    maxMintingFee: 1,\n    maxRevenueShare: 100,\n});\n// Claim reward\nconst result = await client.groupClient.claimReward({\n    groupIpId: groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.claimedReward?.[0].amount[0]).to.equal(10n);",
                  "err": {},
                  "uuid": "3a9d3e12-b64b-4e74-9190-4375bc795046",
                  "parentUUID": "2fdce954-debe-41a2-b9f7-49f548eb7d99",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail when trying to claim reward for a non-existent group",
                  "fullTitle": "Group Functions Collect Royalty and Claim Reward should fail when trying to claim reward for a non-existent group",
                  "timedOut": false,
                  "duration": 35,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const nonExistentGroupId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.claimReward({\n    groupIpId: nonExistentGroupId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n})).to.be.rejectedWith(\"Failed to claim reward\");",
                  "err": {},
                  "uuid": "3f546e78-a929-4910-9912-e5a42e112b53",
                  "parentUUID": "2fdce954-debe-41a2-b9f7-49f548eb7d99",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail when trying to claim reward with invalid token address",
                  "fullTitle": "Group Functions Collect Royalty and Claim Reward should fail when trying to claim reward with invalid token address",
                  "timedOut": false,
                  "duration": 38,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const invalidTokenAddress = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.claimReward({\n    groupIpId: groupIpId,\n    currencyToken: invalidTokenAddress,\n    memberIpIds: [ipId],\n})).to.be.rejectedWith(\"Failed to claim reward\");",
                  "err": {},
                  "uuid": "cad8bea9-8e0c-4d61-a979-9ccb72ece4d6",
                  "parentUUID": "2fdce954-debe-41a2-b9f7-49f548eb7d99",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully collect royalties and claim reward in one transaction",
                  "fullTitle": "Group Functions Collect Royalty and Claim Reward should successfully collect royalties and claim reward in one transaction",
                  "timedOut": false,
                  "duration": 54074,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const ipIds = [];\nconst result1 = await mintAndRegisterIpAssetWithPilTermsHelper();\nconst result2 = await mintAndRegisterIpAssetWithPilTermsHelper();\nipIds.push(result1.ipId);\nipIds.push(result2.ipId);\nlicenseTermsId = result1.licenseTermsIds[0];\nconst groupId = await registerGroupAndAttachLicenseHelper(licenseTermsId, ipIds);\nconst childIpId1 = await mintAndRegisterIpAndMakeDerivativeHelper(groupId, licenseTermsId);\nconst childIpId2 = await mintAndRegisterIpAndMakeDerivativeHelper(groupId, licenseTermsId);\nawait payRoyaltyAndTransferToVaultHelper(childIpId1, groupId, src_1.WIP_TOKEN_ADDRESS, 100n);\nawait payRoyaltyAndTransferToVaultHelper(childIpId2, groupId, src_1.WIP_TOKEN_ADDRESS, 100n);\nconst result = await client.groupClient.collectAndDistributeGroupRoyalties({\n    groupIpId: groupId,\n    currencyTokens: [src_1.WIP_TOKEN_ADDRESS],\n    memberIpIds: ipIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.collectedRoyalties?.[0].amount).to.equal(20n);\n(0, chai_1.expect)(result.royaltiesDistributed?.[0].amount).to.equal(10n);\n(0, chai_1.expect)(result.royaltiesDistributed?.[1].amount).to.equal(10n);",
                  "err": {},
                  "uuid": "ea77f683-b4df-453d-a8d6-ea67fd16a463",
                  "parentUUID": "2fdce954-debe-41a2-b9f7-49f548eb7d99",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "33661327-b7d6-44db-b213-692f3c02a33c",
                "888af94b-7d3e-4d0b-86d0-b4710400fb01",
                "3a9d3e12-b64b-4e74-9190-4375bc795046",
                "3f546e78-a929-4910-9912-e5a42e112b53",
                "cad8bea9-8e0c-4d61-a979-9ccb72ece4d6",
                "ea77f683-b4df-453d-a8d6-ea67fd16a463"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 85207,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "31697990-62c5-44e8-a25e-4f0c1dc271d1",
          "title": "IPAccount Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts",
          "file": "/test/integration/ipAccount.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"IPAccount Functions\"",
              "fullTitle": "IPAccount Functions \"before all\" hook in \"IPAccount Functions\"",
              "timedOut": false,
              "duration": 8972,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = registerResult.ipId;\ndata = (0, viem_1.encodeFunctionData)({\n    abi: generated_1.accessControllerAbi,\n    functionName: \"setTransientPermission\",\n    args: [\n        (0, viem_1.getAddress)(ipId),\n        (0, viem_1.getAddress)(util_1.TEST_WALLET_ADDRESS),\n        (0, viem_1.getAddress)(coreMetadataModule),\n        (0, viem_1.toFunctionSelector)(\"function setAll(address,string,bytes32,bytes32)\"),\n        src_1.AccessPermission.ALLOW,\n    ],\n});",
              "err": {},
              "uuid": "3fe46d2e-c1fb-4628-9450-17a950b9f31f",
              "parentUUID": "31697990-62c5-44e8-a25e-4f0c1dc271d1",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [
            {
              "title": "should successfully set ip metadata",
              "fullTitle": "IPAccount Functions should successfully set ip metadata",
              "timedOut": false,
              "duration": 8427,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const txHash = await client.ipAccount.setIpMetadata({\n    ipId: ipId,\n    metadataURI: \"https://example.com\",\n    metadataHash: (0, viem_1.toHex)(\"test\", { size: 32 }),\n});\n(0, chai_1.expect)(txHash).to.be.a(\"string\");",
              "err": {},
              "uuid": "91936257-8b30-44c5-9c16-effd17a304a2",
              "parentUUID": "31697990-62c5-44e8-a25e-4f0c1dc271d1",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "should successfully transfer ERC20 tokens",
              "fullTitle": "IPAccount Functions should successfully transfer ERC20 tokens",
              "timedOut": false,
              "duration": 22007,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const erc20 = new generated_1.Erc20Client(util_1.publicClient, util_1.walletClient);\n// 1. Query token balance of ipId and wallet before\nconst initialErc20BalanceOfIpId = await erc20.balanceOf({\n    account: ipId,\n});\nconst initialErc20BalanceOfWallet = await erc20.balanceOf({\n    account: util_1.TEST_WALLET_ADDRESS,\n});\nconst initialWipBalanceOfIpId = await client.wipClient.balanceOf(ipId);\nconst initialWipBalanceOfWallet = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n// 2. transfer erc20 token to the ip account\nconst txHash = await erc20.mint({\n    to: ipId,\n    amount: (0, viem_1.parseEther)(\"0.002\"),\n});\nawait util_1.publicClient.waitForTransactionReceipt({\n    hash: txHash,\n});\n// 3. transfer wip to the ip account\nawait client.wipClient.deposit({\n    amount: 1n,\n});\nawait client.wipClient.transfer({\n    to: ipId,\n    amount: 1n,\n});\n// 4. transfer token of ip account to wallet address\nconst ret = await client.ipAccount.transferErc20({\n    ipId,\n    tokens: [\n        {\n            address: src_1.WIP_TOKEN_ADDRESS,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: 1n,\n        },\n        {\n            address: erc20.address,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: (0, viem_1.parseEther)(\"0.001\"),\n        },\n        {\n            address: erc20.address,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: (0, viem_1.parseEther)(\"0.001\"),\n        },\n    ],\n});\n// 5. query token balance of ipId and wallet address after\nconst finalErc20BalanceOfIpId = await erc20.balanceOf({\n    account: ipId,\n});\nconst finalWipBalanceOfIpId = await client.wipClient.balanceOf(ipId);\nconst finalErc20BalanceOfWallet = await erc20.balanceOf({\n    account: util_1.TEST_WALLET_ADDRESS,\n});\nconst finalWipBalanceOfWallet = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(ret.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(finalErc20BalanceOfIpId).to.equal(initialErc20BalanceOfIpId);\n(0, chai_1.expect)(finalWipBalanceOfIpId).to.equal(initialWipBalanceOfIpId);\n(0, chai_1.expect)(finalErc20BalanceOfWallet).to.equal(initialErc20BalanceOfWallet + (0, viem_1.parseEther)(\"0.002\"));\n(0, chai_1.expect)(finalWipBalanceOfWallet).to.equal(initialWipBalanceOfWallet + 1n);",
              "err": {},
              "uuid": "3ffff82f-7fcc-425e-bd6d-3949de8b9844",
              "parentUUID": "31697990-62c5-44e8-a25e-4f0c1dc271d1",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [
            {
              "uuid": "14d6c49a-dee4-4c8c-bddd-6d3b67d75c9f",
              "title": "execute",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts",
              "file": "/test/integration/ipAccount.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully execute a transaction",
                  "fullTitle": "IPAccount Functions execute should successfully execute a transaction",
                  "timedOut": false,
                  "duration": 8469,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.ipAccount.execute({\n    to: permissionAddress,\n    value: 0,\n    data: data,\n    ipId: ipId,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "dfeac169-c62d-4c0a-8791-aeddc8974b3a",
                  "parentUUID": "14d6c49a-dee4-4c8c-bddd-6d3b67d75c9f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with invalid ipId",
                  "fullTitle": "IPAccount Functions execute should fail with invalid ipId",
                  "timedOut": false,
                  "duration": 39,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.ipAccount.execute({\n    to: permissionAddress,\n    value: 0,\n    data: data,\n    ipId: \"0x0000000000000000000000000000000000000000\",\n})).to.be.rejected;",
                  "err": {},
                  "uuid": "4c9ea298-9b8e-455f-bd5e-596a5c3db0a2",
                  "parentUUID": "14d6c49a-dee4-4c8c-bddd-6d3b67d75c9f",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "dfeac169-c62d-4c0a-8791-aeddc8974b3a",
                "4c9ea298-9b8e-455f-bd5e-596a5c3db0a2"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 8508,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "a52a20c4-1751-4327-9903-018753e080cd",
              "title": "executeWithSig",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts",
              "file": "/test/integration/ipAccount.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should fail with expired deadline",
                  "fullTitle": "IPAccount Functions executeWithSig should fail with expired deadline",
                  "timedOut": false,
                  "duration": 55,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: EXPIRED_DEADLINE,\n    signature: \"0x\",\n})).to.be.rejected;",
                  "err": {},
                  "uuid": "d157bce5-d5ff-4079-881e-01cf95a946ba",
                  "parentUUID": "a52a20c4-1751-4327-9903-018753e080cd",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "d157bce5-d5ff-4079-881e-01cf95a946ba"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 55,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "7029f5a5-2448-4e0b-bf7b-0e0e31d40ada",
              "title": "getIpAccountNonce",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts",
              "file": "/test/integration/ipAccount.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully return account nonce",
                  "fullTitle": "IPAccount Functions getIpAccountNonce should successfully return account nonce",
                  "timedOut": false,
                  "duration": 35,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.ipAccount.getIpAccountNonce(ipId);\n(0, chai_1.expect)(response).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "0421da5b-e95b-4c00-8e45-a0bed5e3f3ac",
                  "parentUUID": "7029f5a5-2448-4e0b-bf7b-0e0e31d40ada",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with invalid ipId",
                  "fullTitle": "IPAccount Functions getIpAccountNonce should fail with invalid ipId",
                  "timedOut": false,
                  "duration": 36,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.ipAccount.getIpAccountNonce(\"0x0000000000000000000000000000000000000000\"))\n    .to.be.rejected;",
                  "err": {},
                  "uuid": "32a6bc6d-c804-4ad6-aa82-92eb13a1b891",
                  "parentUUID": "7029f5a5-2448-4e0b-bf7b-0e0e31d40ada",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "0421da5b-e95b-4c00-8e45-a0bed5e3f3ac",
                "32a6bc6d-c804-4ad6-aa82-92eb13a1b891"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 71,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "75f0362d-586c-4414-8675-f20f6270f7a0",
              "title": "getToken",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts",
              "file": "/test/integration/ipAccount.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully return token information",
                  "fullTitle": "IPAccount Functions getToken should successfully return token information",
                  "timedOut": false,
                  "duration": 48,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.ipAccount.getToken(ipId);\n(0, chai_1.expect)(response.chainId).to.be.a(\"bigint\");\n(0, chai_1.expect)(response.tokenContract).to.be.a(\"string\");\n(0, chai_1.expect)(response.tokenId).to.be.a(\"bigint\");\n(0, chai_1.expect)(response.tokenContract).to.equal(util_1.mockERC721);",
                  "err": {},
                  "uuid": "79862212-7aec-46fe-afa2-574466924940",
                  "parentUUID": "75f0362d-586c-4414-8675-f20f6270f7a0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with invalid ipId",
                  "fullTitle": "IPAccount Functions getToken should fail with invalid ipId",
                  "timedOut": false,
                  "duration": 45,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.ipAccount.getToken(\"0x0000000000000000000000000000000000000000\")).to.be\n    .rejected;",
                  "err": {},
                  "uuid": "9ebbcfdd-0340-43cd-ad3d-9d4c78ab8708",
                  "parentUUID": "75f0362d-586c-4414-8675-f20f6270f7a0",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "79862212-7aec-46fe-afa2-574466924940",
                "9ebbcfdd-0340-43cd-ad3d-9d4c78ab8708"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 93,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [
            "91936257-8b30-44c5-9c16-effd17a304a2",
            "3ffff82f-7fcc-425e-bd6d-3949de8b9844"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 30434,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "85f727e0-01c5-44ff-9e70-0267a86ac7d7",
          "title": "IP Asset Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
          "file": "/test/integration/ipAsset.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"IP Asset Functions\"",
              "fullTitle": "IP Asset Functions \"before all\" hook in \"IP Asset Functions\"",
              "timedOut": false,
              "duration": 37,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();\nconst res = await client.license.registerNonComSocialRemixingPIL();\nnoCommercialLicenseTermsId = res.licenseTermsId;",
              "err": {},
              "uuid": "5e5c8c9b-78c2-487d-af43-db0a2e0d15de",
              "parentUUID": "85f727e0-01c5-44ff-9e70-0267a86ac7d7",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "1b31f8c2-6e33-4de0-ad1d-9d2d23cd5291",
              "title": "Basic IP Asset Operations",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should register an IP Asset",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should register an IP Asset",
                  "timedOut": false,
                  "duration": 8886,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nchildIpId = response.ipId;\n(0, chai_1.expect)(childIpId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "3f138168-d580-4ed7-8007-ec666d532388",
                  "parentUUID": "1b31f8c2-6e33-4de0-ad1d-9d2d23cd5291",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register an IP Asset with multiple metadata fields",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should register an IP Asset with multiple metadata fields",
                  "timedOut": false,
                  "duration": 13077,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    ipMetadata: {\n        ipMetadataURI: \"ipfs://test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataURI: \"ipfs://test-nft-uri\",\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n});\nchildIpId2 = response.ipId;\n(0, chai_1.expect)(response.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(response.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "7fa29575-a3b4-41bf-83f8-df6d932c0513",
                  "parentUUID": "1b31f8c2-6e33-4de0-ad1d-9d2d23cd5291",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not register with invalid metadata hash length",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should not register with invalid metadata hash length",
                  "timedOut": false,
                  "duration": 4568,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    ipMetadata: {\n        ipMetadataHash: \"0x123\", // Invalid length hash\n        nftMetadataHash: (0, viem_1.toHex)(\"valid-hash\", { size: 32 }),\n    },\n})).to.be.rejected;",
                  "err": {},
                  "uuid": "e5edc3d3-8ae7-4c42-a691-e3b37783b70c",
                  "parentUUID": "1b31f8c2-6e33-4de0-ad1d-9d2d23cd5291",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not register with non-existent token ID",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should not register with non-existent token ID",
                  "timedOut": false,
                  "duration": 112,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: BigInt(Number.MAX_SAFE_INTEGER),\n})).to.be.rejected;",
                  "err": {},
                  "uuid": "7dd5d3ae-10da-43ce-a36b-db19d6855834",
                  "parentUUID": "1b31f8c2-6e33-4de0-ad1d-9d2d23cd5291",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register derivative with Non-Commercial Remix PIL",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should register derivative with Non-Commercial Remix PIL",
                  "timedOut": false,
                  "duration": 22059,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nparentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [noCommercialLicenseTermsId],\n    maxMintingFee: \"0\",\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: \"0\",\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "6202055f-6c08-4885-aa87-b8bd7a21103b",
                  "parentUUID": "1b31f8c2-6e33-4de0-ad1d-9d2d23cd5291",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register derivative with Commercial Remix PIL",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should register derivative with Commercial Remix PIL",
                  "timedOut": false,
                  "duration": 22176,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Register commercial remix PIL\nconst licenseResponse = await client.license.registerCommercialRemixPIL({\n    defaultMintingFee: 10n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\n// Register parent IP\nconst tokenId = await (0, util_1.getTokenId)();\nconst commercialParentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// Attach license terms to parent IP\nawait client.license.attachLicenseTerms({\n    ipId: commercialParentIpId,\n    licenseTermsId: licenseResponse.licenseTermsId,\n});\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: childIpId2,\n    parentIpIds: [commercialParentIpId],\n    licenseTermsIds: [licenseResponse.licenseTermsId],\n    maxMintingFee: \"100\",\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: \"100\",\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "d1d06be5-75cd-431b-9a47-4f9f2859bc7a",
                  "parentUUID": "1b31f8c2-6e33-4de0-ad1d-9d2d23cd5291",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register derivative with multiple parent IPs",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should register derivative with multiple parent IPs",
                  "timedOut": false,
                  "duration": 48457,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Create first parent IP\nconst tokenId1 = await (0, util_1.getTokenId)();\nconst parentIpId1 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n})).ipId;\n// Create second parent IP\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst parentIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId2,\n})).ipId;\n// Attach license terms to both parents\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId1,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId2,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\n// Create child IP\nconst childTokenId = await (0, util_1.getTokenId)();\nconst newChildIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId,\n})).ipId;\n// Register derivative with multiple parents\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: newChildIpId,\n    parentIpIds: [parentIpId1, parentIpId2],\n    licenseTermsIds: [noCommercialLicenseTermsId, noCommercialLicenseTermsId],\n    maxMintingFee: \"0\",\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: \"0\",\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "a094f4eb-1e9d-43d5-8205-8c6dbefff9ad",
                  "parentUUID": "1b31f8c2-6e33-4de0-ad1d-9d2d23cd5291",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register derivative with license tokens",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should register derivative with license tokens",
                  "timedOut": false,
                  "duration": 17960,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nconst ipId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: noCommercialLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \"0\",\n    maxRevenueShare: 1,\n});\nconst response = await client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "4c4b53c3-9b63-43cd-a4cd-006f13b852ba",
                  "parentUUID": "1b31f8c2-6e33-4de0-ad1d-9d2d23cd5291",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return true if IP asset is registered",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should return true if IP asset is registered",
                  "timedOut": false,
                  "duration": 41,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const isRegistered = await client.ipAsset.isRegistered(parentIpId);\n(0, chai_1.expect)(isRegistered).to.equal(true);",
                  "err": {},
                  "uuid": "2854b948-9930-41d3-ae21-e58460d8ed42",
                  "parentUUID": "1b31f8c2-6e33-4de0-ad1d-9d2d23cd5291",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return false if IP asset is not registered",
                  "fullTitle": "IP Asset Functions Basic IP Asset Operations should return false if IP asset is not registered",
                  "timedOut": false,
                  "duration": 43,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const isRegistered = await client.ipAsset.isRegistered(\"0x1234567890123456789012345678901234567890\");\n(0, chai_1.expect)(isRegistered).to.equal(false);",
                  "err": {},
                  "uuid": "58e12fbf-7cdf-427f-ab38-5066ba46260a",
                  "parentUUID": "1b31f8c2-6e33-4de0-ad1d-9d2d23cd5291",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "3f138168-d580-4ed7-8007-ec666d532388",
                "7fa29575-a3b4-41bf-83f8-df6d932c0513",
                "e5edc3d3-8ae7-4c42-a691-e3b37783b70c",
                "7dd5d3ae-10da-43ce-a36b-db19d6855834",
                "6202055f-6c08-4885-aa87-b8bd7a21103b",
                "d1d06be5-75cd-431b-9a47-4f9f2859bc7a",
                "a094f4eb-1e9d-43d5-8205-8c6dbefff9ad",
                "4c4b53c3-9b63-43cd-a4cd-006f13b852ba",
                "2854b948-9930-41d3-ae21-e58460d8ed42",
                "58e12fbf-7cdf-427f-ab38-5066ba46260a"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 137379,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
              "title": "SPG NFT Operations",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"SPG NFT Operations\"",
                  "fullTitle": "IP Asset Functions SPG NFT Operations \"before all\" hook in \"SPG NFT Operations\"",
                  "timedOut": false,
                  "duration": 9909,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Setup NFT collection\nconst txData = await client.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\n// Setup license terms\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContract,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];\n// Setup ERC20\nconst mockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\nawait mockERC20.approve(generated_1.derivativeWorkflowsAddress[util_1.aeneid], viem_1.maxUint256);\nawait mockERC20.approve(generated_1.royaltyTokenDistributionWorkflowsAddress[util_1.aeneid], viem_1.maxUint256);\nawait mockERC20.mint(util_1.TEST_WALLET_ADDRESS, 100000n);",
                  "err": {},
                  "uuid": "6cf6df09-8c0b-4b98-95a8-345291cb8b28",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should register IP Asset with metadata",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register IP Asset with metadata",
                  "timedOut": false,
                  "duration": 9060,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst response = await client.ipAsset.register({\n    nftContract,\n    tokenId,\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(response.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "690e265a-b3d8-441c-8149-6e2b8441281e",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register derivative IP",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register derivative IP",
                  "timedOut": false,
                  "duration": 9286,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenChildId = await (0, util_1.mintBySpg)(nftContract);\nconst result = await client.ipAsset.registerDerivativeIp({\n    nftContract: nftContract,\n    tokenId: tokenChildId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: \"0\",\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: \"0\",\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "9beb3da1-882c-429d-b4b0-6df3c8fc45eb",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register IP and attach PIL terms",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register IP and attach PIL terms",
                  "timedOut": false,
                  "duration": 13411,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: nftContract,\n    tokenId,\n    deadline: 1000n,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 10000n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"undefined\");",
                  "err": {},
                  "uuid": "f2760b03-641e-461c-b4ae-a9501594f52f",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register IP and attach PIL terms with license terms max limit",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register IP and attach PIL terms with license terms max limit",
                  "timedOut": false,
                  "duration": 9635,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 10000n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);",
                  "err": {},
                  "uuid": "5e943a51-a626-4704-b4b1-09a8c6eedca1",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint and register IP and make derivative",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should mint and register IP and make derivative",
                  "timedOut": false,
                  "duration": 8915,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "34e7041e-40fb-445e-b8ed-73e2fd050cd7",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint and register IP",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should mint and register IP",
                  "timedOut": false,
                  "duration": 4491,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: nftContract,\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n    allowDuplicates: false,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "68032cc0-2eb0-4210-971d-f9b3f13fc113",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register PIL terms and attach",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register PIL terms and attach",
                  "timedOut": false,
                  "duration": 4609,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.registerPilTermsAndAttach({\n    ipId: parentIpId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"undefined\");",
                  "err": {},
                  "uuid": "095f280d-e68c-4ca4-81e0-72da4af1fc72",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register PIL terms and attach with license terms max limit",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register PIL terms and attach with license terms max limit",
                  "timedOut": false,
                  "duration": 5343,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.registerPilTermsAndAttach({\n    ipId: parentIpId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);",
                  "err": {},
                  "uuid": "1c2d56d0-5e29-4878-9102-968f80ced4c6",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint and register IP and make derivative with license tokens",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should mint and register IP and make derivative with license tokens",
                  "timedOut": false,
                  "duration": 17668,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \"0\",\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], mintLicenseTokensResult.licenseTokenIds[0]);\nconst result = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: nftContract,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "0bba4822-f762-4c5b-8178-aa1a7d4ce408",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register IP and make derivative with license tokens",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register IP and make derivative with license tokens",
                  "timedOut": false,
                  "duration": 22032,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \"0\",\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], mintLicenseTokensResult.licenseTokenIds[0]);\nconst result = await client.ipAsset.registerIpAndMakeDerivativeWithLicenseTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "633b7ed3-54b3-4963-9849-fe5dc5494bca",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register IP and attach license terms and distribute royalty tokens",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens",
                  "timedOut": false,
                  "duration": 13921,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 1,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"undefined\");",
                  "err": {},
                  "uuid": "3835b9be-b0f0-4b2a-916a-6199e5433a1f",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register IP and attach license terms and distribute royalty tokens with license terms max limit",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens with license terms max limit",
                  "timedOut": false,
                  "duration": 14575,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 1,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);",
                  "err": {},
                  "uuid": "fd2ce22b-aa97-4525-99aa-fd7dc5661fed",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register IP and attach license terms and distribute royalty tokens with complex royalty shares",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens with complex royalty shares",
                  "timedOut": false,
                  "duration": 17672,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: generated_1.erc20Address[util_1.aeneid],\n                uri: \"test case\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 43,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 17,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 2,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 38,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"undefined\");",
                  "err": {},
                  "uuid": "dbefa84d-2bc2-48ef-8ca0-c8dda2ec13e1",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register derivative and attach license terms and distribute royalty tokens",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should register derivative and attach license terms and distribute royalty tokens",
                  "timedOut": false,
                  "duration": 21575,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: \"0\",\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: \"0\",\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "c284bb6f-50a2-414c-a1a4-5b2f91f8e0c8",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint and register IP and attach PIL terms and distribute royalty tokens without licensing config",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should mint and register IP and attach PIL terms and distribute royalty tokens without licensing config",
                  "timedOut": false,
                  "duration": 4757,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: nftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "b4137029-3668-4491-ace8-6cc599333c2a",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint and register IP and attach PIL terms and distribute royalty tokens with license terms max limit",
                  "fullTitle": "IP Asset Functions SPG NFT Operations should mint and register IP and attach PIL terms and distribute royalty tokens with license terms max limit",
                  "timedOut": false,
                  "duration": 5279,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: nftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n            maxLicenseTokens: 100,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 11n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);",
                  "err": {},
                  "uuid": "6a442d79-71e2-42ab-b707-c83593f4d02f",
                  "parentUUID": "daaa1e53-146d-4b81-97ae-7cc3db81fca0",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "690e265a-b3d8-441c-8149-6e2b8441281e",
                "9beb3da1-882c-429d-b4b0-6df3c8fc45eb",
                "f2760b03-641e-461c-b4ae-a9501594f52f",
                "5e943a51-a626-4704-b4b1-09a8c6eedca1",
                "34e7041e-40fb-445e-b8ed-73e2fd050cd7",
                "68032cc0-2eb0-4210-971d-f9b3f13fc113",
                "095f280d-e68c-4ca4-81e0-72da4af1fc72",
                "1c2d56d0-5e29-4878-9102-968f80ced4c6",
                "0bba4822-f762-4c5b-8178-aa1a7d4ce408",
                "633b7ed3-54b3-4963-9849-fe5dc5494bca",
                "3835b9be-b0f0-4b2a-916a-6199e5433a1f",
                "fd2ce22b-aa97-4525-99aa-fd7dc5661fed",
                "dbefa84d-2bc2-48ef-8ca0-c8dda2ec13e1",
                "c284bb6f-50a2-414c-a1a4-5b2f91f8e0c8",
                "b4137029-3668-4491-ace8-6cc599333c2a",
                "6a442d79-71e2-42ab-b707-c83593f4d02f"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 182229,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "d591b9c7-1ff3-4a7b-9859-b75d3838bcc6",
              "title": "SPG With Minting Fees with Public Minting SPG NFT Contract",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"SPG With Minting Fees with Public Minting SPG NFT Contract\"",
                  "fullTitle": "IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract \"before all\" hook in \"SPG With Minting Fees with Public Minting SPG NFT Contract\"",
                  "timedOut": false,
                  "duration": 13611,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// ensure we start with no wip since we will be wrapping them\nconst wipBalance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nif (wipBalance > 0n) {\n    await client.wipClient.withdraw({\n        amount: wipBalance,\n    });\n}\n// create a nft collection that requires minting fee\nconst rsp = await client.nftClient.createNFTCollection({\n    name: \"Premium Collection\",\n    symbol: \"PC\",\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \"test-uri\",\n    mintFee: 100n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nnftContractWithMintingFee = rsp.spgNftContract;\n// create parent ip with minting fee\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContractWithMintingFee,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 150n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: true,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: BigInt(0),\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: BigInt(0),\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test\",\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 150n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];",
                  "err": {},
                  "uuid": "e23bd81d-979e-457a-a60c-8804ad7d39dd",
                  "parentUUID": "d591b9c7-1ff3-4a7b-9859-b75d3838bcc6",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should auto wrap ip when mint and register derivative",
                  "fullTitle": "IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative",
                  "timedOut": false,
                  "duration": 5098,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const userBalanceBefore = await client.getWalletBalance();\nconst rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContractWithMintingFee, // pay 100 here\n    derivData: {\n        parentIpIds: [parentIpId], // pay 150 here\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    ipMetadata: {\n        ipMetadataURI: \"test\",\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \"test\",\n        nftMetadataHash: viem_1.zeroHash,\n    },\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(rsp.ipId).to.be.a(\"string\");\nconst userBalanceAfter = await client.getWalletBalance();\nconst cost = 150n + 100n;\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - cost));\n// user should not have any WIP tokens since we swap the exact amount\nconst wipBalance = await client.ipAsset.wipClient.balanceOf({\n    owner: util_1.TEST_WALLET_ADDRESS,\n});\n(0, chai_1.expect)(wipBalance.result).to.be.equal(0n);",
                  "err": {},
                  "uuid": "b0f70599-d089-4c34-8b5e-d14b39bfcc45",
                  "parentUUID": "d591b9c7-1ff3-4a7b-9859-b75d3838bcc6",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should auto wrap ip when mint and register derivative with license tokens",
                  "fullTitle": "IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative with license tokens",
                  "timedOut": false,
                  "duration": 30562,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenIds[0]);\n(0, chai_1.expect)(licenseTokenIds).to.be.an(\"array\");\nconst { txHash, ipId } = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: nftContractWithMintingFee,\n    licenseTokenIds: licenseTokenIds,\n    maxRts: common_1.MAX_ROYALTY_TOKEN,\n    ipMetadata: {\n        ipMetadataURI: \"test\",\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \"test\",\n        nftMetadataHash: viem_1.zeroHash,\n    },\n});\n(0, chai_1.expect)(txHash).to.be.a(\"string\");\n(0, chai_1.expect)(ipId).to.be.a(\"string\");\nconst isRegistered = await client.ipAsset.isRegistered(ipId);\n(0, chai_1.expect)(isRegistered).to.equal(true);",
                  "err": {},
                  "uuid": "e1f9b3c8-d6c1-454c-b2f4-0da0e0addb1d",
                  "parentUUID": "d591b9c7-1ff3-4a7b-9859-b75d3838bcc6",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should auto wrap ip when registering derivative",
                  "fullTitle": "IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when registering derivative",
                  "timedOut": false,
                  "duration": 21908,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nconst balanceBefore = await client.getWalletBalance();\nconst rsp = await client.ipAsset.registerDerivativeIp({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(rsp.ipId).to.be.a(\"string\");\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 150n));",
                  "err": {},
                  "uuid": "fe76b735-0aff-48ab-a542-04a366fc57fb",
                  "parentUUID": "d591b9c7-1ff3-4a7b-9859-b75d3838bcc6",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should spend existing wip when register derivative and distribute loyalty tokens",
                  "fullTitle": "IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should spend existing wip when register derivative and distribute loyalty tokens",
                  "timedOut": false,
                  "duration": 18198,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nawait client.wipClient.deposit({\n    amount: 150n,\n});\nconst rsp = await client.ipAsset.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(rsp.ipRoyaltyVault).to.be.a(\"string\");\n(0, chai_1.expect)(rsp.distributeRoyaltyTokensTxHash).to.be.a(\"string\");\n(0, chai_1.expect)(rsp.ipId).to.be.a(\"string\");\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.be.equal(0n);",
                  "err": {},
                  "uuid": "9868f503-0f2b-4940-b9e7-00a68fa0b10b",
                  "parentUUID": "d591b9c7-1ff3-4a7b-9859-b75d3838bcc6",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should auto wrap ip when mint and register derivative and distribute loyalty tokens",
                  "fullTitle": "IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative and distribute loyalty tokens",
                  "timedOut": false,
                  "duration": 4960,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens({\n    spgNftContract: nftContractWithMintingFee,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    ipMetadata: {\n        ipMetadataURI: \"test\",\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \"test\",\n        nftMetadataHash: viem_1.zeroHash,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(rsp.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "f9277e19-83f9-4d70-926c-6a4cf2e74335",
                  "parentUUID": "d591b9c7-1ff3-4a7b-9859-b75d3838bcc6",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "b0f70599-d089-4c34-8b5e-d14b39bfcc45",
                "e1f9b3c8-d6c1-454c-b2f4-0da0e0addb1d",
                "fe76b735-0aff-48ab-a542-04a366fc57fb",
                "9868f503-0f2b-4940-b9e7-00a68fa0b10b",
                "f9277e19-83f9-4d70-926c-6a4cf2e74335"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 80726,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "fd8daf15-fe1a-4f22-acfc-f250c912f569",
              "title": "IP Asset Registration with Private Minting SPG NFT Contracts",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"IP Asset Registration with Private Minting SPG NFT Contracts\"",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts \"before all\" hook in \"IP Asset Registration with Private Minting SPG NFT Contracts\"",
                  "timedOut": false,
                  "duration": 4327,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \"Private Minting Collection\",\n    symbol: \"PMC\",\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 3n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \"\",\n});\nspgNftContractWithPrivateMinting = privateMintingCollectionResult.spgNftContract;",
                  "err": {},
                  "uuid": "b1836047-6d2a-4de9-a2b1-9d3e8766acc4",
                  "parentUUID": "fd8daf15-fe1a-4f22-acfc-f250c912f569",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully when call mint and register ip asset with pil terms",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip asset with pil terms",
                  "timedOut": false,
                  "duration": 13729,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"undefined\");\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];",
                  "err": {},
                  "uuid": "d0c6069b-8f3c-45cb-a83e-cb4cfd387af0",
                  "parentUUID": "fd8daf15-fe1a-4f22-acfc-f250c912f569",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully when call mint and register ip asset with pil terms with license terms max limit",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip asset with pil terms with license terms max limit",
                  "timedOut": false,
                  "duration": 10095,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 5n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 5n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n    ipMetadata: {\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\"array\");\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);",
                  "err": {},
                  "uuid": "532d7430-117c-4477-8548-b6cdd3ef8740",
                  "parentUUID": "fd8daf15-fe1a-4f22-acfc-f250c912f569",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully when call mint and register ip and make derivative",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and make derivative",
                  "timedOut": false,
                  "duration": 9389,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 100n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "efdf095f-b339-4e8b-8934-2950972454ee",
                  "parentUUID": "fd8daf15-fe1a-4f22-acfc-f250c912f569",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully when call mint and register ip",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip",
                  "timedOut": false,
                  "duration": 8998,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n    allowDuplicates: false,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "407804ee-8053-4d68-9830-e71238f5babc",
                  "parentUUID": "fd8daf15-fe1a-4f22-acfc-f250c912f569",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully when call mint and register ip and make derivative with license tokens",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and make derivative with license tokens",
                  "timedOut": false,
                  "duration": 22233,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \"0\",\n    maxRevenueShare: 100,\n});\nconst licenseTokenId = mintLicenseTokensResult.licenseTokenIds[0];\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenId);\nconst result = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    licenseTokenIds: [licenseTokenId],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \"test-uri\",\n        ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "95fbdad4-04d8-480e-9874-dbc5f2e625ba",
                  "parentUUID": "fd8daf15-fe1a-4f22-acfc-f250c912f569",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully when call mint and register ip and attach pil terms and distribute royalty tokens",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and attach pil terms and distribute royalty tokens",
                  "timedOut": false,
                  "duration": 9308,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"test case\",\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.ipId).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\"array\");\n(0, chai_1.expect)(result.tokenId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "9fb92006-5c48-4c69-a29e-f0fa590faa2d",
                  "parentUUID": "fd8daf15-fe1a-4f22-acfc-f250c912f569",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should succeed when call mint and register ip and make derivative and distribute royalty tokens",
                  "fullTitle": "IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should succeed when call mint and register ip and make derivative and distribute royalty tokens",
                  "timedOut": false,
                  "duration": 26658,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: true,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\nconst newParentIpId = result.ipId;\nconst licenseId = result.licenseTermsIds[0];\nconst rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    derivData: {\n        parentIpIds: [newParentIpId],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(rsp.ipId).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "1edf975f-799e-4747-a834-066e0d446e7a",
                  "parentUUID": "fd8daf15-fe1a-4f22-acfc-f250c912f569",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "d0c6069b-8f3c-45cb-a83e-cb4cfd387af0",
                "532d7430-117c-4477-8548-b6cdd3ef8740",
                "efdf095f-b339-4e8b-8934-2950972454ee",
                "407804ee-8053-4d68-9830-e71238f5babc",
                "95fbdad4-04d8-480e-9874-dbc5f2e625ba",
                "9fb92006-5c48-4c69-a29e-f0fa590faa2d",
                "1edf975f-799e-4747-a834-066e0d446e7a"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 100410,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "f6504bc7-22b4-4526-aa1d-326fdaaa6368",
              "title": "Batch Operations",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Batch Operations\"",
                  "fullTitle": "IP Asset Functions Batch Operations \"before all\" hook in \"Batch Operations\"",
                  "timedOut": false,
                  "duration": 17369,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\nconst tokenId = await (0, util_1.getTokenId)();\nparentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;",
                  "err": {},
                  "uuid": "4aeda02b-6d7c-4d0b-8cb9-928fb29d26b0",
                  "parentUUID": "f6504bc7-22b4-4526-aa1d-326fdaaa6368",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should batch register derivative",
                  "fullTitle": "IP Asset Functions Batch Operations should batch register derivative",
                  "timedOut": false,
                  "duration": 35830,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const childTokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId,\n})).ipId;\nconst childTokenId2 = await (0, util_1.getTokenId)();\nconst childIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId2,\n})).ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nconst result = await client.ipAsset.batchRegisterDerivative({\n    args: [\n        {\n            childIpId: childIpId,\n            parentIpIds: [parentIpId],\n            licenseTermsIds: [noCommercialLicenseTermsId],\n            maxMintingFee: \"0\",\n            maxRts: 5 * 10 ** 6,\n            maxRevenueShare: \"0\",\n        },\n        {\n            childIpId: childIpId2,\n            parentIpIds: [parentIpId],\n            licenseTermsIds: [noCommercialLicenseTermsId],\n            maxMintingFee: \"0\",\n            maxRts: 5 * 10 ** 6,\n            maxRevenueShare: \"0\",\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "bc0a7775-f7b1-4650-8b50-b08fc81516d2",
                  "parentUUID": "f6504bc7-22b4-4526-aa1d-326fdaaa6368",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should batch mint and register IP asset with PIL terms",
                  "fullTitle": "IP Asset Functions Batch Operations should batch mint and register IP asset with PIL terms",
                  "timedOut": false,
                  "duration": 9911,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.batchMintAndRegisterIpAssetWithPilTerms({\n    args: [\n        {\n            spgNftContract: nftContract,\n            licenseTermsData: [\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 8n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \"\",\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 8n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                    maxLicenseTokens: 100,\n                },\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 80n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \"\",\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 100n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                },\n            ],\n        },\n        {\n            spgNftContract: nftContract,\n            licenseTermsData: [\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 8n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \"\",\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 8n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                    maxLicenseTokens: 100,\n                },\n            ],\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.results).to.be.an(\"array\");\n(0, chai_1.expect)(result.results[0].licenseTermsIds).to.be.an(\"array\").and.length(2);\n(0, chai_1.expect)(result.results[0].maxLicenseTokensTxHashes).to.be.an(\"array\").and.length(1);\n(0, chai_1.expect)(result.results[1].licenseTermsIds).to.be.an(\"array\").and.length(1);\n(0, chai_1.expect)(result.results[1].maxLicenseTokensTxHashes).to.be.an(\"array\").and.length(1);",
                  "err": {},
                  "uuid": "36ec0714-6bad-43f1-b88c-3e095fa20f0c",
                  "parentUUID": "f6504bc7-22b4-4526-aa1d-326fdaaa6368",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should batch mint and register IP asset and make derivative",
                  "fullTitle": "IP Asset Functions Batch Operations should batch mint and register IP asset and make derivative",
                  "timedOut": false,
                  "duration": 5147,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract: nftContract,\n            derivData: {\n                parentIpIds: [parentIpId],\n                licenseTermsIds: [noCommercialLicenseTermsId],\n                maxMintingFee: \"0\",\n                maxRts: 5 * 10 ** 6,\n                maxRevenueShare: \"0\",\n            },\n        },\n        {\n            spgNftContract: nftContract,\n            derivData: {\n                parentIpIds: [parentIpId],\n                licenseTermsIds: [noCommercialLicenseTermsId],\n                maxMintingFee: \"0\",\n                maxRts: 5 * 10 ** 6,\n                maxRevenueShare: \"0\",\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.results).to.be.an(\"array\");",
                  "err": {},
                  "uuid": "135c71ff-f460-4d4c-b4be-cf5dd38764e3",
                  "parentUUID": "f6504bc7-22b4-4526-aa1d-326fdaaa6368",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should batch register giving parameters",
                  "fullTitle": "IP Asset Functions Batch Operations should batch register giving parameters",
                  "timedOut": false,
                  "duration": 22877,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst spgTokenId1 = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst spgTokenId2 = await (0, util_1.mintBySpg)(nftContract, \"test-metadata\");\nconst result = await client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId,\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2,\n        },\n        {\n            nftContract,\n            tokenId: spgTokenId1,\n            ipMetadata: {\n                ipMetadataURI: \"test-uri2\",\n                ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash2\", { size: 32 }),\n                nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash2\", { size: 32 }),\n            },\n        },\n        {\n            nftContract,\n            tokenId: spgTokenId2,\n            ipMetadata: {\n                ipMetadataURI: \"test-uri\",\n                ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n                nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.results).to.be.an(\"array\");\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "373d2c43-1e10-4ee6-a4f6-fc795e2b37ce",
                  "parentUUID": "f6504bc7-22b4-4526-aa1d-326fdaaa6368",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "bc0a7775-f7b1-4650-8b50-b08fc81516d2",
                "36ec0714-6bad-43f1-b88c-3e095fa20f0c",
                "135c71ff-f460-4d4c-b4be-cf5dd38764e3",
                "373d2c43-1e10-4ee6-a4f6-fc795e2b37ce"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 73765,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "d0f6a112-a8a5-4397-a7f3-71acd1a4d2ff",
              "title": "Error Cases",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Error Cases\"",
                  "fullTitle": "IP Asset Functions Error Cases \"before all\" hook in \"Error Cases\"",
                  "timedOut": false,
                  "duration": 4689,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;",
                  "err": {},
                  "uuid": "028ad1dd-0e14-4f06-94b8-9f490a54587c",
                  "parentUUID": "d0f6a112-a8a5-4397-a7f3-71acd1a4d2ff",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should fail to register unowned NFT",
                  "fullTitle": "IP Asset Functions Error Cases should fail to register unowned NFT",
                  "timedOut": false,
                  "duration": 148,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: nftContract,\n    tokenId: 999999n, // Non-existent token\n})).to.be.rejected;",
                  "err": {},
                  "uuid": "4b888e06-23a5-4cc3-8c06-c88bcf437be0",
                  "parentUUID": "d0f6a112-a8a5-4397-a7f3-71acd1a4d2ff",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "4b888e06-23a5-4cc3-8c06-c88bcf437be0"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 148,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "79981ce4-bfce-4364-8139-ad861199ba3a",
              "title": "Other Edge Cases",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Other Edge Cases\"",
                  "fullTitle": "IP Asset Functions Other Edge Cases \"before all\" hook in \"Other Edge Cases\"",
                  "timedOut": false,
                  "duration": 13573,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst parentIpResponse = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nparentIpId = parentIpResponse.ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});",
                  "err": {},
                  "uuid": "2ffc0370-8cae-497b-b617-41bbeb3d4e9a",
                  "parentUUID": "79981ce4-bfce-4364-8139-ad861199ba3a",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "36bfdec9-42f5-4ce7-960b-2b381d0de264",
                  "title": "License Token Edge Cases",
                  "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
                  "file": "/test/integration/ipAsset.test.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should fail when trying to use non-existent license token",
                      "fullTitle": "IP Asset Functions Other Edge Cases License Token Edge Cases should fail when trying to use non-existent license token",
                      "timedOut": false,
                      "duration": 13056,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tokenId = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId,\n    })).ipId,\n    licenseTokenIds: [BigInt(999999)], // Non-existent token\n    maxRts: 5 * 10 ** 6,\n})).to.be.rejected;",
                      "err": {},
                      "uuid": "9c1df4ea-6ea7-429a-a4ad-6e3f2d976f59",
                      "parentUUID": "36bfdec9-42f5-4ce7-960b-2b381d0de264",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should fail when trying to use same license token twice",
                      "fullTitle": "IP Asset Functions Other Edge Cases License Token Edge Cases should fail when trying to use same license token twice",
                      "timedOut": false,
                      "duration": 27089,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: noCommercialLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \"0\",\n    maxRevenueShare: 1,\n});\nconst tokenId1 = await (0, util_1.getTokenId)();\nawait client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n    })).ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n});\nconst tokenId2 = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n    })).ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n})).to.be.rejected; // Should fail as token already used",
                      "err": {},
                      "uuid": "c21883a2-d405-4576-8cba-983173ca814a",
                      "parentUUID": "36bfdec9-42f5-4ce7-960b-2b381d0de264",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "9c1df4ea-6ea7-429a-a4ad-6e3f2d976f59",
                    "c21883a2-d405-4576-8cba-983173ca814a"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 40145,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 300000
                },
                {
                  "uuid": "58dcaf7d-60f8-4143-b7f8-ae9cd66a72ef",
                  "title": "Batch Operation Edge Cases",
                  "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
                  "file": "/test/integration/ipAsset.test.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should handle partial failures in batch registration",
                      "fullTitle": "IP Asset Functions Other Edge Cases Batch Operation Edge Cases should handle partial failures in batch registration",
                      "timedOut": false,
                      "duration": 13413,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nawait client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n});\nawait (0, chai_1.expect)(client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId1, // Already registered\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2, // New registration\n        },\n    ],\n})).to.be.rejected;",
                      "err": {},
                      "uuid": "cf66dd18-3c0c-465e-8370-bf57e3578298",
                      "parentUUID": "58dcaf7d-60f8-4143-b7f8-ae9cd66a72ef",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "cf66dd18-3c0c-465e-8370-bf57e3578298"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 13413,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 300000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "d4546976-2654-49f3-a162-fed8b321f6f4",
              "title": "Batch Register IP Assets With Optimized Workflows",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts",
              "file": "/test/integration/ipAsset.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Batch Register IP Assets With Optimized Workflows\"",
                  "fullTitle": "IP Asset Functions Batch Register IP Assets With Optimized Workflows \"before all\" hook in \"Batch Register IP Assets With Optimized Workflows\"",
                  "timedOut": false,
                  "duration": 40095,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Create a public minting NFT collection\nconst publicMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \"Public Minting Collection\",\n    symbol: \"PMC\",\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \"\",\n});\nspgNftContractWithPublicMinting = publicMintingCollectionResult.spgNftContract;\n// Create a private minting NFT collection\nconst privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \"Private Minting Collection\",\n    symbol: \"PRC\",\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \"\",\n});\nspgNftContractWithPrivateMinting = privateMintingCollectionResult.spgNftContract;\n// Register a commercial remix PIL license\nconst commercialRemixPILResult = await client.license.registerCommercialRemixPIL({\n    defaultMintingFee: 10n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\nlicenseTermsId1 = commercialRemixPILResult.licenseTermsId;\n// Register a commercial use PIL license\nconst commercialUsePILResult = await client.license.registerPILTerms({\n    transferable: true,\n    royaltyPolicy: \"0xBe54FB168b3c982b7AaE60dB6CF75Bd8447b390E\",\n    defaultMintingFee: 5n,\n    expiration: 0n,\n    commercialUse: true,\n    commercialAttribution: true,\n    commercializerChecker: viem_1.zeroAddress,\n    commercializerCheckerData: viem_1.zeroAddress,\n    commercialRevShare: 10,\n    commercialRevCeiling: 0n,\n    derivativesAllowed: true,\n    derivativesAttribution: true,\n    derivativesApproval: false,\n    derivativesReciprocal: true,\n    derivativeRevCeiling: 0n,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    uri: \"https://github.com/piplabs/pil-document/blob/ad67bb632a310d2557f8abcccd428e4c9c798db1/off-chain-terms/CommercialRemix.json\",\n});\nlicenseTermsId2 = commercialUsePILResult.licenseTermsId;\n// Mint and register IP with public minting contract\nconst publicMintingIpResult = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPublicMinting,\n});\nparentIpId1 = publicMintingIpResult.ipId;\n// Attach license terms to the first IP\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId1,\n    licenseTermsId: licenseTermsId1,\n});\n// Mint and register IP with private minting contract\nconst privateMintingIpResult = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPrivateMinting,\n});\nparentIpId2 = privateMintingIpResult.ipId;\n// Attach license terms to the second IP\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId2,\n    licenseTermsId: licenseTermsId2,\n});",
                  "err": {},
                  "uuid": "98266114-fb43-4b92-8ac2-89d27ef15e7d",
                  "parentUUID": "d4546976-2654-49f3-a162-fed8b321f6f4",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully batch register multiple IP assets with SPG NFT contracts",
                  "fullTitle": "IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully batch register multiple IP assets with SPG NFT contracts",
                  "timedOut": false,
                  "duration": 47170,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15(10+5) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall due to the private minting\n     * - `maxLicenseTokens` is set to 1000n for first license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 1000n,\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 3n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 3n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     * - `maxLicenseTokens` is set to 100n for license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 100n,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 20(10+10) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5(0+5) WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the mint tokens is given `msg.sender` as the recipient\n     * - `maxLicenseTokens` is set to 80n and 10n for license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"test case\",\n                },\n                maxLicenseTokens: 80n,\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 100n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"test case\",\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the mint tokens is given `msg.sender` as the recipient\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"test case\",\n                },\n            },\n        ],\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10,\n            },\n        ],\n    },\n];\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\nconst totalFees = 10 + 15 + 0 + 10 + 20 + 5 + 10 + 0;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n/**\n * Transaction breakdown:\n *\n * 1. derivativeWorkflowsClient: 1 transaction\n *    - No license terms attached\n *\n * 2. multicall3Client: 3 transactions\n *    - Second transaction includes license terms with maxLicenseTokens: 1000n\n *\n * 3. licenseAttachmentWorkflowsClient: 1 transaction\n *    - Two license terms attached\n *    - First license terms: maxLicenseTokens: 1000n\n *\n * 4. royaltyTokenDistributionWorkflowsClient: 3 transactions\n *    - Second transaction includes two license terms:\n *    -  First license terms: maxLicenseTokens: 80n\n *    - Second license terms: maxLicenseTokens: 10n\n *   - Third transaction includes a license terms\n *\n * Summary:\n * - Total transactions: 4 (4 unique transaction hashes)\n * - Total IP assets registered: 8\n */\n(0, chai_1.expect)(result.registrationResults.length).equal(4);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) => a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(2);",
                  "err": {},
                  "uuid": "306a813f-de4a-4d3d-afa7-03e0e05d54ea",
                  "parentUUID": "d4546976-2654-49f3-a162-fed8b321f6f4",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully batch register multiple IP assets with NFT contracts",
                  "fullTitle": "IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully batch register multiple IP assets with NFT contracts",
                  "timedOut": false,
                  "duration": 65026,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst tokenId4 = await (0, util_1.getTokenId)();\nconst tokenId5 = await (0, util_1.getTokenId)();\nconst tokenId6 = await (0, util_1.getTokenId)();\nconst tokenId7 = await (0, util_1.getTokenId)();\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst requests = [\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerIpAndAttachPilTerms  workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall\n     * - `maxLicenseTokens` is set to 100n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId3,\n        deadline: 1000n,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: viem_1.zeroAddress,\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: false,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"test case\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 10000n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 100n,\n            },\n        ],\n    },\n    /**\n     * registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     * - `maxLicenseTokens` is set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId4,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \"test case\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 1n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \"test case\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 6n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n        ],\n        ipMetadata: {\n            ipMetadataURI: \"test-uri\",\n            ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n            nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 43,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 17,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 2,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 38,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId5,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId6,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId7,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10,\n            },\n        ],\n    },\n];\nconst totalFees = 10 + 5 + 0 + 0 + 5 + 10 + 5;\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n/**\n * Transaction breakdown:\n * 1. royaltyTokenDistributionWorkflowsClient: 4 args\n *  - The third request has two license terms, first one has `maxLicenseTokens` set to 10n\n *\n * 2.licenseAttachmentWorkflowsClient: 1 arg\n *  - The first request have two license terms, second one has `maxLicenseTokens` set to 100n\n *\n * 3.derivativeWorkflowsClient: 2 args\n *  - None license terms and no `maxLicenseTokens` set\n *\n * Summary:\n * - Total transactions: 3 (3 unique transaction hashes)\n * - Total IP assets registered: 7\n */\n(0, chai_1.expect)(result.registrationResults.length).equal(3);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) => a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).greaterThan(0);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(4);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes).equal(undefined);",
                  "err": {},
                  "uuid": "02a7fa4b-f604-4c93-b195-018e55202602",
                  "parentUUID": "d4546976-2654-49f3-a162-fed8b321f6f4",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully register IP assets using a combination of NFT contracts and SPG NFT contracts",
                  "fullTitle": "IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully register IP assets using a combination of NFT contracts and SPG NFT contracts",
                  "timedOut": false,
                  "duration": 55467,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst tokenId4 = await (0, util_1.getTokenId)();\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15(10+5) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5(0+5) WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 20(10+10) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10,\n            },\n        ],\n    },\n    /**\n     * registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     * - `maxLicenseTokens` is set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \"test case\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 1n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n        ipMetadata: {\n            ipMetadataURI: \"test-uri\",\n            ipMetadataHash: (0, viem_1.toHex)(\"test-metadata-hash\", { size: 32 }),\n            nftMetadataHash: (0, viem_1.toHex)(\"test-nft-metadata-hash\", { size: 32 }),\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 43,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 17,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 2,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 38,\n            },\n        ],\n    },\n    /**\n     * registerIpAndAttachPilTerms  workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall\n     * - the second request has `maxLicenseTokens` set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId3,\n        deadline: 1000n,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: viem_1.zeroAddress,\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: false,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"test case\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 10000n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId4,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n];\nconst totalFees = 15 + 5 + 20 + 10 + 5 + 0 + 0 + 10;\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n/**\n * Transaction breakdown:\n * 1. multicall3Client: 2 args\n *  - No license terms and no `maxLicenseTokens` set\n *\n * 2. royaltyTokenDistributionWorkflowsClient: 3 args\n *  - The third request has a license terms and `maxLicenseTokens` set to 10n\n *\n * 3. derivativeWorkflowsClient: 2 args\n *  - None license terms and no `maxLicenseTokens` set\n *\n * 4. licenseAttachmentWorkflowsClient: 1 arg\n *  - The first request have two license terms, second one has `maxLicenseTokens` set to 10n\n *\n * Summary:\n * - Total transactions: 4 (4 unique transaction hashes)\n * - Total IP assets registered: 8\n */\n(0, chai_1.expect)(result.registrationResults.length).equal(4);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) => a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).greaterThan(0);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[1].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);",
                  "err": {},
                  "uuid": "7633dca4-a79a-4d5c-99e5-4bc2a607418c",
                  "parentUUID": "d4546976-2654-49f3-a162-fed8b321f6f4",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully register IP assets with multicall disabled",
                  "fullTitle": "IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully register IP assets with multicall disabled",
                  "timedOut": false,
                  "duration": 50483,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15(10+5) WIP tokens\n     * - Uses `derivativeWorkflowsClient` to call the this method\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` to call the this method\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` to call the this method\n     * - the first request has `maxLicenseTokens` set to 10n\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 10n,\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \"\",\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient`to call the this method\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient`to call the this method\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n];\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst totalFees = 15 + 0 + 10 + 5 + 5;\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n    options: {\n        wipOptions: {\n            useMulticallWhenPossible: false,\n        },\n    },\n});\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n/**\n * Transaction breakdown:\n * 1. None license terms and no `maxLicenseTokens` set\n * 2. The request have one license terms and no `maxLicenseTokens` set\n * 3. The request have two license terms, first one has `maxLicenseTokens` set to 10n\n * 4. The requests have no license terms and no `maxLicenseTokens` set\n * 5. The requests have no license terms and no `maxLicenseTokens` set\n * Summary:\n * - Total transactions: 5 (5 unique transaction hashes)\n * - Total IP assets registered: 5\n */\n(0, chai_1.expect)(result.registrationResults.length).equal(requests.length);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) => a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[4].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[4].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[4].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);",
                  "err": {},
                  "uuid": "4007661f-25ac-418d-b4bb-10f19f9860c5",
                  "parentUUID": "d4546976-2654-49f3-a162-fed8b321f6f4",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "306a813f-de4a-4d3d-afa7-03e0e05d54ea",
                "02a7fa4b-f604-4c93-b195-018e55202602",
                "7633dca4-a79a-4d5c-99e5-4bc2a607418c",
                "4007661f-25ac-418d-b4bb-10f19f9860c5"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 218146,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "d4987c7f-401a-49b9-b925-4f6d45e096ca",
          "title": "License Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts",
          "file": "/test/integration/license.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"License Functions\"",
              "fullTitle": "License Functions \"before all\" hook in \"License Functions\"",
              "timedOut": false,
              "duration": 41,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();\nconst derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nclientB = derivedClient.clientB;",
              "err": {},
              "uuid": "c0317884-5039-40d7-bd97-d76777702e57",
              "parentUUID": "d4987c7f-401a-49b9-b925-4f6d45e096ca",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "0360a964-0284-42ce-bd92-90222183c1dc",
              "title": "register license with different types",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts",
              "file": "/test/integration/license.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should register license ",
                  "fullTitle": "License Functions register license with different types should register license ",
                  "timedOut": false,
                  "duration": 29,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.registerPILTerms({\n    defaultMintingFee: 0,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    transferable: false,\n    royaltyPolicy: viem_1.zeroAddress,\n    commercialUse: false,\n    commercialAttribution: false,\n    commercializerChecker: viem_1.zeroAddress,\n    commercializerCheckerData: \"0x\",\n    commercialRevShare: 0,\n    derivativesAllowed: false,\n    derivativesAttribution: false,\n    derivativesApproval: false,\n    derivativesReciprocal: false,\n    uri: \"\",\n    expiration: \"\",\n    commercialRevCeiling: \"\",\n    derivativeRevCeiling: \"\",\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "a3d0e83f-8556-447e-acaf-10f4c422207d",
                  "parentUUID": "0360a964-0284-42ce-bd92-90222183c1dc",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register license with non commercial social remixing PIL",
                  "fullTitle": "License Functions register license with different types should register license with non commercial social remixing PIL",
                  "timedOut": false,
                  "duration": 41,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.registerNonComSocialRemixingPIL();\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "4824240c-7161-4cfd-a44a-0a54da789192",
                  "parentUUID": "0360a964-0284-42ce-bd92-90222183c1dc",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register license with commercial use",
                  "fullTitle": "License Functions register license with different types should register license with commercial use",
                  "timedOut": false,
                  "duration": 32,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.registerCommercialUsePIL({\n    defaultMintingFee: \"1\",\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "dd041012-e957-4d81-9633-ad5967d47c10",
                  "parentUUID": "0360a964-0284-42ce-bd92-90222183c1dc",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register license with commercial Remix use",
                  "fullTitle": "License Functions register license with different types should register license with commercial Remix use",
                  "timedOut": false,
                  "duration": 66,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.registerCommercialRemixPIL({\n    defaultMintingFee: \"1\",\n    commercialRevShare: 100,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "4a94ef1c-eff2-44ab-bdd4-fd99c00eb8a9",
                  "parentUUID": "0360a964-0284-42ce-bd92-90222183c1dc",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should register license with creative commons attribution PIL",
                  "fullTitle": "License Functions register license with different types should register license with creative commons attribution PIL",
                  "timedOut": false,
                  "duration": 38,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.registerCreativeCommonsAttributionPIL({\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicyAddress: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "8c76bd26-9f72-4038-99c3-5cb479f43bef",
                  "parentUUID": "0360a964-0284-42ce-bd92-90222183c1dc",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "a3d0e83f-8556-447e-acaf-10f4c422207d",
                "4824240c-7161-4cfd-a44a-0a54da789192",
                "dd041012-e957-4d81-9633-ad5967d47c10",
                "4a94ef1c-eff2-44ab-bdd4-fd99c00eb8a9",
                "8c76bd26-9f72-4038-99c3-5cb479f43bef"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 206,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "286e51ad-e710-4703-bb51-1ca007c4676e",
              "title": "attach License Terms and mint license tokens",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts",
              "file": "/test/integration/license.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"attach License Terms and mint license tokens\"",
                  "fullTitle": "License Functions attach License Terms and mint license tokens \"before all\" hook in \"attach License Terms and mint license tokens\"",
                  "timedOut": false,
                  "duration": 9063,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "tokenId = await (0, util_1.getTokenId)();\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nconst mockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\nawait mockERC20.approve(generated_1.licensingModuleAddress[util_1.aeneid], viem_1.maxUint256);\nipId = registerResult.ipId;\nconst registerLicenseResult = await client.license.registerCommercialRemixPIL({\n    defaultMintingFee: 0,\n    commercialRevShare: 100,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\nlicenseId = registerLicenseResult.licenseTermsId;\nconst paidLicenseResult = await client.license.registerCommercialRemixPIL({\n    defaultMintingFee: 100n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\npaidLicenseId = paidLicenseResult.licenseTermsId;",
                  "err": {},
                  "uuid": "37f7b99b-93cc-4755-936e-fddaaf718e33",
                  "parentUUID": "286e51ad-e710-4703-bb51-1ca007c4676e",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should attach License Terms",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should attach License Terms",
                  "timedOut": false,
                  "duration": 4497,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "5f0a8c3d-48cf-4b42-9c4e-b720977c5adf",
                  "parentUUID": "286e51ad-e710-4703-bb51-1ca007c4676e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should be able to attach another license terms",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should be able to attach another license terms",
                  "timedOut": false,
                  "duration": 4467,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: paidLicenseId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "11a0b671-4cdb-4c02-aae0-348f58c717a4",
                  "parentUUID": "286e51ad-e710-4703-bb51-1ca007c4676e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint license tokens with ip owner",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should mint license tokens with ip owner",
                  "timedOut": false,
                  "duration": 4506,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseId,\n    licensorIpId: ipId,\n    maxMintingFee: \"1\",\n    maxRevenueShare: \"100\",\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\"array\");",
                  "err": {},
                  "uuid": "47d97bce-371e-4d94-b65e-01d7f6500caa",
                  "parentUUID": "286e51ad-e710-4703-bb51-1ca007c4676e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint license tokens with non ip owner",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should mint license tokens with non ip owner",
                  "timedOut": false,
                  "duration": 17743,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// register ip with another wallet account\nconst tokenIdB = await (0, util_1.getTokenId)();\nconst registerResult = await clientB.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenIdB,\n});\nconst ipIdB = registerResult.ipId;\n// attach license terms to the ip\nawait client.license.attachLicenseTerms({\n    ipId: ipIdB,\n    licenseTermsId: licenseId,\n});\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseId,\n    licensorIpId: ipIdB,\n    maxMintingFee: \"1\",\n    maxRevenueShare: \"100\",\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\"array\");",
                  "err": {},
                  "uuid": "2c5bbf6f-0fcd-437b-be50-ca0ab4771f3a",
                  "parentUUID": "286e51ad-e710-4703-bb51-1ca007c4676e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint license token with default license terms",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should mint license token with default license terms",
                  "timedOut": false,
                  "duration": 8568,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// get default license terms id\nconst licenseRegistryReadOnlyClient = new generated_1.LicenseRegistryReadOnlyClient(util_1.publicClient);\nconst { licenseTermsId: defaultLicenseTermsId } = await licenseRegistryReadOnlyClient.getDefaultLicenseTerms();\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: defaultLicenseTermsId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 1,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\"array\");",
                  "err": {},
                  "uuid": "f7144247-f6d9-4486-a3bc-2fa394a4f7c4",
                  "parentUUID": "286e51ad-e710-4703-bb51-1ca007c4676e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint license tokens with fee and pay with IP",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should mint license tokens with fee and pay with IP",
                  "timedOut": false,
                  "duration": 4774,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const balanceBefore = await client.getWalletBalance();\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: paidLicenseId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 50,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 100n));",
                  "err": {},
                  "uuid": "d773b94d-37b6-4d63-ad1c-5cd9e09660a9",
                  "parentUUID": "286e51ad-e710-4703-bb51-1ca007c4676e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should get license terms",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should get license terms",
                  "timedOut": false,
                  "duration": 31,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.getLicenseTerms(licenseId);\n(0, chai_1.expect)(result).to.be.an(\"object\");",
                  "err": {},
                  "uuid": "10d621df-9f34-41e0-b428-3cd4f0ca6756",
                  "parentUUID": "286e51ad-e710-4703-bb51-1ca007c4676e",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should predict minting license fee",
                  "fullTitle": "License Functions attach License Terms and mint license tokens should predict minting license fee",
                  "timedOut": false,
                  "duration": 103,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const result = await client.license.predictMintingLicenseFee({\n    licenseTermsId: licenseId,\n    licensorIpId: ipId,\n    amount: 1,\n});\n(0, chai_1.expect)(result.currencyToken).to.be.a(\"string\");\n(0, chai_1.expect)(result.tokenAmount).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "f29b0fb4-67ec-45fb-a815-c8755ffd6f1f",
                  "parentUUID": "286e51ad-e710-4703-bb51-1ca007c4676e",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [
                {
                  "uuid": "bac109de-abdc-4d45-8bad-04cc4517d219",
                  "title": "licensing config and max license tokens",
                  "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts",
                  "file": "/test/integration/license.test.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should set licensing config",
                      "fullTitle": "License Functions attach License Terms and mint license tokens licensing config and max license tokens should set licensing config",
                      "timedOut": false,
                      "duration": 4480,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.license.setLicensingConfig({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n    licensingConfig,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(result.success).to.equal(true);",
                      "err": {},
                      "uuid": "75205a10-2955-42eb-94a7-4409090b740f",
                      "parentUUID": "bac109de-abdc-4d45-8bad-04cc4517d219",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should get licensing config",
                      "fullTitle": "License Functions attach License Terms and mint license tokens licensing config and max license tokens should get licensing config",
                      "timedOut": false,
                      "duration": 31,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.license.getLicensingConfig({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n});\n(0, chai_1.expect)(result).to.deep.equal(licensingConfig);",
                      "err": {},
                      "uuid": "ec80663f-b650-4818-ac36-91fd352e7a09",
                      "parentUUID": "bac109de-abdc-4d45-8bad-04cc4517d219",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should set max license tokens",
                      "fullTitle": "License Functions attach License Terms and mint license tokens licensing config and max license tokens should set max license tokens",
                      "timedOut": false,
                      "duration": 13044,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const result = await client.license.setMaxLicenseTokens({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n    maxLicenseTokens: 100,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");",
                      "err": {},
                      "uuid": "fee0db64-fbce-4a63-b993-e6b4048937a1",
                      "parentUUID": "bac109de-abdc-4d45-8bad-04cc4517d219",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "75205a10-2955-42eb-94a7-4409090b740f",
                    "ec80663f-b650-4818-ac36-91fd352e7a09",
                    "fee0db64-fbce-4a63-b993-e6b4048937a1"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 17555,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 300000
                }
              ],
              "passes": [
                "5f0a8c3d-48cf-4b42-9c4e-b720977c5adf",
                "11a0b671-4cdb-4c02-aae0-348f58c717a4",
                "47d97bce-371e-4d94-b65e-01d7f6500caa",
                "2c5bbf6f-0fcd-437b-be50-ca0ab4771f3a",
                "f7144247-f6d9-4486-a3bc-2fa394a4f7c4",
                "d773b94d-37b6-4d63-ad1c-5cd9e09660a9",
                "10d621df-9f34-41e0-b428-3cd4f0ca6756",
                "f29b0fb4-67ec-45fb-a815-c8755ffd6f1f"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 44689,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "7619bd1c-d988-471e-a6a3-7bd3f56150f4",
              "title": "Creative Commons Attribution License Tests",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts",
              "file": "/test/integration/license.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"Creative Commons Attribution License Tests\"",
                  "fullTitle": "License Functions Creative Commons Attribution License Tests \"before all\" hook in \"Creative Commons Attribution License Tests\"",
                  "timedOut": false,
                  "duration": 12855,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "tokenId = await (0, util_1.getTokenId)();\n// Register an IP asset\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = registerResult.ipId;\n// Create a Creative Commons Attribution license\nconst ccLicenseResult = await client.license.registerCreativeCommonsAttributionPIL({\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicyAddress: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n});\nccLicenseTermsId = ccLicenseResult.licenseTermsId;",
                  "err": {},
                  "uuid": "68b11b04-3484-48d0-86a3-dea70806e5a4",
                  "parentUUID": "7619bd1c-d988-471e-a6a3-7bd3f56150f4",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should verify the license terms match Creative Commons Attribution specifications",
                  "fullTitle": "License Functions Creative Commons Attribution License Tests should verify the license terms match Creative Commons Attribution specifications",
                  "timedOut": false,
                  "duration": 39,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const licenseTerms = await client.license.getLicenseTerms(ccLicenseTermsId);\n(0, chai_1.expect)(licenseTerms.terms.transferable).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.commercialUse).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesAllowed).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesAttribution).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesReciprocal).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesApproval).to.equal(false);\n(0, chai_1.expect)(licenseTerms.terms.commercialAttribution).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.commercialRevShare).to.equal(0);\n(0, chai_1.expect)(licenseTerms.terms.defaultMintingFee).to.equal(0n);\n(0, chai_1.expect)(licenseTerms.terms.royaltyPolicy).to.equal(generated_1.royaltyPolicyLapAddress[util_1.aeneid]);\n(0, chai_1.expect)(licenseTerms.terms.expiration).to.equal(0n);",
                  "err": {},
                  "uuid": "e741da97-b92d-4ede-b4e4-6d13976b2e24",
                  "parentUUID": "7619bd1c-d988-471e-a6a3-7bd3f56150f4",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should attach Creative Commons Attribution license to an IP",
                  "fullTitle": "License Functions Creative Commons Attribution License Tests should attach Creative Commons Attribution license to an IP",
                  "timedOut": false,
                  "duration": 4502,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const attachResult = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: ccLicenseTermsId,\n});\n(0, chai_1.expect)(attachResult.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(attachResult.success).to.equal(true);\nconst licenseRegistryReadOnlyClient = new generated_1.LicenseRegistryReadOnlyClient(util_1.publicClient);\nconst hasLicense = await licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({\n    ipId: ipId,\n    licenseTemplate: client.ipAsset.licenseTemplateClient.address,\n    licenseTermsId: ccLicenseTermsId,\n});\n(0, chai_1.expect)(hasLicense).to.equal(true);",
                  "err": {},
                  "uuid": "b922854a-44b6-42dd-9722-ce420d0132e1",
                  "parentUUID": "7619bd1c-d988-471e-a6a3-7bd3f56150f4",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should mint CC-BY license tokens with no minting fee",
                  "fullTitle": "License Functions Creative Commons Attribution License Tests should mint CC-BY license tokens with no minting fee",
                  "timedOut": false,
                  "duration": 8742,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Get wallet balance before minting\nconst balanceBefore = await client.getWalletBalance();\n// Predict the minting fee (should be zero for CC-BY)\nconst feePredict = await client.license.predictMintingLicenseFee({\n    licenseTermsId: ccLicenseTermsId,\n    licensorIpId: ipId,\n    amount: 1,\n});\n// CC-BY licenses should have zero minting fee\n(0, chai_1.expect)(feePredict.tokenAmount).to.equal(0n);\nconst mintResult = await client.license.mintLicenseTokens({\n    licenseTermsId: ccLicenseTermsId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 0,\n});\n(0, chai_1.expect)(mintResult.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(mintResult.licenseTokenIds).to.be.a(\"array\");\nconst balanceAfter = await client.getWalletBalance();\n// Verify no fee was charged just gas\n// This checks that any difference is very small (just gas costs)\nconst balanceDiff = balanceBefore - balanceAfter;\nconst gasUsed = mintResult.receipt.gasUsed;\nconst effectiveGasPrice = mintResult.receipt.effectiveGasPrice;\nconst totalGas = gasUsed * effectiveGasPrice;\n// Confirms the balance diff only reflects gas cost, since license fee is zero.\n(0, chai_1.expect)(balanceDiff).to.equal(totalGas); // Small amount for gas",
                  "err": {},
                  "uuid": "f36baacd-9623-440d-9a2b-d123351065ab",
                  "parentUUID": "7619bd1c-d988-471e-a6a3-7bd3f56150f4",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "e741da97-b92d-4ede-b4e4-6d13976b2e24",
                "b922854a-44b6-42dd-9722-ce420d0132e1",
                "f36baacd-9623-440d-9a2b-d123351065ab"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 13283,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "bb6df4b9-b2f0-494c-bdd0-2fc58545601d",
          "title": "nftClient Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts",
          "file": "/test/integration/nftClient.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"nftClient Functions\"",
              "fullTitle": "nftClient Functions \"before all\" hook in \"nftClient Functions\"",
              "timedOut": false,
              "duration": 1,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();",
              "err": {},
              "uuid": "224496ba-9a6f-4367-957c-71b80d73637f",
              "parentUUID": "bb6df4b9-b2f0-494c-bdd0-2fc58545601d",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "d8607baf-13a4-4fd4-b9a6-0491563c7086",
              "title": "createNFTCollection",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts",
              "file": "/test/integration/nftClient.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully create public nft collection with minimal params",
                  "fullTitle": "nftClient Functions createNFTCollection should successfully create public nft collection with minimal params",
                  "timedOut": false,
                  "duration": 4350,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"test-collection\",\n    symbol: \"TEST\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\"string\");\n(0, chai_1.expect)(txData.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "eb647946-55f3-4050-9f69-8d6048e229c7",
                  "parentUUID": "d8607baf-13a4-4fd4-b9a6-0491563c7086",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully create collection with custom mint fee",
                  "fullTitle": "nftClient Functions createNFTCollection should successfully create collection with custom mint fee",
                  "timedOut": false,
                  "duration": 8435,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"paid-collection\",\n    symbol: \"PAID\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFee: 10000000n,\n    mintFeeToken: generated_1.erc20Address[mockData_1.aeneid],\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\"string\");\nspgNftContract = txData.spgNftContract;",
                  "err": {},
                  "uuid": "5ea7b0bc-9eaf-4c84-b2ec-0bdb7b45389d",
                  "parentUUID": "d8607baf-13a4-4fd4-b9a6-0491563c7086",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully create private collection",
                  "fullTitle": "nftClient Functions createNFTCollection should successfully create private collection",
                  "timedOut": false,
                  "duration": 4374,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"private-collection\",\n    symbol: \"PRIV\",\n    maxSupply: 100,\n    isPublicMinting: false, // private minting\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: false, // starts closed\n    contractURI: \"test-uri\",\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "7fa8749a-ec43-4f7b-aff4-675592635d14",
                  "parentUUID": "d8607baf-13a4-4fd4-b9a6-0491563c7086",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully create collection with baseURI",
                  "fullTitle": "nftClient Functions createNFTCollection should successfully create collection with baseURI",
                  "timedOut": false,
                  "duration": 4405,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"uri-collection\",\n    symbol: \"URI\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    baseURI: \"ipfs://QmTest/\",\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "fda3e433-5e00-4284-8846-de41c2d92b49",
                  "parentUUID": "d8607baf-13a4-4fd4-b9a6-0491563c7086",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully create collection with custom owner",
                  "fullTitle": "nftClient Functions createNFTCollection should successfully create collection with custom owner",
                  "timedOut": false,
                  "duration": 4427,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"owned-collection\",\n    symbol: \"OWN\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    owner: util_1.TEST_WALLET_ADDRESS,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "37fc67c2-1f99-49f7-bda0-650057c21bf1",
                  "parentUUID": "d8607baf-13a4-4fd4-b9a6-0491563c7086",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully get encoded transaction data",
                  "fullTitle": "nftClient Functions createNFTCollection should successfully get encoded transaction data",
                  "timedOut": false,
                  "duration": 0,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const txData = await client.nftClient.createNFTCollection({\n    name: \"encoded-collection\",\n    symbol: \"ENC\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    txOptions: {\n        encodedTxDataOnly: true,\n    },\n});\n(0, chai_1.expect)(txData.encodedTxData).to.be.an(\"object\");\n(0, chai_1.expect)(txData.encodedTxData?.data).to.be.a(\"string\");\n(0, chai_1.expect)(txData.encodedTxData?.to).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "67036eca-f67e-42c6-92e6-67c45441139d",
                  "parentUUID": "d8607baf-13a4-4fd4-b9a6-0491563c7086",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with invalid mint fee token",
                  "fullTitle": "nftClient Functions createNFTCollection should fail with invalid mint fee token",
                  "timedOut": false,
                  "duration": 2,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.nftClient.createNFTCollection({\n    name: \"invalid-fee-collection\",\n    symbol: \"INV\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFee: 1000000000000000000n,\n    mintFeeToken: \"0x0000000000000000000000000000000000000000\",\n})).to.be.rejectedWith(\"Invalid mint fee token address\");",
                  "err": {},
                  "uuid": "fd03ef41-df1d-44c1-981c-f19428d90e02",
                  "parentUUID": "d8607baf-13a4-4fd4-b9a6-0491563c7086",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "eb647946-55f3-4050-9f69-8d6048e229c7",
                "5ea7b0bc-9eaf-4c84-b2ec-0bdb7b45389d",
                "7fa8749a-ec43-4f7b-aff4-675592635d14",
                "fda3e433-5e00-4284-8846-de41c2d92b49",
                "37fc67c2-1f99-49f7-bda0-650057c21bf1",
                "67036eca-f67e-42c6-92e6-67c45441139d",
                "fd03ef41-df1d-44c1-981c-f19428d90e02"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 25993,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "24070adf-04dd-464b-b81b-dce7d1741068",
              "title": "Mint Fee",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts",
              "file": "/test/integration/nftClient.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully get mint fee token",
                  "fullTitle": "nftClient Functions Mint Fee should successfully get mint fee token",
                  "timedOut": false,
                  "duration": 35,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const mintFeeToken = await client.nftClient.getMintFeeToken(spgNftContract);\n(0, chai_1.expect)(mintFeeToken).to.equal(generated_1.erc20Address[mockData_1.aeneid]);",
                  "err": {},
                  "uuid": "93f6ae3b-5fee-4a2a-ab83-fb2313c66ebc",
                  "parentUUID": "24070adf-04dd-464b-b81b-dce7d1741068",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should successfully get mint fee",
                  "fullTitle": "nftClient Functions Mint Fee should successfully get mint fee",
                  "timedOut": false,
                  "duration": 44,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const mintFee = await client.nftClient.getMintFee(spgNftContract);\n(0, chai_1.expect)(mintFee).to.equal(10000000n);",
                  "err": {},
                  "uuid": "facbe230-379b-4c48-a7b1-608803157511",
                  "parentUUID": "24070adf-04dd-464b-b81b-dce7d1741068",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "93f6ae3b-5fee-4a2a-ab83-fb2313c66ebc",
                "facbe230-379b-4c48-a7b1-608803157511"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 79,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "dd3d3362-704f-4ef2-b813-2f4c0467b2a1",
              "title": "set and get tokenURI",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts",
              "file": "/test/integration/nftClient.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully set token URI",
                  "fullTitle": "nftClient Functions set and get tokenURI should successfully set token URI",
                  "timedOut": false,
                  "duration": 13144,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Setup: Approve the contract for ERC20 transfers\nconst erc20Client = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[mockData_1.aeneid]);\nconst txHash = await erc20Client.approve(spgNftContract, viem_1.maxUint256);\nawait util_1.publicClient.waitForTransactionReceipt({ hash: txHash });\n// Mint a new token with initial metadata\nconst tokenId = await (0, util_1.mintBySpg)(spgNftContract, \"ipfs://QmTest/\");\n(0, chai_1.expect)(tokenId).to.be.a(\"bigint\");\n// Update the token URI\nconst updatedMetadata = \"ipfs://QmUpdated/metadata.json\";\nconst result = await client.nftClient.setTokenURI({\n    tokenId: tokenId,\n    tokenURI: updatedMetadata,\n    spgNftContract,\n});\n// Verify the transaction\n(0, chai_1.expect)(result.txHash).to.be.a(\"string\");\n// Verification that the URI was updated\nconst tokenURI = await client.nftClient.getTokenURI({\n    tokenId,\n    spgNftContract,\n});\n(0, chai_1.expect)(tokenURI).to.equal(updatedMetadata);",
                  "err": {},
                  "uuid": "61e4c774-77ee-4aa3-b976-1a63c9e32159",
                  "parentUUID": "dd3d3362-704f-4ef2-b813-2f4c0467b2a1",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "61e4c774-77ee-4aa3-b976-1a63c9e32159"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 13144,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "54c14a72-bbc1-4d36-9151-994657e83285",
              "title": "Error Cases",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts",
              "file": "/test/integration/nftClient.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "fails with invalid token ID",
                  "fullTitle": "nftClient Functions Error Cases fails with invalid token ID",
                  "timedOut": false,
                  "duration": 4404,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const erc20Client = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[mockData_1.aeneid]);\nconst txHash = await erc20Client.approve(spgNftContract, viem_1.maxUint256);\nawait util_1.publicClient.waitForTransactionReceipt({ hash: txHash });\nconst invalidTokenId = 999999999999999n;\nconst updatedMetadata = \"ipfs://QmUpdated/metadata.json\";\nawait (0, chai_1.expect)(client.nftClient.setTokenURI({\n    tokenId: invalidTokenId,\n    tokenURI: updatedMetadata,\n    spgNftContract,\n})).to.be.rejectedWith(\"Failed to set token URI\");",
                  "err": {},
                  "uuid": "3a0354ec-3386-4410-a8ff-e548819e2c23",
                  "parentUUID": "54c14a72-bbc1-4d36-9151-994657e83285",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "3a0354ec-3386-4410-a8ff-e548819e2c23"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 4404,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "e1c4d5d0-d148-4cb5-b626-e6a9c30aa9d3",
          "title": "Permission Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts",
          "file": "/test/integration/permission.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Permission Functions\"",
              "fullTitle": "Permission Functions \"before all\" hook in \"Permission Functions\"",
              "timedOut": false,
              "duration": 8800,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = response.ipId;",
              "err": {},
              "uuid": "f669ab82-1e88-49f2-9167-a9c6d1e96ec4",
              "parentUUID": "e1c4d5d0-d148-4cb5-b626-e6a9c30aa9d3",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "8a006330-9eae-413c-a4c3-2e90a70bd134",
              "title": "Single Permission Operations",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts",
              "file": "/test/integration/permission.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should set permission successfully",
                  "fullTitle": "Permission Functions Single Permission Operations should set permission successfully",
                  "timedOut": false,
                  "duration": 8437,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.permission.setPermission({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n    func: \"function setAll(address,string,bytes32,bytes32)\",\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(response.success).to.equal(true);",
                  "err": {},
                  "uuid": "f06c2ee5-0fee-416b-aa63-0c59ece624b1",
                  "parentUUID": "8a006330-9eae-413c-a4c3-2e90a70bd134",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should set all permissions successfully",
                  "fullTitle": "Permission Functions Single Permission Operations should set all permissions successfully",
                  "timedOut": false,
                  "duration": 4392,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.permission.setAllPermissions({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    permission: permission_1.AccessPermission.ALLOW,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(response.success).to.equal(true);",
                  "err": {},
                  "uuid": "2b042089-4d9a-43e1-a8e4-3a6cc48b9a25",
                  "parentUUID": "8a006330-9eae-413c-a4c3-2e90a70bd134",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "f06c2ee5-0fee-416b-aa63-0c59ece624b1",
                "2b042089-4d9a-43e1-a8e4-3a6cc48b9a25"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 12829,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "90216b59-93cb-43d5-bb7b-af3f1b70ae4d",
              "title": "Permission Signatures",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts",
              "file": "/test/integration/permission.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should create set permission signature",
                  "fullTitle": "Permission Functions Permission Signatures should create set permission signature",
                  "timedOut": false,
                  "duration": 4486,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.permission.createSetPermissionSignature({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    func: \"function setAll(address,string,bytes32,bytes32)\",\n    permission: permission_1.AccessPermission.ALLOW,\n    deadline: 60000n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(response.success).to.equal(true);",
                  "err": {},
                  "uuid": "b7271cc2-7891-4f97-9195-a671d859c83a",
                  "parentUUID": "90216b59-93cb-43d5-bb7b-af3f1b70ae4d",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "b7271cc2-7891-4f97-9195-a671d859c83a"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 4486,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "9403cd6e-aac7-4cff-a3f7-e5351f09eb8b",
              "title": "Batch Operations",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts",
              "file": "/test/integration/permission.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should set batch permissions successfully",
                  "fullTitle": "Permission Functions Batch Operations should set batch permissions successfully",
                  "timedOut": false,
                  "duration": 4432,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.permission.setBatchPermissions({\n    permissions: [\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.ALLOW,\n            func: \"function setAll(address,string,bytes32,bytes32)\",\n        },\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.DENY,\n            func: \"function freezeMetadata(address)\",\n        },\n    ],\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(response.success).to.equal(true);",
                  "err": {},
                  "uuid": "d65337e3-e7c7-457a-a850-379e6e5f0620",
                  "parentUUID": "9403cd6e-aac7-4cff-a3f7-e5351f09eb8b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should create batch permission signature",
                  "fullTitle": "Permission Functions Batch Operations should create batch permission signature",
                  "timedOut": false,
                  "duration": 8541,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.permission.createBatchPermissionSignature({\n    ipId: ipId,\n    permissions: [\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.ALLOW,\n            func: \"function setAll(address,string,bytes32,bytes32)\",\n        },\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.DENY,\n            func: \"function freezeMetadata(address)\",\n        },\n    ],\n    deadline: 60000n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");\n(0, chai_1.expect)(response.success).to.equal(true);",
                  "err": {},
                  "uuid": "7875fa90-a1c7-40a8-8498-25ad4834781f",
                  "parentUUID": "9403cd6e-aac7-4cff-a3f7-e5351f09eb8b",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "d65337e3-e7c7-457a-a850-379e6e5f0620",
                "7875fa90-a1c7-40a8-8498-25ad4834781f"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 12973,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "282559e3-7889-4fef-b939-76ab32686a1c",
              "title": "Error Cases",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts",
              "file": "/test/integration/permission.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should fail when setting permission for unregistered IP",
                  "fullTitle": "Permission Functions Error Cases should fail when setting permission for unregistered IP",
                  "timedOut": false,
                  "duration": 35,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const unregisteredIpId = \"0x1234567890123456789012345678901234567890\";\nawait (0, chai_1.expect)(client.permission.setPermission({\n    ipId: unregisteredIpId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n})).to.be.rejectedWith(`IP id with ${unregisteredIpId} is not registered.`);",
                  "err": {},
                  "uuid": "0e79308d-ca2f-4025-aa83-1309dbc5e6b0",
                  "parentUUID": "282559e3-7889-4fef-b939-76ab32686a1c",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail with invalid function signature",
                  "fullTitle": "Permission Functions Error Cases should fail with invalid function signature",
                  "timedOut": false,
                  "duration": 47,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(client.permission.setPermission({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n    func: \"invalid_function_signature\",\n})).to.be.rejected;",
                  "err": {},
                  "uuid": "e6497549-abe0-45ea-9042-c0e88b588e69",
                  "parentUUID": "282559e3-7889-4fef-b939-76ab32686a1c",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "0e79308d-ca2f-4025-aa83-1309dbc5e6b0",
                "e6497549-abe0-45ea-9042-c0e88b588e69"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 82,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "cbb7aa13-7df7-4f72-b53b-530df2008106",
          "title": "Royalty Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts",
          "file": "/test/integration/royalty.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Royalty Functions\"",
              "fullTitle": "Royalty Functions \"before all\" hook in \"Royalty Functions\"",
              "timedOut": false,
              "duration": 31227,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();\nmockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\n// Setup initial state\nparentIpId = await getIpId();\nchildIpId = await getIpId();\nlicenseTermsId = await getCommercialPolicyId();\n// Setup relationships and approvals\nawait attachLicenseTerms(parentIpId, licenseTermsId);\nawait mockERC20.mint(util_1.TEST_WALLET_ADDRESS, (0, viem_1.parseEther)(\"10\"));\nawait mockERC20.approve(generated_1.royaltyModuleAddress[util_1.aeneid], viem_1.maxUint256);\n// Register derivative\nawait client.ipAsset.registerDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [licenseTermsId],\n    maxMintingFee: \"0\",\n    maxRts: \"0\",\n    maxRevenueShare: \"0\",\n});",
              "err": {},
              "uuid": "8c2916a8-f56d-48ad-8c21-76344d6c96fb",
              "parentUUID": "cbb7aa13-7df7-4f72-b53b-530df2008106",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "ea9ba53b-7b87-4025-ae26-c8530ee43eb9",
              "title": "Royalty Payments",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts",
              "file": "/test/integration/royalty.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should successfully pay royalty on behalf",
                  "fullTitle": "Royalty Functions Royalty Payments should successfully pay royalty on behalf",
                  "timedOut": false,
                  "duration": 4479,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: parentIpId,\n    payerIpId: childIpId,\n    token: generated_1.erc20Address[util_1.aeneid],\n    amount: 1,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");",
                  "err": {},
                  "uuid": "470a66ba-452b-433e-b98d-11ca5f75d89a",
                  "parentUUID": "ea9ba53b-7b87-4025-ae26-c8530ee43eb9",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should auto convert IP to WIP when paying WIP on behalf",
                  "fullTitle": "Royalty Functions Royalty Payments should auto convert IP to WIP when paying WIP on behalf",
                  "timedOut": false,
                  "duration": 4625,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const balanceBefore = await client.getWalletBalance();\nconst response = await client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: parentIpId,\n    payerIpId: childIpId,\n    token: common_1.WIP_TOKEN_ADDRESS,\n    amount: 100n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\"string\");\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 100n));",
                  "err": {},
                  "uuid": "752db21e-89ee-4bd5-b234-0f5ac9aeb03c",
                  "parentUUID": "ea9ba53b-7b87-4025-ae26-c8530ee43eb9",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail to pay royalty with unregistered receiver",
                  "fullTitle": "Royalty Functions Royalty Payments should fail to pay royalty with unregistered receiver",
                  "timedOut": false,
                  "duration": 41,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const unregisteredIpId = \"0x1234567890123456789012345678901234567890\";\nawait (0, chai_1.expect)(client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: unregisteredIpId,\n    payerIpId: childIpId,\n    token: generated_1.erc20Address[util_1.aeneid],\n    amount: 10 * 10 ** 2,\n})).to.be.rejectedWith(`The receiver IP with id ${unregisteredIpId} is not registered.`);",
                  "err": {},
                  "uuid": "8297b8ed-b93a-41d7-b074-682f2fba3a58",
                  "parentUUID": "ea9ba53b-7b87-4025-ae26-c8530ee43eb9",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow the royalty vault to transfer its native tokens to a wallet address",
                  "fullTitle": "Royalty Functions Royalty Payments should allow the royalty vault to transfer its native tokens to a wallet address",
                  "timedOut": false,
                  "duration": 4609,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const royaltyVaultAddress = await client.royalty.getRoyaltyVaultAddress(parentIpId);\nconst royaltyVaultToken = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, royaltyVaultAddress);\nconst transferAmount = BigInt(10 * 10 ** 6); // 10 million tokens\n// Check initial balances of the vault token\nconst initialTargetBalance = await royaltyVaultToken.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst initialParentBalance = await royaltyVaultToken.balanceOf(parentIpId);\n(0, chai_1.expect)(Number(initialParentBalance)).greaterThanOrEqual(Number(transferAmount));\nconst transferResult = await client.ipAccount.execute({\n    to: royaltyVaultAddress,\n    value: 0,\n    ipId: parentIpId,\n    data: (0, viem_1.encodeFunctionData)({\n        abi: viem_1.erc20Abi,\n        functionName: \"transfer\",\n        args: [util_1.TEST_WALLET_ADDRESS, transferAmount],\n    }),\n});\n(0, chai_1.expect)(transferResult.txHash).to.be.a(\"string\");\n// Check final balances to confirm the transfer worked\nconst finalTargetBalance = await royaltyVaultToken.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst finalParentBalance = await royaltyVaultToken.balanceOf(parentIpId);\n(0, chai_1.expect)(finalTargetBalance).to.equal(initialTargetBalance + transferAmount, \"Target wallet balance should increase by the transfer amount\");\n(0, chai_1.expect)(Number(finalParentBalance)).equal(Number(initialParentBalance - transferAmount));",
                  "err": {},
                  "uuid": "3aa2053a-aeec-4b28-9751-b24858b8e7c0",
                  "parentUUID": "ea9ba53b-7b87-4025-ae26-c8530ee43eb9",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "470a66ba-452b-433e-b98d-11ca5f75d89a",
                "752db21e-89ee-4bd5-b234-0f5ac9aeb03c",
                "8297b8ed-b93a-41d7-b074-682f2fba3a58",
                "3aa2053a-aeec-4b28-9751-b24858b8e7c0"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 13754,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "8ac92391-600b-4de9-a404-c60c0b3ed545",
              "title": "Revenue Queries",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts",
              "file": "/test/integration/royalty.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should return claimable revenue amount",
                  "fullTitle": "Royalty Functions Revenue Queries should return claimable revenue amount",
                  "timedOut": false,
                  "duration": 109,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.royalty.claimableRevenue({\n    ipId: parentIpId,\n    claimer: util_1.TEST_WALLET_ADDRESS,\n    token: generated_1.erc20Address[util_1.aeneid],\n});\n(0, chai_1.expect)(response).to.be.a(\"bigint\");",
                  "err": {},
                  "uuid": "c227e528-bc85-4ccf-8586-cb43b3ca3550",
                  "parentUUID": "8ac92391-600b-4de9-a404-c60c0b3ed545",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should fail to get royalty vault address for unregistered IP",
                  "fullTitle": "Royalty Functions Revenue Queries should fail to get royalty vault address for unregistered IP",
                  "timedOut": false,
                  "duration": 38,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const unregisteredIpId = \"0x1234567890123456789012345678901234567890\";\nawait (0, chai_1.expect)(client.royalty.getRoyaltyVaultAddress(unregisteredIpId)).to.be.rejectedWith(`The royalty vault IP with id ${unregisteredIpId} is not registered.`);",
                  "err": {},
                  "uuid": "60a1abe8-0643-4554-bf8b-f0aea21c16fe",
                  "parentUUID": "8ac92391-600b-4de9-a404-c60c0b3ed545",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "c227e528-bc85-4ccf-8586-cb43b3ca3550",
                "60a1abe8-0643-4554-bf8b-f0aea21c16fe"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 147,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "e96440ef-8a23-4bfd-b4d1-181ce7df2eb7",
              "title": "Error Cases",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts",
              "file": "/test/integration/royalty.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should return zero for claimable revenue with invalid token",
                  "fullTitle": "Royalty Functions Error Cases should return zero for claimable revenue with invalid token",
                  "timedOut": false,
                  "duration": 112,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const response = await client.royalty.claimableRevenue({\n    ipId: parentIpId,\n    claimer: util_1.TEST_WALLET_ADDRESS,\n    token: \"0x0000000000000000000000000000000000000000\",\n});\n(0, chai_1.expect)(response).to.equal(0n);",
                  "err": {},
                  "uuid": "fb530f9d-5223-4d87-b7a1-113d085dd2f3",
                  "parentUUID": "e96440ef-8a23-4bfd-b4d1-181ce7df2eb7",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "fb530f9d-5223-4d87-b7a1-113d085dd2f3"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 112,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "0464e127-4623-48eb-a2fc-765ff6914829",
              "title": "ClaimAllRevenue With WIP",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts",
              "file": "/test/integration/royalty.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"ClaimAllRevenue With WIP\"",
                  "fullTitle": "Royalty Functions ClaimAllRevenue With WIP \"before all\" hook in \"ClaimAllRevenue With WIP\"",
                  "timedOut": false,
                  "duration": 23775,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// set up\n// minting Fee: 100, 10% LAP rev share, A expect to get 120 WIP\n// A -> B -> C -> D\nconst txData = await client.nftClient.createNFTCollection({\n    name: \"free-collection\",\n    symbol: \"FREE\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: viem_1.zeroAddress,\n});\nspgNftContract = txData.spgNftContract;\nconst retA = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 100n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 100n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nipA = retA.ipId;\nlicenseId = retA.licenseTermsIds[0];\nconst retB = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipA],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\nipB = retB.ipId;\nconst retC = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipB],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\nipC = retC.ipId;\nawait client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipC],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});",
                  "err": {},
                  "uuid": "aa35e301-2358-4e41-a51c-9fba16d8acde",
                  "parentUUID": "0464e127-4623-48eb-a2fc-765ff6914829",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should claim all revenue",
                  "fullTitle": "Royalty Functions ClaimAllRevenue With WIP should claim all revenue",
                  "timedOut": false,
                  "duration": 13132,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const ret = await client.royalty.claimAllRevenue({\n    ancestorIpId: ipA,\n    claimer: ipA,\n    childIpIds: [ipB, ipC],\n    royaltyPolicies: [generated_1.royaltyPolicyLapAddress[util_1.aeneid], generated_1.royaltyPolicyLapAddress[util_1.aeneid]],\n    currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n});\n(0, chai_1.expect)(ret.txHashes).to.be.an(\"array\");\n(0, chai_1.expect)(ret.claimedTokens[0].amount).to.equal(120n);",
                  "err": {},
                  "uuid": "01dc3eb5-bc0e-4dd7-a9e1-44da69c27651",
                  "parentUUID": "0464e127-4623-48eb-a2fc-765ff6914829",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "01dc3eb5-bc0e-4dd7-a9e1-44da69c27651"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 13132,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "1ce7b4b8-7d0f-4c96-80db-fecd6efea838",
              "title": "BatchClaimAllRevenue With WIP",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts",
              "file": "/test/integration/royalty.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before all\" hook in \"BatchClaimAllRevenue With WIP\"",
                  "fullTitle": "Royalty Functions BatchClaimAllRevenue With WIP \"before all\" hook in \"BatchClaimAllRevenue With WIP\"",
                  "timedOut": false,
                  "duration": 41946,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nanotherAddress = derivedClient.address;\nawait client.wipClient.deposit({\n    amount: (0, viem_1.parseEther)(\"5\"),\n});\n/**\n * Asset Hierarchy Setup for Revenue Collection Tests\n *\n * Overview:\n * This test setup creates two distinct IP asset hierarchies (IpA and IpB) to demonstrate\n * different revenue collection scenarios using LAP (Licensing Agreement Policy) and LRP\n * (Licensing Revenue Policy) respectively.\n *\n * IpA Hierarchy (LAP - Licensing Agreement Policy):                           IpB Hierarchy (LRP - Licensing Revenue Policy):\n * ┌─────────────────────────────────────────────────────────────┐          ┌─────────────────────────────────────────────────────────────┐\n * │ IpA (Parent) - Total Expected Revenue: 130 WIP              │          │ IpB (Parent) - Total Expected Revenue: 330 WIP              │\n * ├─────────────────────────────────────────────────────────────┤          ├─────────────────────────────────────────────────────────────┤\n * │ Revenue Sources:                                            │          │ Revenue Sources:                                            │\n * │ ├── Minting Fee: 100 WIP                                    │          │ ├── Minting Fee: 150 WIP                                    │\n * │ ├── Revenue Share (ipA2->ipA1): 10 WIP (10% LAP)            │          │ ├── LRP Revenue Share: 10%                                  │\n * │ ├── Revenue Share (ipA3->ipA2): 10 WIP (10% LAP)            │          │ ├── Total Revenue: 330 WIP                                  │\n * │ └── Direct Payment (ipA3): 10 WIP (10% LAP)                 │          │    └── From ipB1: 150 WIP + 10% revenue share               │\n * │                                                             │          │    └── From ipB2: 150 WIP + 10% revenue share               │\n * │                                                             │          │                                                             │\n * | Ownership Distribution:                                     │          |                                                             │\n * │ ├── Wallet Address: 50%  65 WIP                             │          │ Revenue Flow:                                               │\n * │ └── Another Address: 50% 65 WIP                             │          │ ipB3                                                        │\n * │                                                             │          │ ├── ipB1 ─┐                                                 │\n * │ Revenue Flow:                                               │          │ └── ipB2 ─┴──> ipB (collects 330 WIP)                       │\n * │ ipA3                                                        │          │                                                             │\n * │  └──> ipA2 (20% LAP) ──> ipA1 (10% LAP) ──> ipA             │          │                                                             │\n * │       └──> Direct Payment: 100 WIP                          │          │                                                             │\n * └─────────────────────────────────────────────────────────────┘          └─────────────────────────────────────────────────────────────┘\n */\nconst txData = await client.nftClient.createNFTCollection({\n    name: \"free-collection\",\n    symbol: \"FREE\",\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \"test-uri\",\n    mintFeeRecipient: viem_1.zeroAddress,\n});\nspgNftContract = txData.spgNftContract;\n// 1. Register ipA\nconst ret1A = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 100n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 100n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 50,\n        },\n        {\n            recipient: anotherAddress,\n            percentage: 50,\n        },\n    ],\n});\nipA = ret1A.ipId;\nlicenseId = ret1A.licenseTermsIds[0];\n// 2. Register ipB\nconst ret1B = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n                defaultMintingFee: 150n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \"\",\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 150n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nipB = ret1B.ipId;\nlicenseId1 = ret1B.licenseTermsIds[0];\n// 3. Register ipA1 from ipA and ipB1 from ipB\nconst { results: ret2 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB],\n                licenseTermsIds: [licenseId1],\n            },\n        },\n    ],\n});\nipA1 = ret2[0].ipId;\nipB1 = ret2[1].ipId;\n// 4. Register ipA2 from ipA1 and ipB2 from ipB\nconst { results: ret3 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA1],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB],\n                licenseTermsIds: [licenseId1],\n            },\n        },\n    ],\n});\nipA2 = ret3[0].ipId;\nipB2 = ret3[1].ipId;\n// 5. Register ipA3 from ipA2 and ipB3 from ipB1 and ipB2\nconst { results: ret4 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA2],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB1, ipB2],\n                licenseTermsIds: [licenseId1, licenseId1],\n            },\n        },\n    ],\n});\nipA3 = ret4[0].ipId;\n// 6. Pay royalty on behalf of ipA2 to ipA3\nawait client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: ipA2,\n    payerIpId: ipA3,\n    token: common_1.WIP_TOKEN_ADDRESS,\n    amount: 100n,\n});\nconst balance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nawait client.wipClient.withdraw({\n    amount: balance,\n});",
                  "err": {},
                  "uuid": "beac45cd-9789-44f5-a66c-35bb71909942",
                  "parentUUID": "1ce7b4b8-7d0f-4c96-80db-fecd6efea838",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should batch claim all revenue",
                  "fullTitle": "Royalty Functions BatchClaimAllRevenue With WIP should batch claim all revenue",
                  "timedOut": false,
                  "duration": 13359,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const anotherAddressWipBalanceBefore = await client.wipClient.balanceOf(anotherAddress);\nconst result = await client.royalty.batchClaimAllRevenue({\n    ancestorIps: [\n        {\n            ipId: ipA,\n            claimer: util_1.TEST_WALLET_ADDRESS,\n            childIpIds: [ipA1, ipA2],\n            royaltyPolicies: [generated_1.royaltyPolicyLapAddress[util_1.aeneid], generated_1.royaltyPolicyLapAddress[util_1.aeneid]],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n        },\n        {\n            ipId: ipA,\n            claimer: anotherAddress,\n            childIpIds: [],\n            royaltyPolicies: [],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS],\n        },\n        {\n            ipId: ipB,\n            claimer: ipB,\n            childIpIds: [ipB1, ipB2],\n            royaltyPolicies: [generated_1.royaltyPolicyLrpAddress[util_1.aeneid], generated_1.royaltyPolicyLrpAddress[util_1.aeneid]],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n        },\n    ],\n});\nconst anotherAddressWipBalanceAfter = await client.wipClient.balanceOf(anotherAddress);\nconst walletWipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(result.txHashes).to.be.an(\"array\");\n(0, chai_1.expect)(result.claimedTokens[0].amount).to.equal(65n);\n(0, chai_1.expect)(result.claimedTokens[1].amount).to.equal(65n);\n(0, chai_1.expect)(result.claimedTokens[2].amount).to.equal(330n);\n(0, chai_1.expect)(walletWipBalanceAfter).to.equal(0n);\n(0, chai_1.expect)(anotherAddressWipBalanceAfter).to.equal(anotherAddressWipBalanceBefore + 65n);\n// Note: The final wallet balance cannot be precisely calculated because:\n// The test involves multiple transactions (claimAllRevenue, token transfers, etc.)\n// batchClaimAllRevenue only returns receipts for claimAllRevenue calls\n// Additional gas costs and token transfers occur outside the returned receipts",
                  "err": {},
                  "uuid": "9f5ed613-09e2-43f4-880d-d43fd18b61d8",
                  "parentUUID": "1ce7b4b8-7d0f-4c96-80db-fecd6efea838",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "9f5ed613-09e2-43f4-880d-d43fd18b61d8"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 13359,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        },
        {
          "uuid": "41e10014-3110-4ca2-834e-a361518b9475",
          "title": "WIP Functions",
          "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts",
          "file": "/test/integration/wip.test.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"WIP Functions\"",
              "fullTitle": "WIP Functions \"before all\" hook in \"WIP Functions\"",
              "timedOut": false,
              "duration": 3,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "client = (0, util_1.getStoryClient)();",
              "err": {},
              "uuid": "2726d585-51b5-495a-8343-2d5d0d1a7bc2",
              "parentUUID": "41e10014-3110-4ca2-834e-a361518b9475",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "7e34a141-d395-492c-b4e8-d97b0d40be8b",
              "title": "deposit",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts",
              "file": "/test/integration/wip.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should deposit 0.01 WIP",
                  "fullTitle": "WIP Functions deposit should deposit 0.01 WIP",
                  "timedOut": false,
                  "duration": 4499,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const ipAmt = (0, viem_1.parseEther)(\"0.01\");\nconst balanceBefore = await client.getWalletBalance();\nconst wipBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst rsp = await client.wipClient.deposit({\n    amount: ipAmt,\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\"string\");\nconst balanceAfter = await client.getWalletBalance();\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.equal(wipBefore + ipAmt);\nconst gasCost = rsp.receipt.gasUsed * rsp.receipt.effectiveGasPrice;\n(0, chai_1.expect)(balanceAfter).to.equal(balanceBefore - ipAmt - gasCost);",
                  "err": {},
                  "uuid": "d7905fc7-0f80-45a7-9667-b190158eb9fd",
                  "parentUUID": "7e34a141-d395-492c-b4e8-d97b0d40be8b",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "d7905fc7-0f80-45a7-9667-b190158eb9fd"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 4499,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "5403ca80-d494-4227-809f-3a208e460936",
              "title": "transfer",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts",
              "file": "/test/integration/wip.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should transfer WIP",
                  "fullTitle": "WIP Functions transfer should transfer WIP",
                  "timedOut": false,
                  "duration": 4338,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const rsp = await client.wipClient.transfer({\n    to: util_1.TEST_WALLET_ADDRESS,\n    amount: (0, viem_1.parseEther)(\"0.01\"),\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\"string\");\n//Due to approve cannot approve msy.sender, so skip transferFrom test",
                  "err": {},
                  "uuid": "3a7d4a51-0fb2-4be3-b00a-c5206c717a7c",
                  "parentUUID": "5403ca80-d494-4227-809f-3a208e460936",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "3a7d4a51-0fb2-4be3-b00a-c5206c717a7c"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 4338,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            },
            {
              "uuid": "943c8864-5896-4114-baed-c53b9542abf5",
              "title": "withdraw",
              "fullFile": "/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts",
              "file": "/test/integration/wip.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should withdrawal WIP",
                  "fullTitle": "WIP Functions withdraw should withdrawal WIP",
                  "timedOut": false,
                  "duration": 4489,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const balanceBefore = await client.getWalletBalance();\nconst wipBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst rsp = await client.wipClient.withdraw({\n    amount: wipBefore,\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\"string\");\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.equal(0n);\nconst balanceAfter = await client.getWalletBalance();\nconst gasCost = rsp.receipt.gasUsed * rsp.receipt.effectiveGasPrice;\n(0, chai_1.expect)(balanceAfter).to.equal(balanceBefore + wipBefore - gasCost);",
                  "err": {},
                  "uuid": "eeb703de-756c-4614-91ec-55b88283a7cc",
                  "parentUUID": "943c8864-5896-4114-baed-c53b9542abf5",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "eeb703de-756c-4614-91ec-55b88283a7cc"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 4489,
              "root": false,
              "rootEmpty": false,
              "_timeout": 300000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 300000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 300000
    }
  ],
  "meta": {
    "mocha": {
      "version": "10.8.2"
    },
    "mochawesome": {
      "options": {
        "quiet": false,
        "reportFilename": "mochawesome",
        "saveHtml": true,
        "saveJson": true,
        "consoleReporter": "spec",
        "useInlineDiffs": false,
        "code": true
      },
      "version": "7.1.3"
    },
    "marge": {
      "options": null,
      "version": "6.2.0"
    }
  }
}