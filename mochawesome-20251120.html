<!doctype html>
<html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Mochawesome Report</title><link rel="stylesheet" href="assets/app.css"/></head><body data-raw="{&quot;stats&quot;:{&quot;suites&quot;:61,&quot;tests&quot;:182,&quot;passes&quot;:182,&quot;pending&quot;:0,&quot;failures&quot;:0,&quot;start&quot;:&quot;2025-11-20T08:53:41.872Z&quot;,&quot;end&quot;:&quot;2025-11-20T09:38:42.590Z&quot;,&quot;duration&quot;:2700718,&quot;testsRegistered&quot;:182,&quot;passPercent&quot;:100,&quot;pendingPercent&quot;:0,&quot;other&quot;:0,&quot;hasOther&quot;:false,&quot;skipped&quot;:0,&quot;hasSkipped&quot;:false},&quot;results&quot;:[{&quot;uuid&quot;:&quot;101b8d8f-5158-4310-9a39-f2dae4d509dd&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;0f27de93-5ce9-464f-ad3c-d89e9bae283f&quot;,&quot;title&quot;:&quot;Dispute Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/dispute.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Dispute Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions \&quot;before all\&quot; hook in \&quot;Dispute Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14553,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;clientA = (0, util_1.getStoryClient)();\nconst derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nclientB = derivedClient.clientB;\nminimumBond = await (0, oov3_1.getMinimumBond)(util_1.publicClient, new generated_1.ArbitrationPolicyUmaClient(util_1.publicClient, util_1.walletClient), src_1.WIP_TOKEN_ADDRESS);\nconst txData = await clientA.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nconst nftContract = txData.spgNftContract;\nipIdB = (await clientB.ipAsset.mintAndRegisterIp({\n    spgNftContract: nftContract,\n})).ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b5e7eced-1ab1-4496-a0af-7ba0a1a72677&quot;,&quot;parentUUID&quot;:&quot;0f27de93-5ce9-464f-ad3c-d89e9bae283f&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;it should not cancel a dispute (yet)&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions it should not cancel a dispute (yet)&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10702,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const raiseResponse = await clientA.dispute.raiseDispute({\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 2592000,\n    bond: minimumBond,\n});\nawait (0, chai_1.expect)(clientA.dispute.cancelDispute({\n    disputeId: raiseResponse.disputeId,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f051c622-127e-41ff-a5ca-71eb7f4e1cb5&quot;,&quot;parentUUID&quot;:&quot;0f27de93-5ce9-464f-ad3c-d89e9bae283f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;71ed6ebe-360f-4a7a-8ae0-58f6e2ded487&quot;,&quot;title&quot;:&quot;raiseDispute and counter dispute&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/dispute.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should raise a dispute&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should raise a dispute&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10476,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const raiseDisputeRequest = {\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 2592000,\n    bond: minimumBond,\n};\nconst response = await clientA.dispute.raiseDispute(raiseDisputeRequest);\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.disputeId).to.be.a(\&quot;bigint\&quot;);\ndisputeId = response.disputeId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;35182ca1-a790-40c6-9f42-d0443d983a4a&quot;,&quot;parentUUID&quot;:&quot;71ed6ebe-360f-4a7a-8ae0-58f6e2ded487&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should validate all enum values defined in DisputeTargetTag&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should validate all enum values defined in DisputeTargetTag&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:442,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const allTags = Object.values(src_1.DisputeTargetTag);\nfor (const tag of allTags) {\n    const tagHex = (0, viem_1.toHex)(tag, { size: 32 });\n    const { allowed } = await clientA.dispute.disputeModuleClient.isWhitelistedDisputeTag({\n        tag: tagHex,\n    });\n    if (tag === src_1.DisputeTargetTag.IN_DISPUTE) {\n        (0, chai_1.expect)(allowed).equal(false);\n    }\n    else {\n        (0, chai_1.expect)(allowed).equal(true);\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9f839dc7-9c8b-4dc6-b298-71c2eaf20bcb&quot;,&quot;parentUUID&quot;:&quot;71ed6ebe-360f-4a7a-8ae0-58f6e2ded487&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should raise disputes with different DisputeTargetTag enum values&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should raise disputes with different DisputeTargetTag enum values&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:42908,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const allTags = Object.values(src_1.DisputeTargetTag);\nfor (const tag of allTags) {\n    const raiseDisputeRequest = {\n        targetIpId: ipIdB,\n        cid: await generateCID(),\n        targetTag: tag,\n        liveness: 2592000,\n        bond: minimumBond,\n    };\n    if (tag === src_1.DisputeTargetTag.IN_DISPUTE) {\n        await (0, chai_1.expect)(clientA.dispute.raiseDispute(raiseDisputeRequest)).to.be.rejectedWith(\&quot;The target tag IN_DISPUTE is not whitelisted\&quot;);\n    }\n    else {\n        const response = await clientA.dispute.raiseDispute(raiseDisputeRequest);\n        (0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n        (0, chai_1.expect)(response.disputeId).to.be.a(\&quot;bigint\&quot;);\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2cc6252f-5494-47e0-ba6c-db7363f6537b&quot;,&quot;parentUUID&quot;:&quot;71ed6ebe-360f-4a7a-8ae0-58f6e2ded487&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should reject a dispute with an invalid tag not defined in the enum&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should reject a dispute with an invalid tag not defined in the enum&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:361,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(clientA.dispute.raiseDispute({\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: \&quot;INVALID_TAG\&quot;,\n    liveness: 2592000,\n    bond: minimumBond,\n})).to.be.rejectedWith(\&quot;The target tag INVALID_TAG is not whitelisted\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b671bac6-1b4d-417f-8b4f-fa1f643f5eab&quot;,&quot;parentUUID&quot;:&quot;71ed6ebe-360f-4a7a-8ae0-58f6e2ded487&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should be able to counter existing dispute once&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should be able to counter existing dispute once&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15975,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const assertionId = await clientB.dispute.disputeIdToAssertionId(disputeId);\nconst counterEvidenceCID = await generateCID();\nconst ret = await clientB.dispute.disputeAssertion({\n    ipId: ipIdB,\n    assertionId,\n    counterEvidenceCID,\n});\n(0, chai_1.expect)(ret.txHash).to.be.a(\&quot;string\&quot;);\n// should throw error if attempting to dispute assertion again\nawait (0, chai_1.expect)(clientB.dispute.disputeAssertion({\n    ipId: ipIdB,\n    assertionId,\n    counterEvidenceCID,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;dec67c10-d5f6-4e4f-a338-72e04bcda22b&quot;,&quot;parentUUID&quot;:&quot;71ed6ebe-360f-4a7a-8ae0-58f6e2ded487&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;35182ca1-a790-40c6-9f42-d0443d983a4a&quot;,&quot;9f839dc7-9c8b-4dc6-b298-71c2eaf20bcb&quot;,&quot;2cc6252f-5494-47e0-ba6c-db7363f6537b&quot;,&quot;b671bac6-1b4d-417f-8b4f-fa1f643f5eab&quot;,&quot;dec67c10-d5f6-4e4f-a338-72e04bcda22b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:70162,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;c691e749-bd6b-4538-88e9-fffcba03fae4&quot;,&quot;title&quot;:&quot;Dispute resolution&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/dispute.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before each\&quot; hook in \&quot;Dispute resolution\&quot;&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution \&quot;before each\&quot; hook in \&quot;Dispute resolution\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:44998,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Setup NFT collection\nconst txData = await clientA.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\n// Get parent IP ID and license terms ID\nconst ipIdAndLicenseResponse = await clientA.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContract,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: src_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: generated_1.evenSplitGroupPoolAddress[util_1.aeneid],\n            },\n        },\n    ],\n});\nparentIpId = ipIdAndLicenseResponse.ipId;\nlicenseTermsId = ipIdAndLicenseResponse.licenseTermsIds[0];\n//Create a derivative ip\nconst derivativeIpIdResponse1 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\nchildIpId = derivativeIpIdResponse1.ipId;\n// Create a second derivative ip\nconst derivativeIpIdResponse2 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\nchildIpId2 = derivativeIpIdResponse2.ipId;\n// Raise a dispute\nconst response = await clientA.dispute.raiseDispute({\n    targetIpId: parentIpId,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 1,\n    bond: minimumBond,\n});\ndisputeId = response.disputeId;\n// This timeout guarantees that the assertion is expired\n// its intended to be longer than the current block time\n// so it won&#x27;t be included in the same block\nawait new Promise((resolve) =&gt; setTimeout(resolve, 3000));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;714d5225-613e-40b4-b38e-1032442218a6&quot;,&quot;parentUUID&quot;:&quot;c691e749-bd6b-4538-88e9-fffcba03fae4&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should tag infringing ip&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag infringing ip&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9880,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Tag derivative IP as infringing\nconst results = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: childIpId2,\n            disputeId: disputeId,\n        },\n    ],\n});\n(0, chai_1.expect)(results[0].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4a5d7eb3-58f2-49eb-9535-c2677cb06128&quot;,&quot;parentUUID&quot;:&quot;c691e749-bd6b-4538-88e9-fffcba03fae4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should tag a single IP as infringing without using multicall&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag a single IP as infringing without using multicall&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9982,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;/**\n * Test Flow:\n * 1. Set judgment on an existing dispute to mark it as valid (did in `before each` block)\n * 2. Verify the dispute state changed correctly after judgment\n * 3. Try to tag a derivative IP using the judged dispute\n */\n// Step 1: Set judgment on an existing dispute to mark it as valid\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Step 2: Verify dispute state\n// The disputes() function returns multiple values about the dispute:\n// - targetTag: the tag we wanted to apply when raising the dispute\n// - currentTag: the current state of the dispute after judgment\n// After a successful judgment, currentTag should equal targetTag\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag); // Verify judgment was recorded correctly\n// Step 3: Attempt to tag a derivative IP\n// This will fail if:\n// - The dispute is not in a valid state (still IN_DISPUTE or cleared)\n// - The IP we&#x27;re trying to tag is not actually a derivative of the disputed IP\n// - The dispute has already been used to tag this IP\nconst response = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId, // The derivative IP to tag\n            disputeId: disputeId, // Using the judged dispute as basis for tagging\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: false, // Force single transaction instead of batch\n    },\n});\n// Verify we got the expected response\n(0, chai_1.expect)(response).to.have.lengthOf(1);\n(0, chai_1.expect)(response[0].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4be53877-e7aa-427e-bd1e-206a03bd3cfa&quot;,&quot;parentUUID&quot;:&quot;c691e749-bd6b-4538-88e9-fffcba03fae4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should tag multiple IPs as infringing using multicall&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag multiple IPs as infringing using multicall&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:29415,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const disputeResponse = await clientA.dispute.raiseDispute({\n    targetIpId: parentIpId,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 1,\n    bond: minimumBond,\n});\nconst testDisputeId = disputeResponse.disputeId;\nconst derivativeResponse2 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nconst newChildIpId = derivativeResponse2.ipId;\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, testDisputeId);\n// This timeout guarantees that the assertion is expired\n// its intended to be longer than the current block time\n// so it won&#x27;t be included in the same block\nawait new Promise((resolve) =&gt; setTimeout(resolve, 3000));\nconst { currentTag, targetTag } = await getDisputeState(testDisputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst response = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: testDisputeId,\n        },\n        {\n            ipId: newChildIpId,\n            disputeId: testDisputeId,\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: true,\n    },\n});\n(0, chai_1.expect)(response).to.have.lengthOf(1);\n(0, chai_1.expect)(response[0].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b52e787a-65e1-4626-bd56-5a21117d8e29&quot;,&quot;parentUUID&quot;:&quot;c691e749-bd6b-4538-88e9-fffcba03fae4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should tag multiple IPs without multicall when specified&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag multiple IPs without multicall when specified&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22430,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create two new derivative IPs sequentially\nconst derivativeResponse3 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nconst derivativeResponse4 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst responses = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: derivativeResponse3.ipId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: derivativeResponse4.ipId,\n            disputeId: disputeId,\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: false,\n    },\n});\n(0, chai_1.expect)(responses).to.have.lengthOf(2);\n(0, chai_1.expect)(responses[0].txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(responses[1].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4f75af23-f86c-4962-bc6a-5fb1909a54a9&quot;,&quot;parentUUID&quot;:&quot;c691e749-bd6b-4538-88e9-fffcba03fae4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to tag with invalid dispute ID&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should fail when trying to tag with invalid dispute ID&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:252,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: 999999n,\n        },\n    ],\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5f366f95-bc8d-4f11-af1a-2ea4d6e37481&quot;,&quot;parentUUID&quot;:&quot;c691e749-bd6b-4538-88e9-fffcba03fae4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should resolve a dispute successfully when initiated by dispute initiator&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should resolve a dispute successfully when initiated by dispute initiator&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9964,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst response = await clientA.dispute.resolveDispute({\n    disputeId: disputeId,\n    data: \&quot;0x\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9c5c3bcb-5394-4deb-b82e-68924e89e809&quot;,&quot;parentUUID&quot;:&quot;c691e749-bd6b-4538-88e9-fffcba03fae4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when non-initiator tries to resolve the dispute&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should fail when non-initiator tries to resolve the dispute&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:84,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(clientB.dispute.resolveDispute({\n    disputeId: disputeId,\n    data: \&quot;0x\&quot;,\n})).to.be.rejectedWith(\&quot;NotDisputeInitiator\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;813189a0-60b1-4a45-9619-4c7791faeea9&quot;,&quot;parentUUID&quot;:&quot;c691e749-bd6b-4538-88e9-fffcba03fae4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should propagate IMPROPER_REGISTRATION tag to derivative IPs&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should propagate IMPROPER_REGISTRATION tag to derivative IPs&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10094,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Verify the dispute state changed correctly\nconst { currentTag: parentCurrentTag, targetTag: parentTargetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(parentCurrentTag).to.equal(parentTargetTag);\n// Propagate the tag to both derivative IPs\nconst results = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: childIpId2,\n            disputeId: disputeId,\n        },\n    ],\n});\nconst logData = results[0].receipt?.logs[0].data;\nconst firstWord = logData.slice(0, 66);\nconst childDisputeId = BigInt(firstWord);\n// Verify successful tagging\n(0, chai_1.expect)(results[0].txHash).to.be.a(\&quot;string\&quot;);\nconst { currentTag: childCurrentTag } = await getDisputeState(childDisputeId);\n// Convert the IMPROPER_USAGE tag to hex for comparison\nconst improperUsageTagHex = (0, viem_1.toHex)(src_1.DisputeTargetTag.IMPROPER_REGISTRATION, { size: 32 });\n// Verify both child IPs have the IMPROPER_USAGE tag by\n// fetching and comparing their dispute tags\n(0, chai_1.expect)(parentCurrentTag).to.equal(parentTargetTag);\n(0, chai_1.expect)(childCurrentTag).to.equal(improperUsageTagHex);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2fa68071-f217-4cb3-be09-8578ea4ecf05&quot;,&quot;parentUUID&quot;:&quot;c691e749-bd6b-4538-88e9-fffcba03fae4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;4a5d7eb3-58f2-49eb-9535-c2677cb06128&quot;,&quot;4be53877-e7aa-427e-bd1e-206a03bd3cfa&quot;,&quot;b52e787a-65e1-4626-bd56-5a21117d8e29&quot;,&quot;4f75af23-f86c-4962-bc6a-5fb1909a54a9&quot;,&quot;5f366f95-bc8d-4f11-af1a-2ea4d6e37481&quot;,&quot;9c5c3bcb-5394-4deb-b82e-68924e89e809&quot;,&quot;813189a0-60b1-4a45-9619-4c7791faeea9&quot;,&quot;2fa68071-f217-4cb3-be09-8578ea4ecf05&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:92101,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;f051c622-127e-41ff-a5ca-71eb7f4e1cb5&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:10702,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;85fb6e4a-23e3-4d0d-b827-d3e4f411ec42&quot;,&quot;title&quot;:&quot;Group Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Group Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Group Functions \&quot;before all\&quot; hook in \&quot;Group Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4888,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\n// Create NFT Collection\nspgNftContract = (await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n})).spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;aa51e01f-7374-4f51-b427-4abc81563f7e&quot;,&quot;parentUUID&quot;:&quot;85fb6e4a-23e3-4d0d-b827-d3e4f411ec42&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;e0149868-b20f-478f-a4c8-31bd56179a67&quot;,&quot;title&quot;:&quot;Group Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Group Operations\&quot;&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations \&quot;before all\&quot; hook in \&quot;Group Operations\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10953,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create initial IP with license terms\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    allowDuplicates: false,\n    licenseTermsData,\n});\nlicenseTermsId = result.licenseTermsIds[0];\nipId = result.ipId;\n// Set licensing config\nawait client.license.setLicensingConfig({\n    ipId,\n    licenseTermsId,\n    licenseTemplate: generated_1.piLicenseTemplateAddress[util_1.aeneid],\n    licensingConfig: {\n        isSet: true,\n        mintingFee: 0n,\n        licensingHook: viem_1.zeroAddress,\n        hookData: viem_1.zeroAddress,\n        commercialRevShare: 0,\n        disabled: false,\n        expectMinimumGroupRewardShare: 0,\n        expectGroupRewardPool: groupPoolAddress,\n    },\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ade70cf9-d5e7-4ea5-9534-2206d7568bed&quot;,&quot;parentUUID&quot;:&quot;e0149868-b20f-478f-a4c8-31bd56179a67&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully register group and attach license&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register group and attach license&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8992,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.registerGroupAndAttachLicense({\n    groupPool: groupPoolAddress,\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n});\ngroupId = result.groupId;\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.groupId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c5812dc9-9ae0-4fd8-a8a6-a9a19f66f3ac&quot;,&quot;parentUUID&quot;:&quot;e0149868-b20f-478f-a4c8-31bd56179a67&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully mint, register IP, attach license and add to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully mint, register IP, attach license and add to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5172,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.mintAndRegisterIpAndAttachLicenseAndAddToGroup({\n    groupId,\n    spgNftContract,\n    licenseData: [\n        {\n            licenseTermsId,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: groupPoolAddress,\n            },\n        },\n    ],\n    maxAllowedRewardShare: 100,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cea6f2b8-a001-4896-b421-95c332fd7a31&quot;,&quot;parentUUID&quot;:&quot;e0149868-b20f-478f-a4c8-31bd56179a67&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register a basic group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register a basic group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4918,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.registerGroup({\n    groupPool: groupPoolAddress,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.groupId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;776c33e2-ae2b-46c6-9dee-5948618a1bea&quot;,&quot;parentUUID&quot;:&quot;e0149868-b20f-478f-a4c8-31bd56179a67&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register existing IP with license and add to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register existing IP with license and add to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10242,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(spgNftContract, \&quot;test-metadata\&quot;);\nconst result = await client.groupClient.registerIpAndAttachLicenseAndAddToGroup({\n    groupId,\n    nftContract: spgNftContract,\n    tokenId,\n    licenseData: [\n        {\n            licenseTermsId,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: groupPoolAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;04329525-195a-4ab4-8e12-0993adb33ba6&quot;,&quot;parentUUID&quot;:&quot;e0149868-b20f-478f-a4c8-31bd56179a67&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register group with license and add multiple IPs&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register group with license and add multiple IPs&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5114,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.registerGroupAndAttachLicenseAndAddIps({\n    groupPool: groupPoolAddress,\n    maxAllowedRewardShare: 50,\n    ipIds: [ipId],\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.groupId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1f2b3fa4-8dfa-4e2a-afce-a851881e2db2&quot;,&quot;parentUUID&quot;:&quot;e0149868-b20f-478f-a4c8-31bd56179a67&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to add unregistered IP to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should fail when trying to add unregistered IP to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:96,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.groupClient.registerGroupAndAttachLicenseAndAddIps({\n    groupPool: groupPoolAddress,\n    maxAllowedRewardShare: 5,\n    ipIds: [viem_1.zeroAddress], // Invalid IP address\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n})).to.be.rejectedWith(\&quot;Failed to register group and attach license and add ips\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;114666c6-addb-4d91-b4e4-4f99af201bc5&quot;,&quot;parentUUID&quot;:&quot;e0149868-b20f-478f-a4c8-31bd56179a67&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;1d68ab1f-ad31-4541-b96e-1bde4b1c9834&quot;,&quot;title&quot;:&quot;Add IPs to Group and Remove IPs from Group&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully add multiple IPs to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should successfully add multiple IPs to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11549,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const registerResult = await client.ipAsset.batchMintAndRegisterIpAssetWithPilTerms({\n    args: [\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n    ],\n});\nipIds = registerResult.results?.map((result) =&gt; result.ipId) ?? [];\nconst result = await client.groupClient.addIpsToGroup({\n    groupIpId: groupId,\n    ipIds: ipIds,\n    maxAllowedRewardSharePercentage: 55,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bca0ea01-382c-47c2-9e1d-786fc8053193&quot;,&quot;parentUUID&quot;:&quot;1d68ab1f-ad31-4541-b96e-1bde4b1c9834&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully remove IPs from group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should successfully remove IPs from group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4915,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.removeIpsFromGroup({\n    groupIpId: groupId,\n    ipIds: ipIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d80957f8-e78e-4173-a824-3351c3204185&quot;,&quot;parentUUID&quot;:&quot;1d68ab1f-ad31-4541-b96e-1bde4b1c9834&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to remove IPs from a non-existent group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should fail when trying to remove IPs from a non-existent group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5861,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const registerResult = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData,\n});\nconst testIpId = registerResult.ipId;\nconst nonExistentGroupId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.removeIpsFromGroup({\n    groupIpId: nonExistentGroupId,\n    ipIds: [testIpId],\n})).to.be.rejectedWith(\&quot;Failed to remove IPs from group\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;894986b5-8a20-48c3-87ca-b93e10d8dbb7&quot;,&quot;parentUUID&quot;:&quot;1d68ab1f-ad31-4541-b96e-1bde4b1c9834&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to remove non-existent IPs from a group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should fail when trying to remove non-existent IPs from a group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5012,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const groupResult = await client.groupClient.registerGroup({\n    groupPool: groupPoolAddress,\n});\nconst testGroupId = groupResult.groupId;\nconst nonExistentIpId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.removeIpsFromGroup({\n    groupIpId: testGroupId,\n    ipIds: [nonExistentIpId],\n})).to.be.rejectedWith(\&quot;Failed to remove IPs from group\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;931ed5b3-cf59-47f1-88d9-cc15323e939d&quot;,&quot;parentUUID&quot;:&quot;1d68ab1f-ad31-4541-b96e-1bde4b1c9834&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;bca0ea01-382c-47c2-9e1d-786fc8053193&quot;,&quot;d80957f8-e78e-4173-a824-3351c3204185&quot;,&quot;894986b5-8a20-48c3-87ca-b93e10d8dbb7&quot;,&quot;931ed5b3-cf59-47f1-88d9-cc15323e939d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:27337,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;c5812dc9-9ae0-4fd8-a8a6-a9a19f66f3ac&quot;,&quot;cea6f2b8-a001-4896-b421-95c332fd7a31&quot;,&quot;776c33e2-ae2b-46c6-9dee-5948618a1bea&quot;,&quot;04329525-195a-4ab4-8e12-0993adb33ba6&quot;,&quot;1f2b3fa4-8dfa-4e2a-afce-a851881e2db2&quot;,&quot;114666c6-addb-4d91-b4e4-4f99af201bc5&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:34534,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;8106283e-d133-45a4-920d-0b4de4fcffa3&quot;,&quot;title&quot;:&quot;Collect Royalty and Claim Reward&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Collect Royalty and Claim Reward\&quot;&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward \&quot;before all\&quot; hook in \&quot;Collect Royalty and Claim Reward\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10823,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Register IP id\nconst result1 = await mintAndRegisterIpAssetWithPilTermsHelper();\nipId = result1.ipId;\nlicenseTermsId = result1.licenseTermsIds[0];\n// Register group id\ngroupIpId = await registerGroupAndAttachLicenseHelper(licenseTermsId, [ipId]);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d5893029-5033-4090-a3bf-7b0633af6dab&quot;,&quot;parentUUID&quot;:&quot;8106283e-d133-45a4-920d-0b4de4fcffa3&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully collect royalties&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully collect royalties&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:25048,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Mint and register child IP id\nconst childIpId = await mintAndRegisterIpAndMakeDerivativeHelper(groupIpId, licenseTermsId);\n// Pay royalties from child IP id to group IP id and transfer to vault\nawait payRoyaltyAndTransferToVaultHelper(childIpId, groupIpId, src_1.WIP_TOKEN_ADDRESS, 100n);\n// Collect royalties\nconst result = await client.groupClient.collectRoyalties({\n    groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.collectedRoyalties).to.equal(10n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ad961bcb-a3b0-4d04-80fa-c09686907181&quot;,&quot;parentUUID&quot;:&quot;8106283e-d133-45a4-920d-0b4de4fcffa3&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully get claimable reward&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully get claimable reward&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:132,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.getClaimableReward({\n    groupIpId: groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n});\n(0, chai_1.expect)(result).to.deep.equal([10n]);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cb795288-f776-492b-87bf-d1939587036e&quot;,&quot;parentUUID&quot;:&quot;8106283e-d133-45a4-920d-0b4de4fcffa3&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully claim reward&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully claim reward&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10238,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Mint license tokens to the IP id which doesn&#x27;t have a royalty vault\nawait client.license.mintLicenseTokens({\n    licensorIpId: ipId,\n    licenseTermsId,\n    amount: 100,\n    maxMintingFee: 1,\n    maxRevenueShare: 100,\n});\n// Claim reward\nconst result = await client.groupClient.claimReward({\n    groupIpId: groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.claimedReward?.[0].amount[0]).to.equal(10n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cb96aea8-bc16-4ace-a4f4-6eda881a4e5d&quot;,&quot;parentUUID&quot;:&quot;8106283e-d133-45a4-920d-0b4de4fcffa3&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to claim reward for a non-existent group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should fail when trying to claim reward for a non-existent group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:101,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const nonExistentGroupId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.claimReward({\n    groupIpId: nonExistentGroupId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n})).to.be.rejectedWith(\&quot;Failed to claim reward\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c3df21b3-0cb9-43a7-a594-1c521307d499&quot;,&quot;parentUUID&quot;:&quot;8106283e-d133-45a4-920d-0b4de4fcffa3&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to claim reward with invalid token address&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should fail when trying to claim reward with invalid token address&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:88,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const invalidTokenAddress = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.claimReward({\n    groupIpId: groupIpId,\n    currencyToken: invalidTokenAddress,\n    memberIpIds: [ipId],\n})).to.be.rejectedWith(\&quot;Failed to claim reward\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;aeb42bfb-f46d-485e-9293-0b97c6543620&quot;,&quot;parentUUID&quot;:&quot;8106283e-d133-45a4-920d-0b4de4fcffa3&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully collect royalties and claim reward in one transaction&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully collect royalties and claim reward in one transaction&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:66736,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const ipIds = [];\nconst result1 = await mintAndRegisterIpAssetWithPilTermsHelper();\nconst result2 = await mintAndRegisterIpAssetWithPilTermsHelper();\nipIds.push(result1.ipId);\nipIds.push(result2.ipId);\nlicenseTermsId = result1.licenseTermsIds[0];\nconst groupId = await registerGroupAndAttachLicenseHelper(licenseTermsId, ipIds);\nconst childIpId1 = await mintAndRegisterIpAndMakeDerivativeHelper(groupId, licenseTermsId);\nconst childIpId2 = await mintAndRegisterIpAndMakeDerivativeHelper(groupId, licenseTermsId);\nawait payRoyaltyAndTransferToVaultHelper(childIpId1, groupId, src_1.WIP_TOKEN_ADDRESS, 100n);\nawait payRoyaltyAndTransferToVaultHelper(childIpId2, groupId, src_1.WIP_TOKEN_ADDRESS, 100n);\nconst result = await client.groupClient.collectAndDistributeGroupRoyalties({\n    groupIpId: groupId,\n    currencyTokens: [src_1.WIP_TOKEN_ADDRESS],\n    memberIpIds: ipIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.collectedRoyalties?.[0].amount).to.equal(20n);\n(0, chai_1.expect)(result.royaltiesDistributed?.[0].amount).to.equal(10n);\n(0, chai_1.expect)(result.royaltiesDistributed?.[1].amount).to.equal(10n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9de172a8-ef08-47ee-bac9-3a7359586cc5&quot;,&quot;parentUUID&quot;:&quot;8106283e-d133-45a4-920d-0b4de4fcffa3&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;ad961bcb-a3b0-4d04-80fa-c09686907181&quot;,&quot;cb795288-f776-492b-87bf-d1939587036e&quot;,&quot;cb96aea8-bc16-4ace-a4f4-6eda881a4e5d&quot;,&quot;c3df21b3-0cb9-43a7-a594-1c521307d499&quot;,&quot;aeb42bfb-f46d-485e-9293-0b97c6543620&quot;,&quot;9de172a8-ef08-47ee-bac9-3a7359586cc5&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:102343,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;de20614c-6552-4cbe-b7a9-913ecfdc8e0b&quot;,&quot;title&quot;:&quot;IPAccount Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;IPAccount Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions \&quot;before all\&quot; hook in \&quot;IPAccount Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10230,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = registerResult.ipId;\ndata = (0, viem_1.encodeFunctionData)({\n    abi: generated_1.accessControllerAbi,\n    functionName: \&quot;setTransientPermission\&quot;,\n    args: [\n        (0, viem_1.getAddress)(ipId),\n        (0, viem_1.getAddress)(util_1.TEST_WALLET_ADDRESS),\n        (0, viem_1.getAddress)(coreMetadataModule),\n        (0, viem_1.toFunctionSelector)(\&quot;function setAll(address,string,bytes32,bytes32)\&quot;),\n        src_1.AccessPermission.ALLOW,\n    ],\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;79e335f6-f651-4179-9ca5-fa6a607fba4f&quot;,&quot;parentUUID&quot;:&quot;de20614c-6552-4cbe-b7a9-913ecfdc8e0b&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully set ip metadata&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions should successfully set ip metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4941,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txHash = await client.ipAccount.setIpMetadata({\n    ipId: ipId,\n    metadataURI: \&quot;https://example.com\&quot;,\n    metadataHash: (0, viem_1.toHex)(\&quot;test\&quot;, { size: 32 }),\n});\n(0, chai_1.expect)(txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;724f31ad-e147-4cd2-948c-8cca373e2550&quot;,&quot;parentUUID&quot;:&quot;de20614c-6552-4cbe-b7a9-913ecfdc8e0b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully transfer ERC20 tokens&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions should successfully transfer ERC20 tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:20528,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const erc20 = new generated_1.Erc20Client(util_1.publicClient, util_1.walletClient);\n// 1. Query token balance of ipId and wallet before\nconst initialErc20BalanceOfIpId = await erc20.balanceOf({\n    account: ipId,\n});\nconst initialErc20BalanceOfWallet = await erc20.balanceOf({\n    account: util_1.TEST_WALLET_ADDRESS,\n});\nconst initialWipBalanceOfIpId = await client.wipClient.balanceOf(ipId);\nconst initialWipBalanceOfWallet = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n// 2. transfer erc20 token to the ip account\nconst txHash = await erc20.mint({\n    to: ipId,\n    amount: (0, viem_1.parseEther)(\&quot;0.002\&quot;),\n});\nawait util_1.publicClient.waitForTransactionReceipt({\n    hash: txHash,\n});\n// 3. transfer wip to the ip account\nawait client.wipClient.deposit({\n    amount: 1n,\n});\nawait client.wipClient.transfer({\n    to: ipId,\n    amount: 1n,\n});\n// 4. transfer token of ip account to wallet address\nconst ret = await client.ipAccount.transferErc20({\n    ipId,\n    tokens: [\n        {\n            address: src_1.WIP_TOKEN_ADDRESS,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: 1n,\n        },\n        {\n            address: erc20.address,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: (0, viem_1.parseEther)(\&quot;0.001\&quot;),\n        },\n        {\n            address: erc20.address,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: (0, viem_1.parseEther)(\&quot;0.001\&quot;),\n        },\n    ],\n});\n// 5. query token balance of ipId and wallet address after\nconst finalErc20BalanceOfIpId = await erc20.balanceOf({\n    account: ipId,\n});\nconst finalWipBalanceOfIpId = await client.wipClient.balanceOf(ipId);\nconst finalErc20BalanceOfWallet = await erc20.balanceOf({\n    account: util_1.TEST_WALLET_ADDRESS,\n});\nconst finalWipBalanceOfWallet = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(ret.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(finalErc20BalanceOfIpId).to.equal(initialErc20BalanceOfIpId);\n(0, chai_1.expect)(finalWipBalanceOfIpId).to.equal(initialWipBalanceOfIpId);\n(0, chai_1.expect)(finalErc20BalanceOfWallet).to.equal(initialErc20BalanceOfWallet + (0, viem_1.parseEther)(\&quot;0.002\&quot;));\n(0, chai_1.expect)(finalWipBalanceOfWallet).to.equal(initialWipBalanceOfWallet + 1n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;91b12bd5-f3ff-4254-81be-44386ee98d9f&quot;,&quot;parentUUID&quot;:&quot;de20614c-6552-4cbe-b7a9-913ecfdc8e0b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;342eee3b-a116-4288-8cb2-f86dc6098570&quot;,&quot;title&quot;:&quot;execute&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully execute a transaction&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions execute should successfully execute a transaction&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4924,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.ipAccount.execute({\n    to: permissionAddress,\n    value: 0,\n    data: data,\n    ipId: ipId,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;49d2ddd1-eb3c-4460-b93b-c76172ab2542&quot;,&quot;parentUUID&quot;:&quot;342eee3b-a116-4288-8cb2-f86dc6098570&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid ipId&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions execute should fail with invalid ipId&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:98,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.execute({\n    to: permissionAddress,\n    value: 0,\n    data: data,\n    ipId: \&quot;0x0000000000000000000000000000000000000000\&quot;,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bb9ee91a-122c-4e69-8f63-2e48ba9a4dd7&quot;,&quot;parentUUID&quot;:&quot;342eee3b-a116-4288-8cb2-f86dc6098570&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;49d2ddd1-eb3c-4460-b93b-c76172ab2542&quot;,&quot;bb9ee91a-122c-4e69-8f63-2e48ba9a4dd7&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:5022,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;b773e3ec-4d96-4688-ab62-8e982088f93c&quot;,&quot;title&quot;:&quot;executeWithSig&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully execute with valid signature&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should successfully execute with valid signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5048,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Get the IP Account nonce (state)\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\n// Generate signature for the execute operation itself\n// We need to sign the data that will be executed, not the permission data\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\n// Execute with signature\nconst response = await client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a5be1cde-ee87-46b4-ac9a-1fd3f83af495&quot;,&quot;parentUUID&quot;:&quot;b773e3ec-4d96-4688-ab62-8e982088f93c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with expired deadline&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with expired deadline&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:86,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: EXPIRED_DEADLINE,\n    signature: \&quot;0x\&quot;,\n})).to.be.rejectedWith(\&quot;IPAccount__ExpiredSignature\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d81fd0ad-3c03-4132-92c2-734f109bf3c5&quot;,&quot;parentUUID&quot;:&quot;b773e3ec-4d96-4688-ab62-8e982088f93c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid signature format&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with invalid signature format&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:98,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: \&quot;0x1234567890abcdef\&quot;, // Invalid signature format\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fb08a1bd-a92b-4b44-9ed4-a1766e6521ba&quot;,&quot;parentUUID&quot;:&quot;b773e3ec-4d96-4688-ab62-8e982088f93c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with signature from wrong signer&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with signature from wrong signer&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:197,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Generate signature with wrong signer\nconst wrongSigner = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: wrongSigner,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;465781ab-56ea-4ac4-8718-ab42c479ab30&quot;,&quot;parentUUID&quot;:&quot;b773e3ec-4d96-4688-ab62-8e982088f93c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid ipId format&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with invalid ipId format&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:98,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: \&quot;0x123\&quot;, // Invalid address format\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;Invalid address: 0x123.\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;35f865c8-a656-44aa-8bcb-b9064af9aceb&quot;,&quot;parentUUID&quot;:&quot;b773e3ec-4d96-4688-ab62-8e982088f93c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when IP account does not exist&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail when IP account does not exist&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:98,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create a real non-existent IP address (but with correct format)\nconst nonExistentIpId = \&quot;0x1111111111111111111111111111111111111111\&quot;;\n// Generate signature for this non-existent IP\n// Note: We need to try to get nonce first, if IP doesn&#x27;t exist, this step should fail\ntry {\n    const nonceResult = await client.ipAccount.getIpAccountNonce(nonExistentIpId);\n    const { signature } = await (0, src_1.getSignature)({\n        state: nonceResult,\n        to: permissionAddress,\n        encodeData: data,\n        wallet: util_1.walletClient,\n        verifyingContract: nonExistentIpId, // Use non-existent IP as verifying contract\n        deadline: VALID_DEADLINE,\n        chainId: util_1.aeneid,\n    });\n    await (0, chai_1.expect)(client.ipAccount.executeWithSig({\n        to: permissionAddress,\n        data: data,\n        ipId: nonExistentIpId,\n        signer: util_1.TEST_WALLET_ADDRESS,\n        deadline: VALID_DEADLINE,\n        signature: signature,\n    })).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;); // Should fail because IP doesn&#x27;t exist\n}\ncatch (error) {\n    // If getting nonce fails, it means IP indeed doesn&#x27;t exist, which is also our expected result\n    (0, chai_1.expect)(error.message).to.include(\&quot;Failed to get the IP Account nonce\&quot;);\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1fa58aee-5830-4d8b-9d97-f0f4ca7c7589&quot;,&quot;parentUUID&quot;:&quot;b773e3ec-4d96-4688-ab62-8e982088f93c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with unauthorized signer&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with unauthorized signer&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:180,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Test various unauthorized signer scenarios\nconst unauthorizedSigner = \&quot;0x2222222222222222222222222222222222222222\&quot;;\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: unauthorizedSigner, // Unauthorized signer\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;); // Contract returns InvalidSignature for permission issues&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9c8c3199-a312-46ac-9c2e-6fb0f3371368&quot;,&quot;parentUUID&quot;:&quot;b773e3ec-4d96-4688-ab62-8e982088f93c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with signature for wrong data&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with signature for wrong data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:188,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Generate signature for different data than what we execute\nconst wrongData = (0, viem_1.encodeFunctionData)({\n    abi: generated_1.accessControllerAbi,\n    functionName: \&quot;setTransientPermission\&quot;,\n    args: [\n        (0, viem_1.getAddress)(\&quot;0x1234567890123456789012345678901234567890\&quot;),\n        (0, viem_1.getAddress)(util_1.TEST_WALLET_ADDRESS),\n        (0, viem_1.getAddress)(coreMetadataModule),\n        (0, viem_1.toFunctionSelector)(\&quot;function setAll(address,string,bytes32,bytes32)\&quot;),\n        src_1.AccessPermission.DENY,\n    ],\n});\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: wrongData, // Sign wrong data\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data, // Execute with original data, not the signed data\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;); // Should fail because data doesn&#x27;t match signature&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;73a27078-0c3f-4ad0-9d4f-ba3128d5f74b&quot;,&quot;parentUUID&quot;:&quot;b773e3ec-4d96-4688-ab62-8e982088f93c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with signature for wrong target address&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with signature for wrong target address&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:210,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Generate signature for different target address than what we execute\nconst wrongTarget = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: wrongTarget, // Sign for wrong target\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress, // Execute with original target, not the signed target\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;); // Should fail because target doesn&#x27;t match signature&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;900e5304-75a8-4d2d-9c36-f6b913e19990&quot;,&quot;parentUUID&quot;:&quot;b773e3ec-4d96-4688-ab62-8e982088f93c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should execute with zero value transaction&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should execute with zero value transaction&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5038,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Test successful execution with zero value\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nconst response = await client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n    value: 0, // Explicitly set zero value\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;065a224f-9789-428f-8535-2b6f8c095e71&quot;,&quot;parentUUID&quot;:&quot;b773e3ec-4d96-4688-ab62-8e982088f93c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a5be1cde-ee87-46b4-ac9a-1fd3f83af495&quot;,&quot;d81fd0ad-3c03-4132-92c2-734f109bf3c5&quot;,&quot;fb08a1bd-a92b-4b44-9ed4-a1766e6521ba&quot;,&quot;465781ab-56ea-4ac4-8718-ab42c479ab30&quot;,&quot;35f865c8-a656-44aa-8bcb-b9064af9aceb&quot;,&quot;1fa58aee-5830-4d8b-9d97-f0f4ca7c7589&quot;,&quot;9c8c3199-a312-46ac-9c2e-6fb0f3371368&quot;,&quot;73a27078-0c3f-4ad0-9d4f-ba3128d5f74b&quot;,&quot;900e5304-75a8-4d2d-9c36-f6b913e19990&quot;,&quot;065a224f-9789-428f-8535-2b6f8c095e71&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:11241,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;bdc50e39-8e6f-4653-9dd2-89ea792de60d&quot;,&quot;title&quot;:&quot;getIpAccountNonce&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully return account nonce&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getIpAccountNonce should successfully return account nonce&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:102,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.ipAccount.getIpAccountNonce(ipId);\n(0, chai_1.expect)(response).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7abdfe76-0639-4d76-88e9-2211a62d19ed&quot;,&quot;parentUUID&quot;:&quot;bdc50e39-8e6f-4653-9dd2-89ea792de60d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid ipId&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getIpAccountNonce should fail with invalid ipId&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:90,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.getIpAccountNonce(\&quot;0x0000000000000000000000000000000000000000\&quot;))\n    .to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;33d14158-c1ec-447e-9125-58ed46a266da&quot;,&quot;parentUUID&quot;:&quot;bdc50e39-8e6f-4653-9dd2-89ea792de60d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;7abdfe76-0639-4d76-88e9-2211a62d19ed&quot;,&quot;33d14158-c1ec-447e-9125-58ed46a266da&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:192,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;6f18cf40-471d-42d6-b213-354a6172595b&quot;,&quot;title&quot;:&quot;getToken&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully return token information&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getToken should successfully return token information&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:96,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.ipAccount.getToken(ipId);\n(0, chai_1.expect)(response.chainId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(response.tokenContract).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.tokenId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(response.tokenContract).to.equal(util_1.mockERC721);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ec15932d-e6d2-4df5-88c8-70cb60777685&quot;,&quot;parentUUID&quot;:&quot;6f18cf40-471d-42d6-b213-354a6172595b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid ipId&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getToken should fail with invalid ipId&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:91,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.getToken(\&quot;0x0000000000000000000000000000000000000000\&quot;)).to.be\n    .rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1a5d4685-1eaf-44be-9cd4-a578e8241a72&quot;,&quot;parentUUID&quot;:&quot;6f18cf40-471d-42d6-b213-354a6172595b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;ec15932d-e6d2-4df5-88c8-70cb60777685&quot;,&quot;1a5d4685-1eaf-44be-9cd4-a578e8241a72&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:187,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;724f31ad-e147-4cd2-948c-8cca373e2550&quot;,&quot;91b12bd5-f3ff-4254-81be-44386ee98d9f&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:25469,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;58558070-f8e5-49d0-9159-fcd659c94241&quot;,&quot;title&quot;:&quot;IP Asset Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;IP Asset Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions \&quot;before all\&quot; hook in \&quot;IP Asset Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:91,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst res = await client.license.registerPILTerms(src_1.PILFlavor.nonCommercialSocialRemixing());\nnoCommercialLicenseTermsId = res.licenseTermsId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d266a003-d8f0-4d1f-8bf3-5cbd1708504d&quot;,&quot;parentUUID&quot;:&quot;58558070-f8e5-49d0-9159-fcd659c94241&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;08e67cdc-6012-4db2-885d-ed2d2cc9345c&quot;,&quot;title&quot;:&quot;Basic IP Asset Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register an IP Asset&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register an IP Asset&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14105,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nchildIpId = response.ipId;\n(0, chai_1.expect)(childIpId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e21c2f2b-b94e-496d-87df-9f502e959bfd&quot;,&quot;parentUUID&quot;:&quot;08e67cdc-6012-4db2-885d-ed2d2cc9345c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register an IP Asset with multiple metadata fields&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register an IP Asset with multiple metadata fields&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14204,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    ipMetadata: {\n        ipMetadataURI: \&quot;ipfs://test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataURI: \&quot;ipfs://test-nft-uri\&quot;,\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\nchildIpId2 = response.ipId;\n(0, chai_1.expect)(response.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d8908dd0-febb-4aa2-9051-9cc834969eae&quot;,&quot;parentUUID&quot;:&quot;08e67cdc-6012-4db2-885d-ed2d2cc9345c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should not register with invalid metadata hash length&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should not register with invalid metadata hash length&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5213,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    ipMetadata: {\n        ipMetadataHash: \&quot;0x123\&quot;, // Invalid length hash\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;valid-hash\&quot;, { size: 32 }),\n    },\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;111a0a45-f8b7-4f74-bdbb-3f752b19d344&quot;,&quot;parentUUID&quot;:&quot;08e67cdc-6012-4db2-885d-ed2d2cc9345c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should not register with non-existent token ID&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should not register with non-existent token ID&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:262,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: BigInt(Number.MAX_SAFE_INTEGER),\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f291af66-edc6-4949-9f98-a49b487614ab&quot;,&quot;parentUUID&quot;:&quot;08e67cdc-6012-4db2-885d-ed2d2cc9345c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with Non-Commercial Remix PIL&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with Non-Commercial Remix PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:24732,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nparentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [noCommercialLicenseTermsId],\n    maxMintingFee: 0,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: 0.32423,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;03ebbb51-ad0b-4eae-a0e0-06d60c018894&quot;,&quot;parentUUID&quot;:&quot;08e67cdc-6012-4db2-885d-ed2d2cc9345c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with Commercial Remix PIL&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with Commercial Remix PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:25084,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Register commercial remix PIL\nconst licenseResponse = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 10n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n}));\n// Register parent IP\nconst tokenId = await (0, util_1.getTokenId)();\nconst commercialParentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// Attach license terms to parent IP\nawait client.license.attachLicenseTerms({\n    ipId: commercialParentIpId,\n    licenseTermsId: licenseResponse.licenseTermsId,\n});\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: childIpId2,\n    parentIpIds: [commercialParentIpId],\n    licenseTermsIds: [licenseResponse.licenseTermsId],\n    maxMintingFee: 100,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: 10,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;233fcc2b-d523-447c-9cb8-e22002cefb59&quot;,&quot;parentUUID&quot;:&quot;08e67cdc-6012-4db2-885d-ed2d2cc9345c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with multiple parent IPs&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with multiple parent IPs&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:46391,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create first parent IP\nconst tokenId1 = await (0, util_1.getTokenId)();\nconst parentIpId1 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n})).ipId;\n// Create second parent IP\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst parentIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId2,\n})).ipId;\n// Attach license terms to both parents\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId1,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId2,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\n// Create child IP\nconst childTokenId = await (0, util_1.getTokenId)();\nconst newChildIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId,\n})).ipId;\n// Register derivative with multiple parents\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: newChildIpId,\n    parentIpIds: [parentIpId1, parentIpId2],\n    licenseTermsIds: [noCommercialLicenseTermsId, noCommercialLicenseTermsId],\n    maxMintingFee: 0,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: 0.9999999999,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7ac820dc-c3bb-48e0-b987-6c0dbb2efa92&quot;,&quot;parentUUID&quot;:&quot;08e67cdc-6012-4db2-885d-ed2d2cc9345c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:20520,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst ipId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: noCommercialLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 1,\n});\nconst response = await client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;98c5b3bc-42c2-4543-a813-ecfdb241552b&quot;,&quot;parentUUID&quot;:&quot;08e67cdc-6012-4db2-885d-ed2d2cc9345c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should return true if IP asset is registered&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should return true if IP asset is registered&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:92,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const isRegistered = await client.ipAsset.isRegistered(parentIpId);\n(0, chai_1.expect)(isRegistered).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;105fcc25-75c7-4a63-a4d9-9b3b9d711528&quot;,&quot;parentUUID&quot;:&quot;08e67cdc-6012-4db2-885d-ed2d2cc9345c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should return false if IP asset is not registered&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should return false if IP asset is not registered&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:107,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const isRegistered = await client.ipAsset.isRegistered(\&quot;0x1234567890123456789012345678901234567890\&quot;);\n(0, chai_1.expect)(isRegistered).to.equal(false);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5c062407-c712-460a-8f95-e955b2146391&quot;,&quot;parentUUID&quot;:&quot;08e67cdc-6012-4db2-885d-ed2d2cc9345c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;e21c2f2b-b94e-496d-87df-9f502e959bfd&quot;,&quot;d8908dd0-febb-4aa2-9051-9cc834969eae&quot;,&quot;111a0a45-f8b7-4f74-bdbb-3f752b19d344&quot;,&quot;f291af66-edc6-4949-9f98-a49b487614ab&quot;,&quot;03ebbb51-ad0b-4eae-a0e0-06d60c018894&quot;,&quot;233fcc2b-d523-447c-9cb8-e22002cefb59&quot;,&quot;7ac820dc-c3bb-48e0-b987-6c0dbb2efa92&quot;,&quot;98c5b3bc-42c2-4543-a813-ecfdb241552b&quot;,&quot;105fcc25-75c7-4a63-a4d9-9b3b9d711528&quot;,&quot;5c062407-c712-460a-8f95-e955b2146391&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:150710,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;title&quot;:&quot;SPG NFT Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;SPG NFT Operations\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations \&quot;before all\&quot; hook in \&quot;SPG NFT Operations\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12562,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Setup NFT collection\nconst txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\n// Setup license terms\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContract,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];\n// Setup ERC20\nconst mockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\nawait mockERC20.approve(generated_1.derivativeWorkflowsAddress[util_1.aeneid], viem_1.maxUint256);\nawait mockERC20.approve(generated_1.royaltyTokenDistributionWorkflowsAddress[util_1.aeneid], viem_1.maxUint256);\nawait mockERC20.mint(util_1.TEST_WALLET_ADDRESS, 100000n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;41315859-ed0d-4a1d-94eb-42cc90310107&quot;,&quot;parentUUID&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register IP Asset with metadata&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP Asset with metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10160,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst response = await client.ipAsset.register({\n    nftContract,\n    tokenId,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(response.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8eb086c6-3565-4126-ad76-99020fdd1d21&quot;,&quot;parentUUID&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative IP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register derivative IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14873,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenChildId = await (0, util_1.mintBySpg)(nftContract);\nconst result = await client.ipAsset.registerDerivativeIp({\n    nftContract: nftContract,\n    tokenId: tokenChildId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 0,\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1437b1e8-b86f-4f41-b5ff-d7825746ca80&quot;,&quot;parentUUID&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach PIL terms&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach PIL terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10972,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: nftContract,\n    tokenId,\n    deadline: 1000n,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.commercialUse({\n                defaultMintingFee: 10000n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 10000n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;26bbffde-8704-4961-aef2-31e6d30d4212&quot;,&quot;parentUUID&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach PIL terms with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach PIL terms with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11608,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 10000n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f6c7fd7f-52e4-48a2-8432-d470f96552a5&quot;,&quot;parentUUID&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and make derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and make derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6034,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d6ecf99c-2270-4732-9c30-72c29918bbca&quot;,&quot;parentUUID&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5285,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: nftContract,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    allowDuplicates: false,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7d654cca-be01-4210-9bad-cdca1d7fce0f&quot;,&quot;parentUUID&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and make derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and make derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15680,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], mintLicenseTokensResult.licenseTokenIds[0]);\nconst result = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: nftContract,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;455bf899-6bed-4b2c-9b96-c33b50568186&quot;,&quot;parentUUID&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and make derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and make derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:20568,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], mintLicenseTokensResult.licenseTokenIds[0]);\nconst result = await client.ipAsset.registerIpAndMakeDerivativeWithLicenseTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b3fba487-709a-4957-910b-16a1edc2e56d&quot;,&quot;parentUUID&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach license terms and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17648,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 10,\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 0.00020302,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4e41710b-1b53-4083-9828-54efdc1bb735&quot;,&quot;parentUUID&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach license terms and distribute royalty tokens with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18507,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 12.232131,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;65cb41aa-dbc0-46c4-afbd-11b6487dfa2b&quot;,&quot;parentUUID&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach license terms and distribute royalty tokens with complex royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens with complex royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:16329,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: generated_1.erc20Address[util_1.aeneid],\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 43.000301,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 17.0003011,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 2.000301,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 32.0003012,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;242312f7-b73f-46ec-9df9-52f6892aa8e1&quot;,&quot;parentUUID&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative and attach license terms and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register derivative and attach license terms and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:20088,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 0,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cb13f684-dbd7-4439-a0ba-25c1c5d09e70&quot;,&quot;parentUUID&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and attach PIL terms and distribute royalty tokens without licensing config&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and attach PIL terms and distribute royalty tokens without licensing config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5999,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: nftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.2,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;80fe5810-8da7-4852-890c-2bb30aec9c94&quot;,&quot;parentUUID&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and attach PIL terms and distribute royalty tokens with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and attach PIL terms and distribute royalty tokens with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7544,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: nftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            maxLicenseTokens: 100,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 11n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.434,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(3);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;21af248d-eb56-4eaa-8921-4bb10b00b6ec&quot;,&quot;parentUUID&quot;:&quot;d90f1d0c-df9a-4601-8e0d-613ba4dd32b0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;8eb086c6-3565-4126-ad76-99020fdd1d21&quot;,&quot;1437b1e8-b86f-4f41-b5ff-d7825746ca80&quot;,&quot;26bbffde-8704-4961-aef2-31e6d30d4212&quot;,&quot;f6c7fd7f-52e4-48a2-8432-d470f96552a5&quot;,&quot;d6ecf99c-2270-4732-9c30-72c29918bbca&quot;,&quot;7d654cca-be01-4210-9bad-cdca1d7fce0f&quot;,&quot;455bf899-6bed-4b2c-9b96-c33b50568186&quot;,&quot;b3fba487-709a-4957-910b-16a1edc2e56d&quot;,&quot;4e41710b-1b53-4083-9828-54efdc1bb735&quot;,&quot;65cb41aa-dbc0-46c4-afbd-11b6487dfa2b&quot;,&quot;242312f7-b73f-46ec-9df9-52f6892aa8e1&quot;,&quot;cb13f684-dbd7-4439-a0ba-25c1c5d09e70&quot;,&quot;80fe5810-8da7-4852-890c-2bb30aec9c94&quot;,&quot;21af248d-eb56-4eaa-8921-4bb10b00b6ec&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:181295,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;df879c0a-9fce-4cf0-8bad-473b5902a915&quot;,&quot;title&quot;:&quot;SPG With Minting Fees with Public Minting SPG NFT Contract&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;SPG With Minting Fees with Public Minting SPG NFT Contract\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract \&quot;before all\&quot; hook in \&quot;SPG With Minting Fees with Public Minting SPG NFT Contract\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:16177,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// ensure we start with no wip since we will be wrapping them\nconst wipBalance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nif (wipBalance &gt; 0n) {\n    await client.wipClient.withdraw({\n        amount: wipBalance,\n    });\n}\n// create a nft collection that requires minting fee\nconst rsp = await client.nftClient.createNFTCollection({\n    name: \&quot;Premium Collection\&quot;,\n    symbol: \&quot;PC\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 100n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nnftContractWithMintingFee = rsp.spgNftContract;\n// create parent ip with minting fee\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContractWithMintingFee,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 150n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: true,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: BigInt(0),\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: BigInt(0),\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 150n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a7151389-efe4-4a8a-a370-4d70b05ce2ba&quot;,&quot;parentUUID&quot;:&quot;df879c0a-9fce-4cf0-8bad-473b5902a915&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should auto wrap ip when mint and register derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6757,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const userBalanceBefore = await client.getWalletBalance();\nconst rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContractWithMintingFee, // pay 100 here\n    derivData: {\n        parentIpIds: [parentIpId], // pay 150 here\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test\&quot;,\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \&quot;test\&quot;,\n        nftMetadataHash: viem_1.zeroHash,\n    },\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);\nconst userBalanceAfter = await client.getWalletBalance();\nconst cost = 150n + 100n;\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - cost));\n// user should not have any WIP tokens since we swap the exact amount\nconst wipBalance = await client.ipAsset.wipClient.balanceOf({\n    owner: util_1.TEST_WALLET_ADDRESS,\n});\n(0, chai_1.expect)(wipBalance.result).to.be.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;38415d07-9ec7-4f9e-9150-f5f19181846a&quot;,&quot;parentUUID&quot;:&quot;df879c0a-9fce-4cf0-8bad-473b5902a915&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto wrap ip when mint and register derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:34653,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenIds[0]);\n(0, chai_1.expect)(licenseTokenIds).to.be.an(\&quot;array\&quot;);\nconst { txHash, ipId } = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: nftContractWithMintingFee,\n    licenseTokenIds: licenseTokenIds,\n    maxRts: 0,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test\&quot;,\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \&quot;test\&quot;,\n        nftMetadataHash: viem_1.zeroHash,\n    },\n});\n(0, chai_1.expect)(txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(ipId).to.be.a(\&quot;string\&quot;);\nconst isRegistered = await client.ipAsset.isRegistered(ipId);\n(0, chai_1.expect)(isRegistered).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;31a0b53c-f9d2-43c2-8ca7-36c0ed6e0509&quot;,&quot;parentUUID&quot;:&quot;df879c0a-9fce-4cf0-8bad-473b5902a915&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto wrap ip when registering derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when registering derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:24376,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst balanceBefore = await client.getWalletBalance();\nconst rsp = await client.ipAsset.registerDerivativeIp({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 150n));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c4a2a45f-034f-4e56-8619-462616650f84&quot;,&quot;parentUUID&quot;:&quot;df879c0a-9fce-4cf0-8bad-473b5902a915&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should spend existing wip when register derivative and distribute loyalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should spend existing wip when register derivative and distribute loyalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:21194,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nawait client.wipClient.deposit({\n    amount: 150n,\n});\nconst rsp = await client.ipAsset.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 4.000301,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.be.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6290ac51-440b-4109-b3bc-7d794a832afa&quot;,&quot;parentUUID&quot;:&quot;df879c0a-9fce-4cf0-8bad-473b5902a915&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto wrap ip when mint and register derivative and distribute loyalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative and distribute loyalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6589,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens({\n    spgNftContract: nftContractWithMintingFee,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test\&quot;,\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \&quot;test\&quot;,\n        nftMetadataHash: viem_1.zeroHash,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 0.34343234234,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;421b7b7f-41c9-4f5b-b13a-fc28e74e2b0e&quot;,&quot;parentUUID&quot;:&quot;df879c0a-9fce-4cf0-8bad-473b5902a915&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;38415d07-9ec7-4f9e-9150-f5f19181846a&quot;,&quot;31a0b53c-f9d2-43c2-8ca7-36c0ed6e0509&quot;,&quot;c4a2a45f-034f-4e56-8619-462616650f84&quot;,&quot;6290ac51-440b-4109-b3bc-7d794a832afa&quot;,&quot;421b7b7f-41c9-4f5b-b13a-fc28e74e2b0e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:93569,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;0b76173b-d299-46e1-a05d-95a0d4d3f2da&quot;,&quot;title&quot;:&quot;IP Asset Registration with Private Minting SPG NFT Contracts&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;IP Asset Registration with Private Minting SPG NFT Contracts\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts \&quot;before all\&quot; hook in \&quot;IP Asset Registration with Private Minting SPG NFT Contracts\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4903,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;Private Minting Collection\&quot;,\n    symbol: \&quot;PMC\&quot;,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 3n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \&quot;\&quot;,\n});\nspgNftContractWithPrivateMinting = privateMintingCollectionResult.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0ba52139-d006-47c3-abd2-dbabedfda16c&quot;,&quot;parentUUID&quot;:&quot;0b76173b-d299-46e1-a05d-95a0d4d3f2da&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when call mint and register ip asset with pil terms&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip asset with pil terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:16770,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 6n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                commercialRevShare: 90,\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4435694d-19b0-4465-a784-1c3cfb9720bb&quot;,&quot;parentUUID&quot;:&quot;0b76173b-d299-46e1-a05d-95a0d4d3f2da&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip asset with pil terms with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip asset with pil terms with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12712,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 5n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 5n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n    ipMetadata: {\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a2bdc9b8-83e5-4247-8a36-403fc4cb76c9&quot;,&quot;parentUUID&quot;:&quot;0b76173b-d299-46e1-a05d-95a0d4d3f2da&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip and make derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and make derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11224,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 100n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;86d79cb5-3e08-4580-8dd9-a135415fdba6&quot;,&quot;parentUUID&quot;:&quot;0b76173b-d299-46e1-a05d-95a0d4d3f2da&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10730,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    allowDuplicates: false,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;98031271-983d-43e0-9901-8593a7272bdf&quot;,&quot;parentUUID&quot;:&quot;0b76173b-d299-46e1-a05d-95a0d4d3f2da&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip and make derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and make derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:21632,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst licenseTokenId = mintLicenseTokensResult.licenseTokenIds[0];\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenId);\nconst result = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    licenseTokenIds: [licenseTokenId],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b689f117-da93-4571-aac1-26942655bea3&quot;,&quot;parentUUID&quot;:&quot;0b76173b-d299-46e1-a05d-95a0d4d3f2da&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip and attach pil terms and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and attach pil terms and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11210,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.434,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;783221da-b37d-4b77-a5a9-c58703a3db40&quot;,&quot;parentUUID&quot;:&quot;0b76173b-d299-46e1-a05d-95a0d4d3f2da&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should succeed when call mint and register ip and make derivative and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should succeed when call mint and register ip and make derivative and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:26434,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: true,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\nconst newParentIpId = result.ipId;\nconst licenseId = result.licenseTermsIds[0];\nconst rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    derivData: {\n        parentIpIds: [newParentIpId],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.434,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f03a0b90-7e2e-45f8-98e0-de50c89e099d&quot;,&quot;parentUUID&quot;:&quot;0b76173b-d299-46e1-a05d-95a0d4d3f2da&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;4435694d-19b0-4465-a784-1c3cfb9720bb&quot;,&quot;a2bdc9b8-83e5-4247-8a36-403fc4cb76c9&quot;,&quot;86d79cb5-3e08-4580-8dd9-a135415fdba6&quot;,&quot;98031271-983d-43e0-9901-8593a7272bdf&quot;,&quot;b689f117-da93-4571-aac1-26942655bea3&quot;,&quot;783221da-b37d-4b77-a5a9-c58703a3db40&quot;,&quot;f03a0b90-7e2e-45f8-98e0-de50c89e099d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:110712,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;b893e75f-97f1-4642-bfad-7e83eeeeb82b&quot;,&quot;title&quot;:&quot;Batch Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Batch Operations\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations \&quot;before all\&quot; hook in \&quot;Batch Operations\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:19148,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\nconst tokenId = await (0, util_1.getTokenId)();\nparentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;10025fff-483d-41e7-a50b-53f2a3434dc0&quot;,&quot;parentUUID&quot;:&quot;b893e75f-97f1-4642-bfad-7e83eeeeb82b&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should batch register derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch register derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:31527,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const childTokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId,\n})).ipId;\nconst childTokenId2 = await (0, util_1.getTokenId)();\nconst childIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId2,\n})).ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nconst result = await client.ipAsset.batchRegisterDerivative({\n    args: [\n        {\n            childIpId: childIpId,\n            parentIpIds: [parentIpId],\n            licenseTermsIds: [noCommercialLicenseTermsId],\n        },\n        {\n            childIpId: childIpId2,\n            parentIpIds: [parentIpId],\n            licenseTermsIds: [noCommercialLicenseTermsId],\n            maxMintingFee: 10000000,\n            maxRts: 5 * 10 ** 6,\n            maxRevenueShare: 0,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0751979d-9511-44c7-84ff-fd0123547067&quot;,&quot;parentUUID&quot;:&quot;b893e75f-97f1-4642-bfad-7e83eeeeb82b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should batch mint and register IP asset with PIL terms&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch mint and register IP asset with PIL terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11591,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.batchMintAndRegisterIpAssetWithPilTerms({\n    args: [\n        {\n            spgNftContract: nftContract,\n            licenseTermsData: [\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 8n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \&quot;\&quot;,\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 8n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                    maxLicenseTokens: 100,\n                },\n                {\n                    terms: src_1.PILFlavor.commercialRemix({\n                        defaultMintingFee: 100n,\n                        commercialRevShare: 10,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                    }),\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 100n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                },\n            ],\n        },\n        {\n            spgNftContract: nftContract,\n            licenseTermsData: [\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 8n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \&quot;\&quot;,\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 8n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                    maxLicenseTokens: 100,\n                },\n            ],\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.results).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.results[0].licenseTermsIds).to.be.an(\&quot;array\&quot;).and.length(2);\n(0, chai_1.expect)(result.results[0].maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;).and.length(1);\n(0, chai_1.expect)(result.results[1].licenseTermsIds).to.be.an(\&quot;array\&quot;).and.length(1);\n(0, chai_1.expect)(result.results[1].maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;).and.length(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c89d25cf-adce-4443-8c3f-c1f8f644d9b9&quot;,&quot;parentUUID&quot;:&quot;b893e75f-97f1-4642-bfad-7e83eeeeb82b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should batch mint and register IP asset and make derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch mint and register IP asset and make derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6301,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract: nftContract,\n            derivData: {\n                parentIpIds: [parentIpId],\n                licenseTermsIds: [noCommercialLicenseTermsId],\n                maxMintingFee: 0,\n                maxRts: 5 * 10 ** 6,\n                maxRevenueShare: 0,\n            },\n        },\n        {\n            spgNftContract: nftContract,\n            derivData: {\n                parentIpIds: [parentIpId],\n                licenseTermsIds: [noCommercialLicenseTermsId],\n                maxMintingFee: 0,\n                maxRts: 5 * 10 ** 6,\n                maxRevenueShare: 0,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.results).to.be.an(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a3dd8f3e-6e4d-4e39-857d-af11f99015f8&quot;,&quot;parentUUID&quot;:&quot;b893e75f-97f1-4642-bfad-7e83eeeeb82b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should batch register giving parameters&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch register giving parameters&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30382,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst spgTokenId1 = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst spgTokenId2 = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId,\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2,\n        },\n        {\n            nftContract,\n            tokenId: spgTokenId1,\n            ipMetadata: {\n                ipMetadataURI: \&quot;test-uri2\&quot;,\n                ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash2\&quot;, { size: 32 }),\n                nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash2\&quot;, { size: 32 }),\n            },\n        },\n        {\n            nftContract,\n            tokenId: spgTokenId2,\n            ipMetadata: {\n                ipMetadataURI: \&quot;test-uri\&quot;,\n                ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n                nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.results).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e5a41b7b-1367-4623-9e97-bbbe9fd289ec&quot;,&quot;parentUUID&quot;:&quot;b893e75f-97f1-4642-bfad-7e83eeeeb82b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;0751979d-9511-44c7-84ff-fd0123547067&quot;,&quot;c89d25cf-adce-4443-8c3f-c1f8f644d9b9&quot;,&quot;a3dd8f3e-6e4d-4e39-857d-af11f99015f8&quot;,&quot;e5a41b7b-1367-4623-9e97-bbbe9fd289ec&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:79801,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;037eddf7-40e2-4bc5-8c7f-de264f20c6d7&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Error Cases\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Error Cases \&quot;before all\&quot; hook in \&quot;Error Cases\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9007,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;873a2ddd-1deb-4eef-a20a-9ff7aaaa1da8&quot;,&quot;parentUUID&quot;:&quot;037eddf7-40e2-4bc5-8c7f-de264f20c6d7&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should fail to register unowned NFT&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Error Cases should fail to register unowned NFT&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:295,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: nftContract,\n    tokenId: 999999n, // Non-existent token\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bd113b8a-6893-4d10-8686-86ab405f0724&quot;,&quot;parentUUID&quot;:&quot;037eddf7-40e2-4bc5-8c7f-de264f20c6d7&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;bd113b8a-6893-4d10-8686-86ab405f0724&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:295,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;933540aa-cc60-4e6e-aa22-45486c413e0c&quot;,&quot;title&quot;:&quot;Other Edge Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Other Edge Cases\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases \&quot;before all\&quot; hook in \&quot;Other Edge Cases\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15232,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst parentIpResponse = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nparentIpId = parentIpResponse.ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3fa0eb1e-eaff-4078-a897-da21f2375fa9&quot;,&quot;parentUUID&quot;:&quot;933540aa-cc60-4e6e-aa22-45486c413e0c&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;55f34d79-a0ba-4afd-a9d9-4a3a6670fdac&quot;,&quot;title&quot;:&quot;License Token Edge Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should fail when trying to use non-existent license token&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases License Token Edge Cases should fail when trying to use non-existent license token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10266,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId,\n    })).ipId,\n    licenseTokenIds: [BigInt(999999)], // Non-existent token\n    maxRts: 5 * 10 ** 6,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;53ebc721-926d-4ced-aba7-b0f5d401d199&quot;,&quot;parentUUID&quot;:&quot;55f34d79-a0ba-4afd-a9d9-4a3a6670fdac&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to use same license token twice&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases License Token Edge Cases should fail when trying to use same license token twice&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30621,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: noCommercialLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 1,\n});\nconst tokenId1 = await (0, util_1.getTokenId)();\nawait client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n    })).ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 0,\n});\nconst tokenId2 = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n    })).ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n})).to.be.rejected; // Should fail as token already used&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b65a7bcc-e335-4368-833d-7bffcf33209b&quot;,&quot;parentUUID&quot;:&quot;55f34d79-a0ba-4afd-a9d9-4a3a6670fdac&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;53ebc721-926d-4ced-aba7-b0f5d401d199&quot;,&quot;b65a7bcc-e335-4368-833d-7bffcf33209b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:40887,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;5d46b2f9-e1ce-4b3a-9889-18b8fd37bfe0&quot;,&quot;title&quot;:&quot;Batch Operation Edge Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should handle partial failures in batch registration&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases Batch Operation Edge Cases should handle partial failures in batch registration&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15138,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nawait client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n});\nawait (0, chai_1.expect)(client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId1, // Already registered\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2, // New registration\n        },\n    ],\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0c56626f-b5ce-4b77-950f-84ffca94ad26&quot;,&quot;parentUUID&quot;:&quot;5d46b2f9-e1ce-4b3a-9889-18b8fd37bfe0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;0c56626f-b5ce-4b77-950f-84ffca94ad26&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:15138,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;bb91f955-301e-44c2-a121-6259805b28d0&quot;,&quot;title&quot;:&quot;Batch Register IP Assets With Optimized Workflows&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Batch Register IP Assets With Optimized Workflows\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows \&quot;before all\&quot; hook in \&quot;Batch Register IP Assets With Optimized Workflows\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:58664,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create a public minting NFT collection\nconst publicMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;Public Minting Collection\&quot;,\n    symbol: \&quot;PMC\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \&quot;\&quot;,\n});\nspgNftContractWithPublicMintingWithWip = publicMintingCollectionResult.spgNftContract;\n// Create a private minting NFT collection\nconst privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;Private Minting Collection\&quot;,\n    symbol: \&quot;PRC\&quot;,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: generated_1.erc20Address[util_1.aeneid],\n    contractURI: \&quot;\&quot;,\n});\nspgNftContractWithPrivateMintingWithErc20 = privateMintingCollectionResult.spgNftContract;\n// Register a commercial remix PIL license\nconst commercialRemixPILResult = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 10n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n}));\nlicenseTermsIdWithWIP = commercialRemixPILResult.licenseTermsId;\n// Register a commercial use PIL license\nconst commercialUsePILResult = await client.license.registerPILTerms({\n    transferable: true,\n    royaltyPolicy: \&quot;0xBe54FB168b3c982b7AaE60dB6CF75Bd8447b390E\&quot;,\n    defaultMintingFee: 5n,\n    expiration: 0n,\n    commercialUse: true,\n    commercialAttribution: true,\n    commercializerChecker: viem_1.zeroAddress,\n    commercializerCheckerData: viem_1.zeroAddress,\n    commercialRevShare: 10,\n    commercialRevCeiling: 0n,\n    derivativesAllowed: true,\n    derivativesAttribution: true,\n    derivativesApproval: false,\n    derivativesReciprocal: true,\n    derivativeRevCeiling: 0n,\n    currency: generated_1.erc20Address[util_1.aeneid],\n    uri: \&quot;https://github.com/piplabs/pil-document/blob/ad67bb632a310d2557f8abcccd428e4c9c798db1/off-chain-terms/CommercialRemix.json\&quot;,\n});\nlicenseTermsIdWithErc20 = commercialUsePILResult.licenseTermsId;\n// Mint and register IP with public minting contract\nconst publicMintingIpResult = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPublicMintingWithWip,\n});\nparentIpId1 = publicMintingIpResult.ipId;\n// Attach license terms to the first IP\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId1,\n    licenseTermsId: licenseTermsIdWithWIP,\n});\n// Mint and register IP with private minting contract\nconst privateMintingIpResult = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n});\nparentIpId2 = privateMintingIpResult.ipId;\n// Attach license terms to the second IP\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId2,\n    licenseTermsId: licenseTermsIdWithErc20,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5d8fc064-0b5e-4d60-abc8-5d2fe423cd06&quot;,&quot;parentUUID&quot;:&quot;bb91f955-301e-44c2-a121-6259805b28d0&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully batch register multiple IP assets with SPG NFT contracts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully batch register multiple IP assets with SPG NFT contracts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:44113,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10 WIP tokens + 10 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15 WIP tokens + 5 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the ERC20 token is used\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 0 WIP tokens + 10 ERC20 tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall due to the private minting\n     * - Two license terms\n     * - `maxLicenseTokens` is set to 1000n for first license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 1000n,\n            },\n            {\n                terms: src_1.PILFlavor.commercialUse({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 3n,\n                    override: {\n                        commercialRevShare: 90,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesReciprocal: true,\n                        commercialAttribution: false,\n                    },\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 3n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     * - One license terms\n     * - `maxLicenseTokens` is set to 100n for license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 0n,\n                    commercialRevShare: 90,\n                    override: {\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesReciprocal: true,\n                        commercialAttribution: false,\n                    },\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 100n,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 20(10+10) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 3.000301,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10 ERC20 tokens +5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.434,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the mint tokens is given `msg.sender` as the recipient\n     * - Two license terms\n     * - `maxLicenseTokens` is set to 80n and 10n for license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                maxLicenseTokens: 80n,\n            },\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 100n,\n                    commercialRevShare: 0,\n                    override: {\n                        derivativesReciprocal: true,\n                        commercialAttribution: false,\n                        expiration: 1000n,\n                    },\n                }),\n                maxLicenseTokens: 10n,\n            },\n        ],\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 1.211,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens + 10 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the mint tokens is given `msg.sender` as the recipient\n     * - One license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.creativeCommonsAttribution({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    override: {\n                        defaultMintingFee: 10000n,\n                    },\n                }),\n            },\n        ],\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 1.231,\n            },\n        ],\n    },\n];\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\n/**\n * Transaction breakdown:\n *\n * 1. derivativeWorkflowsClient: 2 args\n *    - First arg:\n *      - 10WIP tokens +10 ERC20 tokens\n *    - Second arg:\n *      - 15WIP tokens + 5 ERC20 tokens\n *\n * 2. licenseAttachmentWorkflowsClient: 1 args\n *    - 10 ERC20 tokens\n *    - Two license terms attached\n *    - First license terms: maxLicenseTokens: 1000n\n *\n * 3. multicall3Client: 2 args\n *    - First arg:\n *      - 10 WIP tokens\n *      - One license terms\n *      - First license terms: maxLicenseTokens: 100n\n *    - Second arg:\n *      - 20 WIP tokens\n *\n * 3. multicall3Client: 2 args\n *    - First arg:\n *      - 10 WIP tokens\n *      - One license terms\n *      - First license terms: maxLicenseTokens: 100n\n *    - Second arg:\n *      - 20 WIP tokens\n *\n * 4. royaltyTokenDistributionWorkflowsClient: 3 args\n *    - First arg:\n *      - 10 ERC20+ 5 ERC20 tokens\n *    - Second arg:\n *      - 15 WIP tokens\n *      - Two license terms\n *      - First license terms: maxLicenseTokens: 80n\n *      - Second license terms: maxLicenseTokens: 10n\n *    - Third arg:\n *      - 10 ERC20 tokens\n *      - One license terms\n *\n * Summary:\n * - Total transactions: 4 (4 unique transaction hashes)\n * - Total IP assets registered: 8\n */\nconst totalFeesForWIP = 10 + 15 + 10 + 20 + 15;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFeesForWIP)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(4);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes).equal(undefined);\n// Derivative workflow\n// First arg\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(undefined);\n// Second arg\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(undefined);\n// license attachment workflow\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n// multicall3 workflow\n// First arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(2);\n// First arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n// Second arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(undefined);\n// royalty token distribution workflow\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(3);\n// First arg\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(undefined);\n// Second arg\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(2);\n// Third arg\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(undefined);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d72f25b0-447a-4ebf-b9b8-efc07f846eb8&quot;,&quot;parentUUID&quot;:&quot;bb91f955-301e-44c2-a121-6259805b28d0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully batch register multiple IP assets with NFT contracts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully batch register multiple IP assets with NFT contracts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:72858,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst tokenId4 = await (0, util_1.getTokenId)();\nconst tokenId5 = await (0, util_1.getTokenId)();\nconst tokenId6 = await (0, util_1.getTokenId)();\nconst tokenId7 = await (0, util_1.getTokenId)();\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst requests = [\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerIpAndAttachPilTerms  workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall\n     * - Two license terms\n     * - `maxLicenseTokens` is set to 100n for second license terms\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId3,\n        deadline: 1000n,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 0n,\n                    commercialRevShare: 100,\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 10000n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 100n,\n            },\n        ],\n    },\n    /**\n     * registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Two license terms\n     * - Need to distribute royalty tokens\n     * - `maxLicenseTokens` is set to 10n for first license terms\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId4,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 1n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n            {\n                terms: src_1.PILFlavor.creativeCommonsAttribution({\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 6n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n        ],\n        ipMetadata: {\n            ipMetadataURI: \&quot;test-uri\&quot;,\n            ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n            nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 43.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 17.0003011,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 2.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 30.0003012,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId5,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId6,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId7,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.434,\n            },\n        ],\n    },\n];\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\n/**\n * Transaction breakdown:\n * 1. royaltyTokenDistributionWorkflowsClient: 4 args\n *  - First arg:\n *    - 10 WIP tokens\n *    - Need to distribute royalty tokens\n *  - Second arg:\n *    - 5 ERC20 tokens\n *    - Need to distribute royalty tokens\n *  - Third arg:\n *    - 0 WIP tokens\n *    - Two license terms\n *    - First license terms: maxLicenseTokens: 10n\n *    - Need to distribute royalty tokens\n *  - Fourth arg:\n *    - 5 ERC20 tokens\n *    - Need to distribute royalty tokens\n * 2. licenseAttachmentWorkflowsClient: 1 arg\n *  - 0 WIP tokens\n *  - Two license terms\n *  - Second license terms: maxLicenseTokens: 100n\n * 3. derivativeWorkflowsClient: 2 args\n *  - First arg:\n *    - 5 ERC20 tokens\n *  - Second arg:\n *    - 10 WIP tokens\n *\n * Summary:\n * - Total transactions: 3 (3 unique transaction hashes)\n * - Total IP assets registered: 7\n */\nconst totalFees = 10 + 10;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(3);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).equal(1);\n// royaltyTokenDistributionWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(4);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[0].ipRoyaltyVault?.length).equal(4);\n// licenseAttachmentWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipRoyaltyVault?.length).equal(0);\n//derivativeWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipRoyaltyVault?.length).equal(0);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;24aafa38-b747-43ee-bda3-4c1a8a430f76&quot;,&quot;parentUUID&quot;:&quot;bb91f955-301e-44c2-a121-6259805b28d0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register IP assets using a combination of NFT contracts and SPG NFT contracts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully register IP assets using a combination of NFT contracts and SPG NFT contracts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:66418,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst tokenId4 = await (0, util_1.getTokenId)();\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10 WIP tokens +5 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall3 due to contains ERC20 token\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10 ERC20 tokens+ 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.434,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 20(10+10) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.4341111111,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10 ERC20 tokens+10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.2312332,\n            },\n        ],\n    },\n    /**\n     * registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     * - One license terms\n     * - `maxLicenseTokens` is set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 1n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n        ipMetadata: {\n            ipMetadataURI: \&quot;test-uri\&quot;,\n            ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n            nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 43.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 17.0003011,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 2.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 30.0003012,\n            },\n        ],\n    },\n    /**\n     * registerIpAndAttachPilTerms  workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall\n     * - Two license terms\n     * - The second request has `maxLicenseTokens` set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId3,\n        deadline: 1000n,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 0n,\n                    commercialRevShare: 100,\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 10000n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId4,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n];\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\n/**\n * Transaction breakdown:\n * 1. derivativeWorkflowsClient:3 args\n * - First arg\n *   - 10 WIP tokens+ 5 ERC20 tokens\n * - Second arg\n *   - 10 ERC20 + 10 WIP tokens\n * - Third arg\n *   - 10 WIP tokens\n *\n * 2. royaltyTokenDistributionWorkflowsClient: 3 args\n *  - First arg\n *    - 15 ERC20 tokens\n *  - Second arg\n *    - 5 ERC20 tokens\n *    - Need to distribute royalty tokens\n *  - Third arg\n *    - 0 WIP tokens\n *    - One license terms\n *    - First license terms: maxLicenseTokens: 10n\n *    - Need to distribute royalty tokens\n *\n * 3. licenseAttachmentWorkflowsClient: 1 arg\n * - 0 WIP tokens\n * - Two license terms\n * - Second license terms: maxLicenseTokens: 100n\n *\n * Summary:\n * - Total transactions: 4 (4 unique transaction hashes)\n * - Total IP assets registered: 8\n */\nconst totalFeesWithWIP = 10 + 10 + 10;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFeesWithWIP)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(4);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).equal(1);\n// derivativeWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[0].ipRoyaltyVault?.length).equal(0);\n// royaltyTokenDistributionWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipRoyaltyVault?.length).equal(2);\n//licenseAttachmentWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipRoyaltyVault?.length).equal(0);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b755274a-24f2-469d-a881-748b35924ab3&quot;,&quot;parentUUID&quot;:&quot;bb91f955-301e-44c2-a121-6259805b28d0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register IP assets with multicall disabled&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully register IP assets with multicall disabled&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:47231,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15(10+5) WIP tokens\n     * - Uses `derivativeWorkflowsClient` to call the this method\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` to call the this method\n     * - One license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` to call the this method\n     * - Two license terms\n     * - The first request has `maxLicenseTokens` set to 10n\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 10n,\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient`to call the this method\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.4341212321,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient`to call the this method\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 3.000301,\n            },\n        ],\n    },\n];\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n    options: {\n        wipOptions: {\n            useMulticallWhenPossible: false,\n        },\n    },\n});\n/**\n * Transaction breakdown:\n *  1. derivativeWorkflowsClient:1 arg\n *    - 15 WIP\n * 2. licenseAttachmentWorkflowsClient: 2 args\n *    - First arg\n *      - 0 WIP tokens\n *      - One license terms\n *    - Second arg\n *      - 10  WIP tokens\n *      - Two license terms\n *      - First license terms: maxLicenseTokens: 10n\n * 3. royaltyTokenDistributionWorkflowsClient: 2 args\n *    - First arg\n *      - 5 ERC20 tokens\n *      - Need to distribute royalty tokens\n *    - Second arg\n *      - 5 ERC20 tokens\n *      - Need to distribute royalty tokens\n * Summary:\n * - Total transactions: 5 (5 unique transaction hashes) due to the multicall disabled\n * - Total IP assets registered: 5\n * - Two distribute royalty tokens transactions\n */\nconst totalFees = 15 + 10;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(requests.length);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).equal(2);\n//derivativeWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipRoyaltyVault?.length).equal(0);\n//licenseAttachmentWorkflowsClient\n//First arg\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n//Second arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n//royaltyTokenDistributionWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipRoyaltyVault?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[4].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[4].ipRoyaltyVault?.length).equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0facb406-b05d-4b81-939a-085e545486b0&quot;,&quot;parentUUID&quot;:&quot;bb91f955-301e-44c2-a121-6259805b28d0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;d72f25b0-447a-4ebf-b9b8-efc07f846eb8&quot;,&quot;24aafa38-b747-43ee-bda3-4c1a8a430f76&quot;,&quot;b755274a-24f2-469d-a881-748b35924ab3&quot;,&quot;0facb406-b05d-4b81-939a-085e545486b0&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:230620,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;54b77adc-ed3c-4585-8a56-1e8693b8d6f8&quot;,&quot;title&quot;:&quot;Batch Mint and Register IP Asset&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Batch Mint and Register IP Asset\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset \&quot;before all\&quot; hook in \&quot;Batch Mint and Register IP Asset\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9862,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const publicMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContractWithPublicMinting = publicMintingCollectionResult.spgNftContract;\nconst privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 20n,\n    mintFeeToken: generated_1.erc20Address[util_1.aeneid],\n});\nspgNftContractWithPrivateMinting = privateMintingCollectionResult.spgNftContract;\nconst { address } = await (0, BIP32_1.getDerivedStoryClient)();\nanotherWalletAddress = address;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;317210e9-ce0e-4ba2-9919-25bad85abc8a&quot;,&quot;parentUUID&quot;:&quot;54b77adc-ed3c-4585-8a56-1e8693b8d6f8&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when public minting of spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should successfully when public minting of spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6379,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst { registrationResults } = await client.ipAsset.batchMintAndRegisterIp({\n    requests: [\n        { spgNftContract: spgNftContractWithPublicMinting },\n        { spgNftContract: spgNftContractWithPublicMinting, recipient: anotherWalletAddress },\n        { spgNftContract: spgNftContractWithPublicMinting, allowDuplicates: false },\n    ],\n});\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(registrationResults.length).equal(1);\n(0, chai_1.expect)(registrationResults[0].ipIdsAndTokenIds.length).equal(3);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d23abccc-54d2-434b-a7a5-208388b07eef&quot;,&quot;parentUUID&quot;:&quot;54b77adc-ed3c-4585-8a56-1e8693b8d6f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when private minting of spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should successfully when private minting of spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11355,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst { registrationResults } = await client.ipAsset.batchMintAndRegisterIp({\n    requests: [\n        { spgNftContract: spgNftContractWithPrivateMinting },\n        { spgNftContract: spgNftContractWithPrivateMinting, recipient: anotherWalletAddress },\n        {\n            spgNftContract: spgNftContractWithPrivateMinting,\n            allowDuplicates: false,\n            recipient: anotherWalletAddress,\n        },\n    ],\n});\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(registrationResults.length).equal(1);\n(0, chai_1.expect)(registrationResults[0].ipIdsAndTokenIds.length).equal(3);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c60552d2-e44f-464f-9e15-35486280d815&quot;,&quot;parentUUID&quot;:&quot;54b77adc-ed3c-4585-8a56-1e8693b8d6f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when hybrid private minting and public minting of spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should successfully when hybrid private minting and public minting of spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11946,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst { registrationResults } = await client.ipAsset.batchMintAndRegisterIp({\n    requests: [\n        { spgNftContract: spgNftContractWithPublicMinting },\n        { spgNftContract: spgNftContractWithPrivateMinting, recipient: anotherWalletAddress },\n        { spgNftContract: spgNftContractWithPrivateMinting, allowDuplicates: false },\n        { spgNftContract: spgNftContractWithPublicMinting, recipient: anotherWalletAddress },\n    ],\n});\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(registrationResults.length).equal(2);\n(0, chai_1.expect)(registrationResults[0].ipIdsAndTokenIds.length).equal(2);\n(0, chai_1.expect)(registrationResults[1].ipIdsAndTokenIds.length).equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9a468409-2911-4788-bb6d-6ff00a7ea877&quot;,&quot;parentUUID&quot;:&quot;54b77adc-ed3c-4585-8a56-1e8693b8d6f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when private minting of spgNftContract but caller does not have the minter role&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should fail when private minting of spgNftContract but caller does not have the minter role&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5362,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Register a new SPG NFT contract with private minting with clientB\nconst { address, clientB } = await (0, BIP32_1.getDerivedStoryClient)();\nconst { spgNftContract: privateMintingContractOfClientB } = await clientB.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: address,\n    contractURI: \&quot;test-uri\&quot;,\n});\nawait (0, chai_1.expect)(client.ipAsset.batchMintAndRegisterIp({\n    requests: [{ spgNftContract: privateMintingContractOfClientB }],\n})).to.be.rejectedWith(\&quot;does not have the minter role\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ee8c807e-b779-4d34-899c-07467c2bc1ab&quot;,&quot;parentUUID&quot;:&quot;54b77adc-ed3c-4585-8a56-1e8693b8d6f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;d23abccc-54d2-434b-a7a5-208388b07eef&quot;,&quot;c60552d2-e44f-464f-9e15-35486280d815&quot;,&quot;9a468409-2911-4788-bb6d-6ff00a7ea877&quot;,&quot;ee8c807e-b779-4d34-899c-07467c2bc1ab&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:35042,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;990dbe3c-17db-4013-a97f-2a8395df99e6&quot;,&quot;title&quot;:&quot;Register ip asset with minted and mint nft&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;bd593be7-1c9f-4153-a9c6-9d3fa6afd57e&quot;,&quot;title&quot;:&quot;Register IP Asset with Minted NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give license terms data and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when give license terms data and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:16742,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 2.000000001,\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds.length).to.be.equal(1);\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;059cef6a-b877-4a9d-92fe-0757910ebfed&quot;,&quot;parentUUID&quot;:&quot;bd593be7-1c9f-4153-a9c6-9d3fa6afd57e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give license terms data without royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when give license terms data without royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11232,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cea36492-5420-47d8-a425-87b03ad7ba68&quot;,&quot;parentUUID&quot;:&quot;bd593be7-1c9f-4153-a9c6-9d3fa6afd57e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when without license terms data, royalty shares, ip metadata&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when without license terms data, royalty shares, ip metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14261,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;962a01cc-dab7-4021-99c2-d6e29a2ebe33&quot;,&quot;parentUUID&quot;:&quot;bd593be7-1c9f-4153-a9c6-9d3fa6afd57e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when without license terms data and royalty shares, with ip metadata&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when without license terms data and royalty shares, with ip metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10118,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataURI: \&quot;test-nft-uri\&quot;,\n    },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8d75b940-cc5d-4e70-a5b9-1a44643916cc&quot;,&quot;parentUUID&quot;:&quot;bd593be7-1c9f-4153-a9c6-9d3fa6afd57e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;059cef6a-b877-4a9d-92fe-0757910ebfed&quot;,&quot;cea36492-5420-47d8-a425-87b03ad7ba68&quot;,&quot;962a01cc-dab7-4021-99c2-d6e29a2ebe33&quot;,&quot;8d75b940-cc5d-4e70-a5b9-1a44643916cc&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:52353,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;5e913d69-fe13-48c8-a8dc-71e9d1a50d3a&quot;,&quot;title&quot;:&quot;Register IP Asset by minting a new NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Register IP Asset by minting a new NFT\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT \&quot;before all\&quot; hook in \&quot;Register IP Asset by minting a new NFT\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9024,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST_FOR_MINT\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cb2de9ba-e830-4ec7-9045-e7be655348a7&quot;,&quot;parentUUID&quot;:&quot;5e913d69-fe13-48c8-a8dc-71e9d1a50d3a&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give license terms data and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT should successfully when give license terms data and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17112,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgNftContract },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 0.000001,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ae1b316b-af76-47b8-a76f-8d1e606800c4&quot;,&quot;parentUUID&quot;:&quot;5e913d69-fe13-48c8-a8dc-71e9d1a50d3a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give license terms data without royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT should successfully when give license terms data without royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12369,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgNftContract },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9a23916b-737e-4ad1-a4e3-16a157a39047&quot;,&quot;parentUUID&quot;:&quot;5e913d69-fe13-48c8-a8dc-71e9d1a50d3a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when without license terms data and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT should successfully when without license terms data and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10453,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgNftContract },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataURI: \&quot;test-nft-uri\&quot;,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;af0f71ed-1c5f-4195-9caf-35fb67c56a31&quot;,&quot;parentUUID&quot;:&quot;5e913d69-fe13-48c8-a8dc-71e9d1a50d3a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;ae1b316b-af76-47b8-a76f-8d1e606800c4&quot;,&quot;9a23916b-737e-4ad1-a4e3-16a157a39047&quot;,&quot;af0f71ed-1c5f-4195-9caf-35fb67c56a31&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:39934,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;c88173c1-e455-46ca-8267-28074759aa7a&quot;,&quot;title&quot;:&quot;Register derivative IP Asset&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Register derivative IP Asset\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset \&quot;before all\&quot; hook in \&quot;Register derivative IP Asset\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14932,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\nparentIpId = result.ipId;\ncommercialRemixLicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c3176fe6-7aab-4aa6-acb0-f8f33c9d641a&quot;,&quot;parentUUID&quot;:&quot;c88173c1-e455-46ca-8267-28074759aa7a&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;415f4098-8583-47da-9c43-d48159556acb&quot;,&quot;title&quot;:&quot;Register derivative IP Asset with Minted NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give derivData and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset with Minted NFT should successfully when give derivData and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:21240,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.equal(BigInt(tokenId));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5df9fade-cc20-4c48-aa6c-9d248117dad4&quot;,&quot;parentUUID&quot;:&quot;415f4098-8583-47da-9c43-d48159556acb&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully given derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset with Minted NFT should successfully given derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:24085,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.equal(BigInt(tokenId));\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;580c19a2-5efd-4cc3-b314-4dc34c097cf3&quot;,&quot;parentUUID&quot;:&quot;415f4098-8583-47da-9c43-d48159556acb&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully given licenseTokenIds and maxRts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset with Minted NFT should successfully given licenseTokenIds and maxRts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:20756,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: commercialRemixLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenIds[0]);\nconst tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    licenseTokenIds: licenseTokenIds,\n    maxRts: 100,\n    maxMintingFee: 10000n,\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.equal(BigInt(tokenId));\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2dde5f9b-fd78-4784-8f1e-204455f6292a&quot;,&quot;parentUUID&quot;:&quot;415f4098-8583-47da-9c43-d48159556acb&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;5df9fade-cc20-4c48-aa6c-9d248117dad4&quot;,&quot;580c19a2-5efd-4cc3-b314-4dc34c097cf3&quot;,&quot;2dde5f9b-fd78-4784-8f1e-204455f6292a&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:66081,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;cce6bb13-b1e2-4ef1-920d-134e5b632651&quot;,&quot;title&quot;:&quot;Register derivative IP Asset by minting a new NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Register derivative IP Asset by minting a new NFT\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT \&quot;before all\&quot; hook in \&quot;Register derivative IP Asset by minting a new NFT\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4888,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST_FOR_MINT\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;93a2a108-b2c2-4f48-92bd-720320373bd7&quot;,&quot;parentUUID&quot;:&quot;cce6bb13-b1e2-4ef1-920d-134e5b632651&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give derivData and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT should successfully when give derivData and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:16150,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 1.23,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9c504970-fc5d-4d90-acbb-c474fd85ab3a&quot;,&quot;parentUUID&quot;:&quot;cce6bb13-b1e2-4ef1-920d-134e5b632651&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give licenseTokenIds and maxRts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT should successfully when give licenseTokenIds and maxRts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:29415,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: commercialRemixLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenIds[0]);\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract },\n    licenseTokenIds: licenseTokenIds,\n    maxRts: 100,\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;862a7073-0121-40ab-8a2e-38e2de48c4fb&quot;,&quot;parentUUID&quot;:&quot;cce6bb13-b1e2-4ef1-920d-134e5b632651&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT should successfully when give derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11222,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;aea8cb68-d340-495b-91c0-15519ad8f744&quot;,&quot;parentUUID&quot;:&quot;cce6bb13-b1e2-4ef1-920d-134e5b632651&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;9c504970-fc5d-4d90-acbb-c474fd85ab3a&quot;,&quot;862a7073-0121-40ab-8a2e-38e2de48c4fb&quot;,&quot;aea8cb68-d340-495b-91c0-15519ad8f744&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:56787,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;ea75fe82-6f49-4593-aa8e-b8b3d8750717&quot;,&quot;title&quot;:&quot;Link Derivative&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Link Derivative\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative \&quot;before all\&quot; hook in \&quot;Link Derivative\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10703,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\nparentIpId = result.ipId;\ncommercialRemixLicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7a750336-b8a9-4bd3-bcdb-6a448f6b2d15&quot;,&quot;parentUUID&quot;:&quot;ea75fe82-6f49-4593-aa8e-b8b3d8750717&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give childIpId and licenseTokenIds&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative should successfully when give childIpId and licenseTokenIds&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:20720,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: commercialRemixLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;397223bb-5f8c-4e93-aa6c-b126e3c2b7ee&quot;,&quot;parentUUID&quot;:&quot;ea75fe82-6f49-4593-aa8e-b8b3d8750717&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give parentIpId and licenseTokenIds&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative should successfully when give parentIpId and licenseTokenIds&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:20552,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [commercialRemixLicenseTermsId],\n    maxMintingFee: 0,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: 0,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;762868a6-e2e1-4305-b9bb-ee35e36cbb4c&quot;,&quot;parentUUID&quot;:&quot;ea75fe82-6f49-4593-aa8e-b8b3d8750717&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;397223bb-5f8c-4e93-aa6c-b126e3c2b7ee&quot;,&quot;762868a6-e2e1-4305-b9bb-ee35e36cbb4c&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:41272,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;882f9eb5-1ad0-4b8f-878b-7f36bffb873f&quot;,&quot;title&quot;:&quot;with ERC20 and WIP token fee&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;with ERC20 and WIP token fee\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee \&quot;before all\&quot; hook in \&quot;with ERC20 and WIP token fee\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:26693,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;spgContractWith100WIP = (await client.nftClient.createNFTCollection({\n    name: \&quot;100 WIP\&quot;,\n    symbol: \&quot;100WIP\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 100n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \&quot;\&quot;,\n})).spgNftContract;\nspgContractWith10ERC20 = (await client.nftClient.createNFTCollection({\n    name: \&quot;10 ERC20\&quot;,\n    symbol: \&quot;10ERC20\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 100n,\n    mintFeeToken: generated_1.erc20Address[util_1.aeneid],\n    contractURI: \&quot;\&quot;,\n})).spgNftContract;\nconst result1 = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\nparentIpIdForWIP = result1.ipId;\nlicenseTermsIdFor100WIP = result1.licenseTermsIds[0];\nconst result2 = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10n,\n                commercialRevShare: 10,\n                currency: generated_1.erc20Address[util_1.aeneid],\n            }),\n        },\n    ],\n});\nparentIpIdForERC20 = result2.ipId;\nlicenseTermsIdFor10ERC20 = result2.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b6c548b6-da5f-4d14-83ec-d06175ad696e&quot;,&quot;parentUUID&quot;:&quot;882f9eb5-1ad0-4b8f-878b-7f36bffb873f&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;cb54e0f8-ec45-4560-85c9-97c1ff9f30fb&quot;,&quot;title&quot;:&quot;SpgNftContract with ERC20 token&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when register ip with license terms data and royalty shares for ERC20&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register ip with license terms data and royalty shares for ERC20&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6074,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a64ce7e9-21dd-4b23-94b7-5187e11fb20f&quot;,&quot;parentUUID&quot;:&quot;cb54e0f8-ec45-4560-85c9-97c1ff9f30fb&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register ip with license terms data&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register ip with license terms data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5813,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: generated_1.erc20Address[util_1.aeneid],\n            }),\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7fdeac16-f5dd-4230-92fd-04aa5e56f08f&quot;,&quot;parentUUID&quot;:&quot;cb54e0f8-ec45-4560-85c9-97c1ff9f30fb&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register ip with spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register ip with spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5299,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;91136c52-9d45-4b76-b241-506758b116ca&quot;,&quot;parentUUID&quot;:&quot;cb54e0f8-ec45-4560-85c9-97c1ff9f30fb&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with derivData and royalty shares for ERC20&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register derivative ip with derivData and royalty shares for ERC20&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10158,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForERC20],\n        licenseTermsIds: [licenseTermsIdFor10ERC20],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d7f81b04-9097-4733-ac2c-10568e1f0f0d&quot;,&quot;parentUUID&quot;:&quot;cb54e0f8-ec45-4560-85c9-97c1ff9f30fb&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with license token ids and derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register derivative ip with license token ids and derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11470,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsIdFor10ERC20,\n    licensorIpId: parentIpIdForERC20,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForERC20],\n        licenseTermsIds: [licenseTermsIdFor10ERC20],\n    },\n    licenseTokenIds: licenseTokenIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9fbd73d4-9c69-4db1-9769-14f0dbaaecac&quot;,&quot;parentUUID&quot;:&quot;cb54e0f8-ec45-4560-85c9-97c1ff9f30fb&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register derivative ip with derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6063,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForERC20],\n        licenseTermsIds: [licenseTermsIdFor10ERC20],\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;00d3ba8d-f89c-4fab-ac4a-b0e7a8c2393a&quot;,&quot;parentUUID&quot;:&quot;cb54e0f8-ec45-4560-85c9-97c1ff9f30fb&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when link derivative ip given childIpId and license token ids&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when link derivative ip given childIpId and license token ids&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15429,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpIdForERC20],\n    licenseTermsIds: [licenseTermsIdFor10ERC20],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;da35e7e6-3260-4cc7-a39f-69613c2c8291&quot;,&quot;parentUUID&quot;:&quot;cb54e0f8-ec45-4560-85c9-97c1ff9f30fb&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a64ce7e9-21dd-4b23-94b7-5187e11fb20f&quot;,&quot;7fdeac16-f5dd-4230-92fd-04aa5e56f08f&quot;,&quot;91136c52-9d45-4b76-b241-506758b116ca&quot;,&quot;d7f81b04-9097-4733-ac2c-10568e1f0f0d&quot;,&quot;9fbd73d4-9c69-4db1-9769-14f0dbaaecac&quot;,&quot;00d3ba8d-f89c-4fab-ac4a-b0e7a8c2393a&quot;,&quot;da35e7e6-3260-4cc7-a39f-69613c2c8291&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:60306,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;a271f10c-04d2-40f3-aede-8cd9f14073c5&quot;,&quot;title&quot;:&quot;SpgNftContract with WIP token&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when register ip with license terms data and royalty shares for WIP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register ip with license terms data and royalty shares for WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15967,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;30c1e134-5348-486a-83e2-67b51b7d68ab&quot;,&quot;parentUUID&quot;:&quot;a271f10c-04d2-40f3-aede-8cd9f14073c5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register ip with license terms data&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register ip with license terms data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6098,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c327ed70-8800-428a-ba42-761aaa6351fe&quot;,&quot;parentUUID&quot;:&quot;a271f10c-04d2-40f3-aede-8cd9f14073c5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register ip with spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register ip with spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10390,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;622b3f7a-d65a-4e6f-a030-0fae02e12889&quot;,&quot;parentUUID&quot;:&quot;a271f10c-04d2-40f3-aede-8cd9f14073c5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with derivData and royalty shares for WIP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register derivative ip with derivData and royalty shares for WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6410,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;48505060-67a4-4295-9128-972d4f613627&quot;,&quot;parentUUID&quot;:&quot;a271f10c-04d2-40f3-aede-8cd9f14073c5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with license token ids and derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register derivative ip with license token ids and derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:16068,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsIdFor100WIP,\n    licensorIpId: parentIpIdForWIP,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n    licenseTokenIds: licenseTokenIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1ed03328-9d2d-46c0-9753-3389f745dc98&quot;,&quot;parentUUID&quot;:&quot;a271f10c-04d2-40f3-aede-8cd9f14073c5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register derivative ip with derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6292,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d5797684-59f8-4768-9c90-f9f566f80285&quot;,&quot;parentUUID&quot;:&quot;a271f10c-04d2-40f3-aede-8cd9f14073c5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when link derivative ip given childIpId and license token ids&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when link derivative ip given childIpId and license token ids&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:24726,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpIdForWIP],\n    licenseTermsIds: [licenseTermsIdFor100WIP],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2540500a-74e0-4d1a-a883-dafb249f1ffe&quot;,&quot;parentUUID&quot;:&quot;a271f10c-04d2-40f3-aede-8cd9f14073c5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;30c1e134-5348-486a-83e2-67b51b7d68ab&quot;,&quot;c327ed70-8800-428a-ba42-761aaa6351fe&quot;,&quot;622b3f7a-d65a-4e6f-a030-0fae02e12889&quot;,&quot;48505060-67a4-4295-9128-972d4f613627&quot;,&quot;1ed03328-9d2d-46c0-9753-3389f745dc98&quot;,&quot;d5797684-59f8-4768-9c90-f9f566f80285&quot;,&quot;2540500a-74e0-4d1a-a883-dafb249f1ffe&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:85951,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;b037e52a-fdd9-460b-8654-bf8d679b7e6d&quot;,&quot;title&quot;:&quot;Mixed ERC20 and WIP token&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when register derivative ip with derivData and royalty shares for mixed ERC20 and WIP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee Mixed ERC20 and WIP token should successfully when register derivative ip with derivData and royalty shares for mixed ERC20 and WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15315,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6b5a9aae-2838-443e-babf-3f43a66e4614&quot;,&quot;parentUUID&quot;:&quot;b037e52a-fdd9-460b-8654-bf8d679b7e6d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with license token ids and derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee Mixed ERC20 and WIP token should successfully when register derivative ip with license token ids and derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:16919,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsIdFor100WIP,\n    licensorIpId: parentIpIdForWIP,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n    licenseTokenIds: licenseTokenIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fb82f4aa-b218-436b-8a20-4d66b7ae3e14&quot;,&quot;parentUUID&quot;:&quot;b037e52a-fdd9-460b-8654-bf8d679b7e6d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;6b5a9aae-2838-443e-babf-3f43a66e4614&quot;,&quot;fb82f4aa-b218-436b-8a20-4d66b7ae3e14&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:32234,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;0d2f2fa2-947e-40e6-affa-70e29b0d5c69&quot;,&quot;title&quot;:&quot;License Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;License Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions \&quot;before all\&quot; hook in \&quot;License Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:91,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nclientB = derivedClient.clientB;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2c6fe0e6-dfe8-42d0-a38f-17310d662391&quot;,&quot;parentUUID&quot;:&quot;0d2f2fa2-947e-40e6-affa-70e29b0d5c69&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;5f2b6371-5e6f-4640-8cf8-2265a4a99311&quot;,&quot;title&quot;:&quot;register license with different types&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register license &quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license &quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:99,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerPILTerms({\n    defaultMintingFee: 0,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    transferable: false,\n    royaltyPolicy: viem_1.zeroAddress,\n    commercialUse: false,\n    commercialAttribution: false,\n    commercializerChecker: viem_1.zeroAddress,\n    commercializerCheckerData: \&quot;0x\&quot;,\n    commercialRevShare: 0,\n    derivativesAllowed: false,\n    derivativesAttribution: false,\n    derivativesApproval: false,\n    derivativesReciprocal: false,\n    uri: \&quot;\&quot;,\n    expiration: 0,\n    commercialRevCeiling: 0,\n    derivativeRevCeiling: 0,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a5b4f60a-6797-48cc-ac2e-ebaa8eefe451&quot;,&quot;parentUUID&quot;:&quot;5f2b6371-5e6f-4640-8cf8-2265a4a99311&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with non commercial social remixing PIL&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with non commercial social remixing PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:83,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerNonComSocialRemixingPIL();\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;06c2cfea-8f38-4cad-94ab-7d31705f190e&quot;,&quot;parentUUID&quot;:&quot;5f2b6371-5e6f-4640-8cf8-2265a4a99311&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with commercial use&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with commercial use&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:86,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerCommercialUsePIL({\n    defaultMintingFee: \&quot;1\&quot;,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7cf43a5d-8f04-43c6-bd7b-0f9fabf05216&quot;,&quot;parentUUID&quot;:&quot;5f2b6371-5e6f-4640-8cf8-2265a4a99311&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with commercial Remix use&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with commercial Remix use&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:85,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerCommercialRemixPIL({\n    defaultMintingFee: \&quot;1\&quot;,\n    commercialRevShare: 100,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e09241f6-ba80-4f16-998a-db4e89ffdb31&quot;,&quot;parentUUID&quot;:&quot;5f2b6371-5e6f-4640-8cf8-2265a4a99311&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with creative commons attribution PIL&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with creative commons attribution PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:84,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerCreativeCommonsAttributionPIL({\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicyAddress: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;26bb4871-ada1-469e-8c03-14c231dc6de5&quot;,&quot;parentUUID&quot;:&quot;5f2b6371-5e6f-4640-8cf8-2265a4a99311&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a5b4f60a-6797-48cc-ac2e-ebaa8eefe451&quot;,&quot;06c2cfea-8f38-4cad-94ab-7d31705f190e&quot;,&quot;7cf43a5d-8f04-43c6-bd7b-0f9fabf05216&quot;,&quot;e09241f6-ba80-4f16-998a-db4e89ffdb31&quot;,&quot;26bb4871-ada1-469e-8c03-14c231dc6de5&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:437,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;5ed49677-90f7-4215-8134-519a74a3e5a6&quot;,&quot;title&quot;:&quot;attach License Terms and mint license tokens&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;attach License Terms and mint license tokens\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens \&quot;before all\&quot; hook in \&quot;attach License Terms and mint license tokens\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18721,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;tokenId = await (0, util_1.getTokenId)();\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nconst mockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\nawait mockERC20.approve(generated_1.licensingModuleAddress[util_1.aeneid], viem_1.maxUint256);\nipId = registerResult.ipId;\nconst registerLicenseResult = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 0n,\n    commercialRevShare: 100,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n}));\nlicenseId = registerLicenseResult.licenseTermsId;\nconst paidLicenseResult = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 100n,\n    commercialRevShare: 10,\n    currency: generated_1.erc20Address[util_1.aeneid],\n}));\npaidLicenseId = paidLicenseResult.licenseTermsId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;220d999b-3b61-411c-9628-1ece3c717030&quot;,&quot;parentUUID&quot;:&quot;5ed49677-90f7-4215-8134-519a74a3e5a6&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should attach License Terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should attach License Terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5122,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fffad5d9-bffd-4e73-b38b-3f2b69264167&quot;,&quot;parentUUID&quot;:&quot;5ed49677-90f7-4215-8134-519a74a3e5a6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should be able to attach another license terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should be able to attach another license terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5132,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: paidLicenseId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;83a8cc45-af0b-4845-84d2-7e3f0465dc06&quot;,&quot;parentUUID&quot;:&quot;5ed49677-90f7-4215-8134-519a74a3e5a6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license tokens with ip owner&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license tokens with ip owner&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5222,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseId,\n    licensorIpId: ipId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9cb45495-c75a-44ae-acf1-1e871b80a7be&quot;,&quot;parentUUID&quot;:&quot;5ed49677-90f7-4215-8134-519a74a3e5a6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license tokens with non ip owner&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license tokens with non ip owner&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:20292,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// register ip with another wallet account\nconst tokenIdB = await (0, util_1.getTokenId)();\nconst registerResult = await clientB.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenIdB,\n});\nconst ipIdB = registerResult.ipId;\n// attach license terms to the ip\nawait client.license.attachLicenseTerms({\n    ipId: ipIdB,\n    licenseTermsId: licenseId,\n});\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseId,\n    licensorIpId: ipIdB,\n    maxMintingFee: 10000000,\n    maxRevenueShare: 100,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9ebaa688-6ba6-4cae-a147-14e7e0740702&quot;,&quot;parentUUID&quot;:&quot;5ed49677-90f7-4215-8134-519a74a3e5a6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license token with default license terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license token with default license terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5307,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// get default license terms id\nconst licenseRegistryReadOnlyClient = new generated_1.LicenseRegistryReadOnlyClient(util_1.publicClient);\nconst { licenseTermsId: defaultLicenseTermsId } = await licenseRegistryReadOnlyClient.getDefaultLicenseTerms();\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: defaultLicenseTermsId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 1,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f38d53bc-0fea-425d-a40a-8c83942b2dc5&quot;,&quot;parentUUID&quot;:&quot;5ed49677-90f7-4215-8134-519a74a3e5a6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license tokens with fee and pay with IP&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license tokens with fee and pay with IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5608,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const balanceBefore = await client.getWalletBalance();\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: paidLicenseId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 50,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 100n));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;42d100e9-f7d5-4ae2-a1aa-77d8eb3c64f0&quot;,&quot;parentUUID&quot;:&quot;5ed49677-90f7-4215-8134-519a74a3e5a6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should get license terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should get license terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:91,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.getLicenseTerms(licenseId);\n(0, chai_1.expect)(result).to.be.an(\&quot;object\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3aeae874-f8d4-4d7b-9bc2-41d852cca617&quot;,&quot;parentUUID&quot;:&quot;5ed49677-90f7-4215-8134-519a74a3e5a6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should predict minting license fee&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should predict minting license fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:253,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.predictMintingLicenseFee({\n    licenseTermsId: licenseId,\n    licensorIpId: ipId,\n    amount: 1,\n});\n(0, chai_1.expect)(result.currencyToken).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenAmount).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;93b08605-0e9f-4abe-9bb4-f2b2bdf5de77&quot;,&quot;parentUUID&quot;:&quot;5ed49677-90f7-4215-8134-519a74a3e5a6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;39e4ca95-04e1-4379-bc15-7f6da663d180&quot;,&quot;title&quot;:&quot;licensing config and max license tokens&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should set licensing config&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens licensing config and max license tokens should set licensing config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5035,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.setLicensingConfig({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n    licensingConfig,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;37c78cf2-d754-4e92-82d8-418d42318cc2&quot;,&quot;parentUUID&quot;:&quot;39e4ca95-04e1-4379-bc15-7f6da663d180&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should get licensing config&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens licensing config and max license tokens should get licensing config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:85,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.getLicensingConfig({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n});\n(0, chai_1.expect)(result).to.deep.equal({\n    ...licensingConfig,\n    expectMinimumGroupRewardShare: 1 * 10 ** 6,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a0524683-af74-4a09-8d0f-a25b3bde6cb3&quot;,&quot;parentUUID&quot;:&quot;39e4ca95-04e1-4379-bc15-7f6da663d180&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should set max license tokens&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens licensing config and max license tokens should set max license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10094,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.setMaxLicenseTokens({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n    maxLicenseTokens: 100,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;19aa3192-e319-4d32-8aef-df887edd658b&quot;,&quot;parentUUID&quot;:&quot;39e4ca95-04e1-4379-bc15-7f6da663d180&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;37c78cf2-d754-4e92-82d8-418d42318cc2&quot;,&quot;a0524683-af74-4a09-8d0f-a25b3bde6cb3&quot;,&quot;19aa3192-e319-4d32-8aef-df887edd658b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:15214,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;fffad5d9-bffd-4e73-b38b-3f2b69264167&quot;,&quot;83a8cc45-af0b-4845-84d2-7e3f0465dc06&quot;,&quot;9cb45495-c75a-44ae-acf1-1e871b80a7be&quot;,&quot;9ebaa688-6ba6-4cae-a147-14e7e0740702&quot;,&quot;f38d53bc-0fea-425d-a40a-8c83942b2dc5&quot;,&quot;42d100e9-f7d5-4ae2-a1aa-77d8eb3c64f0&quot;,&quot;3aeae874-f8d4-4d7b-9bc2-41d852cca617&quot;,&quot;93b08605-0e9f-4abe-9bb4-f2b2bdf5de77&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:47027,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;6ded351e-0c3c-4918-844d-7594efe6ea97&quot;,&quot;title&quot;:&quot;register pil terms and attach&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;register pil terms and attach\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions register pil terms and attach \&quot;before all\&quot; hook in \&quot;register pil terms and attach\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9908,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;tokenId = (await (0, util_1.getTokenId)());\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId,\n});\nipId = registerResult.ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2d3f75e6-2c07-4811-89ca-ba8df089bb85&quot;,&quot;parentUUID&quot;:&quot;6ded351e-0c3c-4918-844d-7594efe6ea97&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register PIL terms and attach&quot;,&quot;fullTitle&quot;:&quot;License Functions register pil terms and attach should register PIL terms and attach&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9639,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerPilTermsAndAttach({\n    ipId: ipId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 0n,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.nonCommercialSocialRemixing(),\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0b8a1147-6278-4c17-b92a-bd3ae943cc94&quot;,&quot;parentUUID&quot;:&quot;6ded351e-0c3c-4918-844d-7594efe6ea97&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register PIL terms and attach with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;License Functions register pil terms and attach should register PIL terms and attach with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7242,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerPilTermsAndAttach({\n    ipId: ipId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 0n,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 1,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 0n,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d5ef893b-53f7-4bab-9ef3-2e4726b576be&quot;,&quot;parentUUID&quot;:&quot;6ded351e-0c3c-4918-844d-7594efe6ea97&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;0b8a1147-6278-4c17-b92a-bd3ae943cc94&quot;,&quot;d5ef893b-53f7-4bab-9ef3-2e4726b576be&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:16881,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;f3a66025-c7c8-452e-80d9-83ba19598170&quot;,&quot;title&quot;:&quot;Creative Commons Attribution License Tests&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Creative Commons Attribution License Tests\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests \&quot;before all\&quot; hook in \&quot;Creative Commons Attribution License Tests\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10054,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;tokenId = await (0, util_1.getTokenId)();\n// Register an IP asset\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = registerResult.ipId;\n// Create a Creative Commons Attribution license\nconst ccLicenseResult = await client.license.registerCreativeCommonsAttributionPIL({\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicyAddress: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n});\nccLicenseTermsId = ccLicenseResult.licenseTermsId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;24b9f800-59b6-48e3-ab15-bbcacaabefd4&quot;,&quot;parentUUID&quot;:&quot;f3a66025-c7c8-452e-80d9-83ba19598170&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should verify the license terms match Creative Commons Attribution specifications&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests should verify the license terms match Creative Commons Attribution specifications&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:85,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const licenseTerms = await client.license.getLicenseTerms(ccLicenseTermsId);\n(0, chai_1.expect)(licenseTerms.terms.transferable).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.commercialUse).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesAllowed).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesAttribution).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesReciprocal).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesApproval).to.equal(false);\n(0, chai_1.expect)(licenseTerms.terms.commercialAttribution).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.commercialRevShare).to.equal(0);\n(0, chai_1.expect)(licenseTerms.terms.defaultMintingFee).to.equal(0n);\n(0, chai_1.expect)(licenseTerms.terms.royaltyPolicy).to.equal(generated_1.royaltyPolicyLapAddress[util_1.aeneid]);\n(0, chai_1.expect)(licenseTerms.terms.expiration).to.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a031f77e-30a2-4b1b-8ff4-a31391f71e79&quot;,&quot;parentUUID&quot;:&quot;f3a66025-c7c8-452e-80d9-83ba19598170&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should attach Creative Commons Attribution license to an IP&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests should attach Creative Commons Attribution license to an IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5217,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const attachResult = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: ccLicenseTermsId,\n});\n(0, chai_1.expect)(attachResult.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(attachResult.success).to.equal(true);\nconst licenseRegistryReadOnlyClient = new generated_1.LicenseRegistryReadOnlyClient(util_1.publicClient);\nconst hasLicense = await licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({\n    ipId: ipId,\n    licenseTemplate: client.ipAsset.licenseTemplateClient.address,\n    licenseTermsId: ccLicenseTermsId,\n});\n(0, chai_1.expect)(hasLicense).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1a78c5ce-bdb3-4ef3-a166-c677cd69e1b9&quot;,&quot;parentUUID&quot;:&quot;f3a66025-c7c8-452e-80d9-83ba19598170&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint CC-BY license tokens with no minting fee&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests should mint CC-BY license tokens with no minting fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5656,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Get wallet balance before minting\nconst balanceBefore = await client.getWalletBalance();\n// Predict the minting fee (should be zero for CC-BY)\nconst feePredict = await client.license.predictMintingLicenseFee({\n    licenseTermsId: ccLicenseTermsId,\n    licensorIpId: ipId,\n    amount: 1,\n});\n// CC-BY licenses should have zero minting fee\n(0, chai_1.expect)(feePredict.tokenAmount).to.equal(0n);\nconst mintResult = await client.license.mintLicenseTokens({\n    licenseTermsId: ccLicenseTermsId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 0,\n});\n(0, chai_1.expect)(mintResult.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(mintResult.licenseTokenIds).to.be.a(\&quot;array\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n// Verify no fee was charged just gas\n// This checks that any difference is very small (just gas costs)\nconst balanceDiff = balanceBefore - balanceAfter;\nconst gasUsed = mintResult.receipt.gasUsed;\nconst effectiveGasPrice = mintResult.receipt.effectiveGasPrice;\nconst totalGas = gasUsed * effectiveGasPrice;\n// Confirms the balance diff only reflects gas cost, since license fee is zero.\n(0, chai_1.expect)(balanceDiff).to.equal(totalGas); // Small amount for gas&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e08954d4-a3a4-473f-8792-4b2ee4eb529d&quot;,&quot;parentUUID&quot;:&quot;f3a66025-c7c8-452e-80d9-83ba19598170&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a031f77e-30a2-4b1b-8ff4-a31391f71e79&quot;,&quot;1a78c5ce-bdb3-4ef3-a166-c677cd69e1b9&quot;,&quot;e08954d4-a3a4-473f-8792-4b2ee4eb529d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:10958,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;dc52c609-67d8-4e86-8db8-fd912c22d5f8&quot;,&quot;title&quot;:&quot;nftClient Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;nftClient Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions \&quot;before all\&quot; hook in \&quot;nftClient Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1b849915-d4b3-420a-931b-4044bf6dec64&quot;,&quot;parentUUID&quot;:&quot;dc52c609-67d8-4e86-8db8-fd912c22d5f8&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;f542d847-7c0b-4d04-97ec-a22822df170d&quot;,&quot;title&quot;:&quot;createNFTCollection&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully create public nft collection with minimal params&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create public nft collection with minimal params&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4891,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(txData.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a51e14f8-5147-4253-8451-b34d0c58c5ba&quot;,&quot;parentUUID&quot;:&quot;f542d847-7c0b-4d04-97ec-a22822df170d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create collection with custom mint fee&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create collection with custom mint fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4871,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;paid-collection\&quot;,\n    symbol: \&quot;PAID\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 10000000,\n    mintFeeToken: generated_1.erc20Address[mockData_1.aeneid],\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);\nspgNftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ac1df1e3-10e8-4212-b046-9069c24b1c9f&quot;,&quot;parentUUID&quot;:&quot;f542d847-7c0b-4d04-97ec-a22822df170d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create private collection&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create private collection&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4895,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;private-collection\&quot;,\n    symbol: \&quot;PRIV\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false, // private minting\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: false, // starts closed\n    contractURI: \&quot;test-uri\&quot;,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3dfab28a-4aba-4090-b4cf-183205bc552c&quot;,&quot;parentUUID&quot;:&quot;f542d847-7c0b-4d04-97ec-a22822df170d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create collection with baseURI&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create collection with baseURI&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4883,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;uri-collection\&quot;,\n    symbol: \&quot;URI\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    baseURI: \&quot;ipfs://QmTest/\&quot;,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;33f8b4fd-a3e2-40b5-998f-e2a6a13e18d6&quot;,&quot;parentUUID&quot;:&quot;f542d847-7c0b-4d04-97ec-a22822df170d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create collection with custom owner&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create collection with custom owner&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5090,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;owned-collection\&quot;,\n    symbol: \&quot;OWN\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    owner: util_1.TEST_WALLET_ADDRESS,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;70685b80-86dc-4842-9608-7474245bfbbf&quot;,&quot;parentUUID&quot;:&quot;f542d847-7c0b-4d04-97ec-a22822df170d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully get encoded transaction data&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully get encoded transaction data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;encoded-collection\&quot;,\n    symbol: \&quot;ENC\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    txOptions: {\n        encodedTxDataOnly: true,\n    },\n});\n(0, chai_1.expect)(txData.encodedTxData).to.be.an(\&quot;object\&quot;);\n(0, chai_1.expect)(txData.encodedTxData?.data).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(txData.encodedTxData?.to).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;86086bca-1265-4fbb-b0e4-a5f8285d3969&quot;,&quot;parentUUID&quot;:&quot;f542d847-7c0b-4d04-97ec-a22822df170d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid mint fee token&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should fail with invalid mint fee token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.nftClient.createNFTCollection({\n    name: \&quot;invalid-fee-collection\&quot;,\n    symbol: \&quot;INV\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 1000000000000000000,\n    mintFeeToken: \&quot;0x0000000000000000000000000000000000000000\&quot;,\n})).to.be.rejectedWith(\&quot;Invalid mint fee token address\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9964b0a2-e468-4654-bd24-fd0482dc60c1&quot;,&quot;parentUUID&quot;:&quot;f542d847-7c0b-4d04-97ec-a22822df170d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a51e14f8-5147-4253-8451-b34d0c58c5ba&quot;,&quot;ac1df1e3-10e8-4212-b046-9069c24b1c9f&quot;,&quot;3dfab28a-4aba-4090-b4cf-183205bc552c&quot;,&quot;33f8b4fd-a3e2-40b5-998f-e2a6a13e18d6&quot;,&quot;70685b80-86dc-4842-9608-7474245bfbbf&quot;,&quot;86086bca-1265-4fbb-b0e4-a5f8285d3969&quot;,&quot;9964b0a2-e468-4654-bd24-fd0482dc60c1&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:24633,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;6e8efd98-5e51-43d4-a83a-88de2d524f20&quot;,&quot;title&quot;:&quot;Mint Fee&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully get mint fee token&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions Mint Fee should successfully get mint fee token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:84,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintFeeToken = await client.nftClient.getMintFeeToken(spgNftContract);\n(0, chai_1.expect)(mintFeeToken).to.equal(generated_1.erc20Address[mockData_1.aeneid]);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a813b6e8-b16c-4c15-922c-910c8320d09a&quot;,&quot;parentUUID&quot;:&quot;6e8efd98-5e51-43d4-a83a-88de2d524f20&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully get mint fee&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions Mint Fee should successfully get mint fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:87,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintFee = await client.nftClient.getMintFee(spgNftContract);\n(0, chai_1.expect)(mintFee).to.equal(10000000n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9cdecf26-816c-4004-9aa9-a12155fc1b46&quot;,&quot;parentUUID&quot;:&quot;6e8efd98-5e51-43d4-a83a-88de2d524f20&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a813b6e8-b16c-4c15-922c-910c8320d09a&quot;,&quot;9cdecf26-816c-4004-9aa9-a12155fc1b46&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:171,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;2ba90cac-e4d0-406b-aa0f-05ad7d305078&quot;,&quot;title&quot;:&quot;set and get tokenURI&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully set token URI&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions set and get tokenURI should successfully set token URI&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18806,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Setup: Approve the contract for ERC20 transfers\nconst erc20Client = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[mockData_1.aeneid]);\nconst txHash = await erc20Client.approve(spgNftContract, viem_1.maxUint256);\nawait util_1.publicClient.waitForTransactionReceipt({ hash: txHash });\n// Mint a new token with initial metadata\nconst tokenId = await (0, util_1.mintBySpg)(spgNftContract, \&quot;ipfs://QmTest/\&quot;);\n(0, chai_1.expect)(tokenId).to.be.a(\&quot;bigint\&quot;);\n// Update the token URI\nconst updatedMetadata = \&quot;ipfs://QmUpdated/metadata.json\&quot;;\nconst result = await client.nftClient.setTokenURI({\n    tokenId: tokenId,\n    tokenURI: updatedMetadata,\n    spgNftContract,\n});\n// Verify the transaction\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n// Verification that the URI was updated\nconst tokenURI = await client.nftClient.getTokenURI({\n    tokenId,\n    spgNftContract,\n});\n(0, chai_1.expect)(tokenURI).to.equal(updatedMetadata);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b06e4a2a-83a0-430a-bf13-69092e80b268&quot;,&quot;parentUUID&quot;:&quot;2ba90cac-e4d0-406b-aa0f-05ad7d305078&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;b06e4a2a-83a0-430a-bf13-69092e80b268&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:18806,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;f6f0944b-228e-4837-abc0-d51fc2c0cde1&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;fails with invalid token ID&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions Error Cases fails with invalid token ID&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5173,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const erc20Client = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[mockData_1.aeneid]);\nconst txHash = await erc20Client.approve(spgNftContract, viem_1.maxUint256);\nawait util_1.publicClient.waitForTransactionReceipt({ hash: txHash });\nconst invalidTokenId = 999999999999999n;\nconst updatedMetadata = \&quot;ipfs://QmUpdated/metadata.json\&quot;;\nawait (0, chai_1.expect)(client.nftClient.setTokenURI({\n    tokenId: invalidTokenId,\n    tokenURI: updatedMetadata,\n    spgNftContract,\n})).to.be.rejectedWith(\&quot;Failed to set token URI\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;21344595-49c7-4d4e-b0bf-25ae14fed0e0&quot;,&quot;parentUUID&quot;:&quot;f6f0944b-228e-4837-abc0-d51fc2c0cde1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;21344595-49c7-4d4e-b0bf-25ae14fed0e0&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:5173,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;184755e1-2f65-4ffd-81e7-91364b9cf900&quot;,&quot;title&quot;:&quot;Permission Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Permission Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Permission Functions \&quot;before all\&quot; hook in \&quot;Permission Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9900,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = response.ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;274a4d98-5fe7-4520-9f09-627c294a4890&quot;,&quot;parentUUID&quot;:&quot;184755e1-2f65-4ffd-81e7-91364b9cf900&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;5589297e-26c3-4354-916c-61c234094268&quot;,&quot;title&quot;:&quot;Single Permission Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should set permission successfully&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Single Permission Operations should set permission successfully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4982,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.setPermission({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n    func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;869af8d8-9f3a-406a-aa5f-bdb2f4cf6f60&quot;,&quot;parentUUID&quot;:&quot;5589297e-26c3-4354-916c-61c234094268&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should set all permissions successfully&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Single Permission Operations should set all permissions successfully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9052,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.setAllPermissions({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    permission: permission_1.AccessPermission.ALLOW,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f2699fba-bd44-4576-b228-0555ef4838ee&quot;,&quot;parentUUID&quot;:&quot;5589297e-26c3-4354-916c-61c234094268&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;869af8d8-9f3a-406a-aa5f-bdb2f4cf6f60&quot;,&quot;f2699fba-bd44-4576-b228-0555ef4838ee&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:14034,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;1ea94993-a163-4776-8f11-c72dfb720bb2&quot;,&quot;title&quot;:&quot;Permission Signatures&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should create set permission signature&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Permission Signatures should create set permission signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5136,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.createSetPermissionSignature({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n    permission: permission_1.AccessPermission.ALLOW,\n    deadline: 60000n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f9084268-3078-4bcd-b354-92a8248e38f7&quot;,&quot;parentUUID&quot;:&quot;1ea94993-a163-4776-8f11-c72dfb720bb2&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;f9084268-3078-4bcd-b354-92a8248e38f7&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:5136,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;5382deac-8676-4277-9610-bc54151fe563&quot;,&quot;title&quot;:&quot;Batch Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should set batch permissions successfully&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Batch Operations should set batch permissions successfully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5025,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.setBatchPermissions({\n    permissions: [\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.ALLOW,\n            func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n        },\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.DENY,\n            func: \&quot;function freezeMetadata(address)\&quot;,\n        },\n    ],\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;799acafe-e9d0-436e-b811-6982ab16d03c&quot;,&quot;parentUUID&quot;:&quot;5382deac-8676-4277-9610-bc54151fe563&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should create batch permission signature&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Batch Operations should create batch permission signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5252,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.createBatchPermissionSignature({\n    ipId: ipId,\n    permissions: [\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.ALLOW,\n            func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n        },\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.DENY,\n            func: \&quot;function freezeMetadata(address)\&quot;,\n        },\n    ],\n    deadline: 60000n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b2c2a31b-504c-4072-b3e2-1e59b56f0607&quot;,&quot;parentUUID&quot;:&quot;5382deac-8676-4277-9610-bc54151fe563&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;799acafe-e9d0-436e-b811-6982ab16d03c&quot;,&quot;b2c2a31b-504c-4072-b3e2-1e59b56f0607&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:10277,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;aecb835d-0b7b-4b46-8122-84839f77d7af&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should fail when setting permission for unregistered IP&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Error Cases should fail when setting permission for unregistered IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:88,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const unregisteredIpId = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nawait (0, chai_1.expect)(client.permission.setPermission({\n    ipId: unregisteredIpId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n})).to.be.rejectedWith(`IP id with ${unregisteredIpId} is not registered.`);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9709f56f-dba9-40af-ac55-0b4289450255&quot;,&quot;parentUUID&quot;:&quot;aecb835d-0b7b-4b46-8122-84839f77d7af&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid function signature&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Error Cases should fail with invalid function signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:90,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.permission.setPermission({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n    func: \&quot;invalid_function_signature\&quot;,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4f74bc02-d4a3-4806-8d41-5101cd0e03c0&quot;,&quot;parentUUID&quot;:&quot;aecb835d-0b7b-4b46-8122-84839f77d7af&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;9709f56f-dba9-40af-ac55-0b4289450255&quot;,&quot;4f74bc02-d4a3-4806-8d41-5101cd0e03c0&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:178,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;9d2c8be0-e524-4134-8b46-d226d1d2b2b6&quot;,&quot;title&quot;:&quot;Royalty Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Royalty Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions \&quot;before all\&quot; hook in \&quot;Royalty Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:31785,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nmockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\n// Setup initial state\nparentIpId = await getIpId();\nchildIpId = await getIpId();\nlicenseTermsId = await getCommercialPolicyId();\n// Setup relationships and approvals\nawait attachLicenseTerms(parentIpId, licenseTermsId);\nawait mockERC20.mint(util_1.TEST_WALLET_ADDRESS, (0, viem_1.parseEther)(\&quot;10\&quot;));\nawait mockERC20.approve(generated_1.royaltyModuleAddress[util_1.aeneid], viem_1.maxUint256);\n// Register derivative\nawait client.ipAsset.registerDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [licenseTermsId],\n    maxMintingFee: 0,\n    maxRts: 0,\n    maxRevenueShare: 0,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a7e9ac6b-41f4-47d1-9f4e-7bf8c813e503&quot;,&quot;parentUUID&quot;:&quot;9d2c8be0-e524-4134-8b46-d226d1d2b2b6&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;da1a6438-8d49-42fc-8316-115e619072fa&quot;,&quot;title&quot;:&quot;Royalty Payments&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully pay royalty on behalf&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should successfully pay royalty on behalf&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5249,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: parentIpId,\n    payerIpId: childIpId,\n    token: generated_1.erc20Address[util_1.aeneid],\n    amount: 1,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1492a8f6-cb0d-4eb6-b6ce-43fd448ee545&quot;,&quot;parentUUID&quot;:&quot;da1a6438-8d49-42fc-8316-115e619072fa&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto convert IP to WIP when paying WIP on behalf&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should auto convert IP to WIP when paying WIP on behalf&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9759,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const balanceBefore = await client.getWalletBalance();\nconst response = await client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: parentIpId,\n    payerIpId: childIpId,\n    token: common_1.WIP_TOKEN_ADDRESS,\n    amount: 100n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 100n));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e95db7bb-b633-4ead-8429-8848121d3d07&quot;,&quot;parentUUID&quot;:&quot;da1a6438-8d49-42fc-8316-115e619072fa&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail to pay royalty with unregistered receiver&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should fail to pay royalty with unregistered receiver&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:90,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const unregisteredIpId = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nawait (0, chai_1.expect)(client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: unregisteredIpId,\n    payerIpId: childIpId,\n    token: generated_1.erc20Address[util_1.aeneid],\n    amount: 10 * 10 ** 2,\n})).to.be.rejectedWith(`The receiver IP with id ${unregisteredIpId} is not registered.`);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b74a84cc-7616-478d-81a3-bb54f7266fd1&quot;,&quot;parentUUID&quot;:&quot;da1a6438-8d49-42fc-8316-115e619072fa&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow the royalty vault to transfer its native tokens to a wallet address&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should allow the royalty vault to transfer its native tokens to a wallet address&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5416,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const royaltyVaultAddress = await client.royalty.getRoyaltyVaultAddress(parentIpId);\nconst royaltyVaultToken = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, royaltyVaultAddress);\nconst transferAmount = BigInt(10 * 10 ** 6); // 10 million tokens\n// Check initial balances of the vault token\nconst initialTargetBalance = await royaltyVaultToken.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst initialParentBalance = await royaltyVaultToken.balanceOf(parentIpId);\n(0, chai_1.expect)(Number(initialParentBalance)).greaterThanOrEqual(Number(transferAmount));\nconst transferResult = await client.ipAccount.execute({\n    to: royaltyVaultAddress,\n    value: 0,\n    ipId: parentIpId,\n    data: (0, viem_1.encodeFunctionData)({\n        abi: viem_1.erc20Abi,\n        functionName: \&quot;transfer\&quot;,\n        args: [util_1.TEST_WALLET_ADDRESS, transferAmount],\n    }),\n});\n(0, chai_1.expect)(transferResult.txHash).to.be.a(\&quot;string\&quot;);\n// Check final balances to confirm the transfer worked\nconst finalTargetBalance = await royaltyVaultToken.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst finalParentBalance = await royaltyVaultToken.balanceOf(parentIpId);\n(0, chai_1.expect)(finalTargetBalance).to.equal(initialTargetBalance + transferAmount, \&quot;Target wallet balance should increase by the transfer amount\&quot;);\n(0, chai_1.expect)(Number(finalParentBalance)).equal(Number(initialParentBalance - transferAmount));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b6a1c800-651c-4544-a3ab-8a3eefcffcad&quot;,&quot;parentUUID&quot;:&quot;da1a6438-8d49-42fc-8316-115e619072fa&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1492a8f6-cb0d-4eb6-b6ce-43fd448ee545&quot;,&quot;e95db7bb-b633-4ead-8429-8848121d3d07&quot;,&quot;b74a84cc-7616-478d-81a3-bb54f7266fd1&quot;,&quot;b6a1c800-651c-4544-a3ab-8a3eefcffcad&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:20514,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;1006b5c7-8a18-431a-af77-7e532a078556&quot;,&quot;title&quot;:&quot;Revenue Queries&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should return claimable revenue amount&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Revenue Queries should return claimable revenue amount&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:265,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.royalty.claimableRevenue({\n    ipId: parentIpId,\n    claimer: util_1.TEST_WALLET_ADDRESS,\n    token: generated_1.erc20Address[util_1.aeneid],\n});\n(0, chai_1.expect)(response).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d5aa05c9-b8b9-4508-88bf-6f978d2fca67&quot;,&quot;parentUUID&quot;:&quot;1006b5c7-8a18-431a-af77-7e532a078556&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail to get royalty vault address for unregistered IP&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Revenue Queries should fail to get royalty vault address for unregistered IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:84,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const unregisteredIpId = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nawait (0, chai_1.expect)(client.royalty.getRoyaltyVaultAddress(unregisteredIpId)).to.be.rejectedWith(`The royalty vault IP with id ${unregisteredIpId} is not registered.`);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6cbce1f1-c0eb-4bd9-93ec-ce4b3cd0db0b&quot;,&quot;parentUUID&quot;:&quot;1006b5c7-8a18-431a-af77-7e532a078556&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;d5aa05c9-b8b9-4508-88bf-6f978d2fca67&quot;,&quot;6cbce1f1-c0eb-4bd9-93ec-ce4b3cd0db0b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:349,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;e3da8b80-d74c-4464-90ac-be9c9962c331&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should return zero for claimable revenue with invalid token&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Error Cases should return zero for claimable revenue with invalid token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:302,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.royalty.claimableRevenue({\n    ipId: parentIpId,\n    claimer: util_1.TEST_WALLET_ADDRESS,\n    token: \&quot;0x0000000000000000000000000000000000000000\&quot;,\n});\n(0, chai_1.expect)(response).to.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9d2a4c3e-a72c-456b-a756-076352d76fd1&quot;,&quot;parentUUID&quot;:&quot;e3da8b80-d74c-4464-90ac-be9c9962c331&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;9d2a4c3e-a72c-456b-a756-076352d76fd1&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:302,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;54abadd7-818a-4f76-ab68-2f8e7fa0839e&quot;,&quot;title&quot;:&quot;ClaimAllRevenue With WIP&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;ClaimAllRevenue With WIP\&quot;&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions ClaimAllRevenue With WIP \&quot;before all\&quot; hook in \&quot;ClaimAllRevenue With WIP\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:33862,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// set up\n// minting Fee: 100, 10% LAP rev share, A expect to get 120 WIP\n// A -&gt; B -&gt; C -&gt; D\nconst txData = await client.nftClient.createNFTCollection({\n    name: \&quot;free-collection\&quot;,\n    symbol: \&quot;FREE\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: viem_1.zeroAddress,\n});\nspgNftContract = txData.spgNftContract;\nconst retA = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 100n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 100n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nipA = retA.ipId;\nlicenseId = retA.licenseTermsIds[0];\nconst retB = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipA],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\nipB = retB.ipId;\nconst retC = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipB],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\nipC = retC.ipId;\nawait client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipC],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2d5dc84c-f58b-4e9c-8647-472aa89f3ca2&quot;,&quot;parentUUID&quot;:&quot;54abadd7-818a-4f76-ab68-2f8e7fa0839e&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should claim all revenue&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions ClaimAllRevenue With WIP should claim all revenue&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14850,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const ret = await client.royalty.claimAllRevenue({\n    ancestorIpId: ipA,\n    claimer: ipA,\n    childIpIds: [ipB, ipC],\n    royaltyPolicies: [generated_1.royaltyPolicyLapAddress[util_1.aeneid], generated_1.royaltyPolicyLapAddress[util_1.aeneid]],\n    currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n});\n(0, chai_1.expect)(ret.txHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(ret.claimedTokens[0].amount).to.equal(120n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;095e1d62-0060-4bda-8206-d20b4420c3d2&quot;,&quot;parentUUID&quot;:&quot;54abadd7-818a-4f76-ab68-2f8e7fa0839e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;095e1d62-0060-4bda-8206-d20b4420c3d2&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:14850,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;bc8985b1-79d0-4313-abee-4245452e00e6&quot;,&quot;title&quot;:&quot;BatchClaimAllRevenue With WIP&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;BatchClaimAllRevenue With WIP\&quot;&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions BatchClaimAllRevenue With WIP \&quot;before all\&quot; hook in \&quot;BatchClaimAllRevenue With WIP\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:50710,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nanotherAddress = derivedClient.address;\nawait client.wipClient.deposit({\n    amount: (0, viem_1.parseEther)(\&quot;5\&quot;),\n});\n/**\n * Asset Hierarchy Setup for Revenue Collection Tests\n *\n * Overview:\n * This test setup creates two distinct IP asset hierarchies (IpA and IpB) to demonstrate\n * different revenue collection scenarios using LAP (Licensing Agreement Policy) and LRP\n * (Licensing Revenue Policy) respectively.\n *\n * IpA Hierarchy (LAP - Licensing Agreement Policy):                           IpB Hierarchy (LRP - Licensing Revenue Policy):\n *           \n *  IpA (Parent) - Total Expected Revenue: 130 WIP                         IpB (Parent) - Total Expected Revenue: 330 WIP              \n *           \n *  Revenue Sources:                                                       Revenue Sources:                                            \n *   Minting Fee: 100 WIP                                                Minting Fee: 150 WIP                                    \n *   Revenue Share (ipA2-&gt;ipA1): 10 WIP (10% LAP)                        LRP Revenue Share: 10%                                  \n *   Revenue Share (ipA3-&gt;ipA2): 10 WIP (10% LAP)                        Total Revenue: 330 WIP                                  \n *   Direct Payment (ipA3): 10 WIP (10% LAP)                                From ipB1: 150 WIP + 10% revenue share               \n *                                                                             From ipB2: 150 WIP + 10% revenue share               \n *                                                                                                                                     \n * | Ownership Distribution:                                               |                                                             \n *   Wallet Address: 50%  65 WIP                                        Revenue Flow:                                               \n *   Another Address: 50% 65 WIP                                        ipB3                                                        \n *                                                                          ipB1                                                  \n *  Revenue Flow:                                                           ipB2 &gt; ipB (collects 330 WIP)                       \n *  ipA3                                                                                                                               \n *   &gt; ipA2 (20% LAP) &gt; ipA1 (10% LAP) &gt; ipA                                                                                    \n *        &gt; Direct Payment: 100 WIP                                                                                                 \n *           \n */\nconst txData = await client.nftClient.createNFTCollection({\n    name: \&quot;free-collection\&quot;,\n    symbol: \&quot;FREE\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: viem_1.zeroAddress,\n});\nspgNftContract = txData.spgNftContract;\n// 1. Register ipA\nconst ret1A = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 100n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 100n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 50,\n        },\n        {\n            recipient: anotherAddress,\n            percentage: 50,\n        },\n    ],\n});\nipA = ret1A.ipId;\nlicenseId = ret1A.licenseTermsIds[0];\n// 2. Register ipB\nconst ret1B = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n                defaultMintingFee: 150n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 150n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nipB = ret1B.ipId;\nlicenseId1 = ret1B.licenseTermsIds[0];\n// 3. Register ipA1 from ipA and ipB1 from ipB\nconst { results: ret2 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB],\n                licenseTermsIds: [licenseId1],\n            },\n        },\n    ],\n});\nipA1 = ret2[0].ipId;\nipB1 = ret2[1].ipId;\n// 4. Register ipA2 from ipA1 and ipB2 from ipB\nconst { results: ret3 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA1],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB],\n                licenseTermsIds: [licenseId1],\n            },\n        },\n    ],\n});\nipA2 = ret3[0].ipId;\nipB2 = ret3[1].ipId;\n// 5. Register ipA3 from ipA2 and ipB3 from ipB1 and ipB2\nconst { results: ret4 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA2],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB1, ipB2],\n                licenseTermsIds: [licenseId1, licenseId1],\n            },\n        },\n    ],\n});\nipA3 = ret4[0].ipId;\n// 6. Pay royalty on behalf of ipA2 to ipA3\nawait client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: ipA2,\n    payerIpId: ipA3,\n    token: common_1.WIP_TOKEN_ADDRESS,\n    amount: 100n,\n});\nconst balance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nawait client.wipClient.withdraw({\n    amount: balance,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;21cf2985-b730-4fa1-b439-fc8e4541b2b3&quot;,&quot;parentUUID&quot;:&quot;bc8985b1-79d0-4313-abee-4245452e00e6&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should batch claim all revenue&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions BatchClaimAllRevenue With WIP should batch claim all revenue&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15272,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const anotherAddressWipBalanceBefore = await client.wipClient.balanceOf(anotherAddress);\nconst result = await client.royalty.batchClaimAllRevenue({\n    ancestorIps: [\n        {\n            ipId: ipA,\n            claimer: util_1.TEST_WALLET_ADDRESS,\n            childIpIds: [ipA1, ipA2],\n            royaltyPolicies: [generated_1.royaltyPolicyLapAddress[util_1.aeneid], generated_1.royaltyPolicyLapAddress[util_1.aeneid]],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n        },\n        {\n            ipId: ipA,\n            claimer: anotherAddress,\n            childIpIds: [],\n            royaltyPolicies: [],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS],\n        },\n        {\n            ipId: ipB,\n            claimer: ipB,\n            childIpIds: [ipB1, ipB2],\n            royaltyPolicies: [generated_1.royaltyPolicyLrpAddress[util_1.aeneid], generated_1.royaltyPolicyLrpAddress[util_1.aeneid]],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n        },\n    ],\n});\nconst anotherAddressWipBalanceAfter = await client.wipClient.balanceOf(anotherAddress);\nconst walletWipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(result.txHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.claimedTokens[0].amount).to.equal(65n);\n(0, chai_1.expect)(result.claimedTokens[1].amount).to.equal(65n);\n(0, chai_1.expect)(result.claimedTokens[2].amount).to.equal(330n);\n(0, chai_1.expect)(walletWipBalanceAfter).to.equal(0n);\n(0, chai_1.expect)(anotherAddressWipBalanceAfter).to.equal(anotherAddressWipBalanceBefore + 65n);\n// Note: The final wallet balance cannot be precisely calculated because:\n// The test involves multiple transactions (claimAllRevenue, token transfers, etc.)\n// batchClaimAllRevenue only returns receipts for claimAllRevenue calls\n// Additional gas costs and token transfers occur outside the returned receipts&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8f602502-a706-4fdf-8bef-a17cfb2dd1c7&quot;,&quot;parentUUID&quot;:&quot;bc8985b1-79d0-4313-abee-4245452e00e6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;8f602502-a706-4fdf-8bef-a17cfb2dd1c7&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:15272,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;0e642a28-67bc-4b4a-b6c9-42c3cb6c4483&quot;,&quot;title&quot;:&quot;WIP Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;WIP Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;WIP Functions \&quot;before all\&quot; hook in \&quot;WIP Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;72de98a8-0eb1-402e-b96e-23aa4b41c28c&quot;,&quot;parentUUID&quot;:&quot;0e642a28-67bc-4b4a-b6c9-42c3cb6c4483&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;157387c8-4b35-4cd1-89ad-9a2160d4ade0&quot;,&quot;title&quot;:&quot;deposit&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should deposit 0.01 WIP&quot;,&quot;fullTitle&quot;:&quot;WIP Functions deposit should deposit 0.01 WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5233,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const ipAmt = (0, viem_1.parseEther)(\&quot;0.01\&quot;);\nconst balanceBefore = await client.getWalletBalance();\nconst wipBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst rsp = await client.wipClient.deposit({\n    amount: ipAmt,\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.equal(wipBefore + ipAmt);\nconst gasCost = rsp.receipt.gasUsed * rsp.receipt.effectiveGasPrice;\n(0, chai_1.expect)(balanceAfter).to.equal(balanceBefore - ipAmt - gasCost);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;845d221c-f81f-4227-8703-f4ab1a68c098&quot;,&quot;parentUUID&quot;:&quot;157387c8-4b35-4cd1-89ad-9a2160d4ade0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;845d221c-f81f-4227-8703-f4ab1a68c098&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:5233,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;a0d29af4-4390-4949-8dfb-098f6567e5f5&quot;,&quot;title&quot;:&quot;transfer&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should transfer WIP&quot;,&quot;fullTitle&quot;:&quot;WIP Functions transfer should transfer WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4872,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const rsp = await client.wipClient.transfer({\n    to: util_1.TEST_WALLET_ADDRESS,\n    amount: (0, viem_1.parseEther)(\&quot;0.01\&quot;),\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n//Due to approve cannot approve msy.sender, so skip transferFrom test&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;864fa6bc-587f-4c63-bea1-2f718a0d337f&quot;,&quot;parentUUID&quot;:&quot;a0d29af4-4390-4949-8dfb-098f6567e5f5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;864fa6bc-587f-4c63-bea1-2f718a0d337f&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4872,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;a0e8cfe9-550c-49a6-8be6-ea3f070fa33d&quot;,&quot;title&quot;:&quot;withdraw&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should withdrawal WIP&quot;,&quot;fullTitle&quot;:&quot;WIP Functions withdraw should withdrawal WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5242,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const balanceBefore = await client.getWalletBalance();\nconst wipBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst rsp = await client.wipClient.withdraw({\n    amount: wipBefore,\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.equal(0n);\nconst balanceAfter = await client.getWalletBalance();\nconst gasCost = rsp.receipt.gasUsed * rsp.receipt.effectiveGasPrice;\n(0, chai_1.expect)(balanceAfter).to.equal(balanceBefore + wipBefore - gasCost);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f2060fe6-5e4d-4dea-8194-337ef2ebfd45&quot;,&quot;parentUUID&quot;:&quot;a0e8cfe9-550c-49a6-8be6-ea3f070fa33d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;f2060fe6-5e4d-4dea-8194-337ef2ebfd45&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:5242,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:300000}],&quot;meta&quot;:{&quot;mocha&quot;:{&quot;version&quot;:&quot;10.8.2&quot;},&quot;mochawesome&quot;:{&quot;options&quot;:{&quot;quiet&quot;:false,&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;saveHtml&quot;:true,&quot;saveJson&quot;:true,&quot;consoleReporter&quot;:&quot;spec&quot;,&quot;useInlineDiffs&quot;:false,&quot;code&quot;:true},&quot;version&quot;:&quot;7.1.4&quot;},&quot;marge&quot;:{&quot;version&quot;:&quot;6.3.2&quot;}}}" data-config="{&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;reportDir&quot;:&quot;mochawesome-report&quot;,&quot;reportTitle&quot;:&quot;core-sdk&quot;,&quot;reportPageTitle&quot;:&quot;Mochawesome Report&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;cdn&quot;:false,&quot;charts&quot;:false,&quot;enableCharts&quot;:false,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;showPassed&quot;:true,&quot;showFailed&quot;:true,&quot;showPending&quot;:true,&quot;showSkipped&quot;:false,&quot;showHooks&quot;:&quot;failed&quot;,&quot;saveJson&quot;:true,&quot;saveHtml&quot;:true,&quot;dev&quot;:false,&quot;assetsDir&quot;:&quot;mochawesome-report/assets&quot;,&quot;jsonFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/mochawesome-report/mochawesome.json&quot;,&quot;htmlFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/mochawesome-report/mochawesome.html&quot;}"><div id="report"></div><script src="assets/app.js"></script></body></html>