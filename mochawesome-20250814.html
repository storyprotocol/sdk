<!doctype html>
<html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Mochawesome Report</title><link rel="stylesheet" href="assets/app.css"/></head><body data-raw="{&quot;stats&quot;:{&quot;suites&quot;:48,&quot;tests&quot;:138,&quot;passes&quot;:138,&quot;pending&quot;:0,&quot;failures&quot;:0,&quot;start&quot;:&quot;2025-08-14T06:42:18.218Z&quot;,&quot;end&quot;:&quot;2025-08-14T07:12:15.028Z&quot;,&quot;duration&quot;:1796810,&quot;testsRegistered&quot;:138,&quot;passPercent&quot;:100,&quot;pendingPercent&quot;:0,&quot;other&quot;:0,&quot;hasOther&quot;:false,&quot;skipped&quot;:0,&quot;hasSkipped&quot;:false},&quot;results&quot;:[{&quot;uuid&quot;:&quot;b9683cd5-712d-4cda-a999-748e7d2a53ec&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;ee3ed576-8cc2-44fa-9985-1e0a1178b7a1&quot;,&quot;title&quot;:&quot;Dispute Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/dispute.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Dispute Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions \&quot;before all\&quot; hook in \&quot;Dispute Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9053,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;clientA = (0, util_1.getStoryClient)();\nconst derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nclientB = derivedClient.clientB;\nminimumBond = await (0, oov3_1.getMinimumBond)(util_1.publicClient, new generated_1.ArbitrationPolicyUmaClient(util_1.publicClient, util_1.walletClient), src_1.WIP_TOKEN_ADDRESS);\nconst txData = await clientA.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nconst nftContract = txData.spgNftContract;\nipIdB = (await clientB.ipAsset.mintAndRegisterIp({\n    spgNftContract: nftContract,\n})).ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ef0c3018-6c5e-4bec-ac51-1a9c019018c1&quot;,&quot;parentUUID&quot;:&quot;ee3ed576-8cc2-44fa-9985-1e0a1178b7a1&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;it should not cancel a dispute (yet)&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions it should not cancel a dispute (yet)&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9066,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const raiseResponse = await clientA.dispute.raiseDispute({\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 2592000,\n    bond: minimumBond,\n});\nawait (0, chai_1.expect)(clientA.dispute.cancelDispute({\n    disputeId: raiseResponse.disputeId,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3feae60e-08e1-4e60-b251-ab87da2f1e7b&quot;,&quot;parentUUID&quot;:&quot;ee3ed576-8cc2-44fa-9985-1e0a1178b7a1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;efb31f67-44ac-4a87-ac94-72d4161c75e9&quot;,&quot;title&quot;:&quot;raiseDispute and counter dispute&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/dispute.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should raise a dispute&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should raise a dispute&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9005,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const raiseDisputeRequest = {\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 2592000,\n    bond: minimumBond,\n};\nconst response = await clientA.dispute.raiseDispute(raiseDisputeRequest);\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.disputeId).to.be.a(\&quot;bigint\&quot;);\ndisputeId = response.disputeId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cf807ca5-16d6-4562-8fa7-ecf3a1d9d4b6&quot;,&quot;parentUUID&quot;:&quot;efb31f67-44ac-4a87-ac94-72d4161c75e9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should validate all enum values defined in DisputeTargetTag&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should validate all enum values defined in DisputeTargetTag&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:172,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const allTags = Object.values(src_1.DisputeTargetTag);\nfor (const tag of allTags) {\n    const tagHex = (0, viem_1.toHex)(tag, { size: 32 });\n    const { allowed } = await clientA.dispute.disputeModuleClient.isWhitelistedDisputeTag({\n        tag: tagHex,\n    });\n    if (tag === src_1.DisputeTargetTag.IN_DISPUTE) {\n        (0, chai_1.expect)(allowed).equal(false);\n    }\n    else {\n        (0, chai_1.expect)(allowed).equal(true);\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fe46cb4d-1a0c-470f-8092-9b83f2c08454&quot;,&quot;parentUUID&quot;:&quot;efb31f67-44ac-4a87-ac94-72d4161c75e9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should raise disputes with different DisputeTargetTag enum values&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should raise disputes with different DisputeTargetTag enum values&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:44157,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const allTags = Object.values(src_1.DisputeTargetTag);\nfor (const tag of allTags) {\n    const raiseDisputeRequest = {\n        targetIpId: ipIdB,\n        cid: await generateCID(),\n        targetTag: tag,\n        liveness: 2592000,\n        bond: minimumBond,\n    };\n    if (tag === src_1.DisputeTargetTag.IN_DISPUTE) {\n        await (0, chai_1.expect)(clientA.dispute.raiseDispute(raiseDisputeRequest)).to.be.rejectedWith(\&quot;The target tag IN_DISPUTE is not whitelisted\&quot;);\n    }\n    else {\n        const response = await clientA.dispute.raiseDispute(raiseDisputeRequest);\n        (0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n        (0, chai_1.expect)(response.disputeId).to.be.a(\&quot;bigint\&quot;);\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f5c39f70-e4be-4025-99af-c6b8710433dc&quot;,&quot;parentUUID&quot;:&quot;efb31f67-44ac-4a87-ac94-72d4161c75e9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should reject a dispute with an invalid tag not defined in the enum&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should reject a dispute with an invalid tag not defined in the enum&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:170,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(clientA.dispute.raiseDispute({\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: \&quot;INVALID_TAG\&quot;,\n    liveness: 2592000,\n    bond: minimumBond,\n})).to.be.rejectedWith(\&quot;The target tag INVALID_TAG is not whitelisted\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;07e937b9-528e-4fd7-aea2-2a986796bf57&quot;,&quot;parentUUID&quot;:&quot;efb31f67-44ac-4a87-ac94-72d4161c75e9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should be able to counter existing dispute once&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should be able to counter existing dispute once&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13524,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const assertionId = await clientB.dispute.disputeIdToAssertionId(disputeId);\nconst counterEvidenceCID = await generateCID();\nconst ret = await clientB.dispute.disputeAssertion({\n    ipId: ipIdB,\n    assertionId,\n    counterEvidenceCID,\n});\n(0, chai_1.expect)(ret.txHash).to.be.a(\&quot;string\&quot;);\n// should throw error if attempting to dispute assertion again\nawait (0, chai_1.expect)(clientB.dispute.disputeAssertion({\n    ipId: ipIdB,\n    assertionId,\n    counterEvidenceCID,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;64106253-33ec-4ee2-ad32-8951387902c4&quot;,&quot;parentUUID&quot;:&quot;efb31f67-44ac-4a87-ac94-72d4161c75e9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;cf807ca5-16d6-4562-8fa7-ecf3a1d9d4b6&quot;,&quot;fe46cb4d-1a0c-470f-8092-9b83f2c08454&quot;,&quot;f5c39f70-e4be-4025-99af-c6b8710433dc&quot;,&quot;07e937b9-528e-4fd7-aea2-2a986796bf57&quot;,&quot;64106253-33ec-4ee2-ad32-8951387902c4&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:67028,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;7450ac1b-8331-433c-aa09-636e8cb2b759&quot;,&quot;title&quot;:&quot;Dispute resolution&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/dispute.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before each\&quot; hook in \&quot;Dispute resolution\&quot;&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution \&quot;before each\&quot; hook in \&quot;Dispute resolution\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:34235,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Setup NFT collection\nconst txData = await clientA.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\n// Get parent IP ID and license terms ID\nconst ipIdAndLicenseResponse = await clientA.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContract,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: src_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: generated_1.evenSplitGroupPoolAddress[util_1.aeneid],\n            },\n        },\n    ],\n});\nparentIpId = ipIdAndLicenseResponse.ipId;\nlicenseTermsId = ipIdAndLicenseResponse.licenseTermsIds[0];\n//Create a derivative ip\nconst derivativeIpIdResponse1 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\nchildIpId = derivativeIpIdResponse1.ipId;\n// Create a second derivative ip\nconst derivativeIpIdResponse2 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\nchildIpId2 = derivativeIpIdResponse2.ipId;\n// Raise a dispute\nconst response = await clientA.dispute.raiseDispute({\n    targetIpId: parentIpId,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 1,\n    bond: minimumBond,\n});\ndisputeId = response.disputeId;\n// This timeout guarantees that the assertion is expired\n// its intended to be longer than the current block time\n// so it won&#x27;t be included in the same block\nawait new Promise((resolve) =&gt; setTimeout(resolve, 3000));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7037f7d4-1426-45f8-a41f-fed7cc249ef1&quot;,&quot;parentUUID&quot;:&quot;7450ac1b-8331-433c-aa09-636e8cb2b759&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should tag infringing ip&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag infringing ip&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8743,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Tag derivative IP as infringing\nconst results = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: childIpId2,\n            disputeId: disputeId,\n        },\n    ],\n});\n(0, chai_1.expect)(results[0].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;247372e2-0c8b-4d87-853c-90ae9365cfcc&quot;,&quot;parentUUID&quot;:&quot;7450ac1b-8331-433c-aa09-636e8cb2b759&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should tag a single IP as infringing without using multicall&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag a single IP as infringing without using multicall&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8768,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;/**\n * Test Flow:\n * 1. Set judgment on an existing dispute to mark it as valid (did in `before each` block)\n * 2. Verify the dispute state changed correctly after judgment\n * 3. Try to tag a derivative IP using the judged dispute\n */\n// Step 1: Set judgment on an existing dispute to mark it as valid\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Step 2: Verify dispute state\n// The disputes() function returns multiple values about the dispute:\n// - targetTag: the tag we wanted to apply when raising the dispute\n// - currentTag: the current state of the dispute after judgment\n// After a successful judgment, currentTag should equal targetTag\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag); // Verify judgment was recorded correctly\n// Step 3: Attempt to tag a derivative IP\n// This will fail if:\n// - The dispute is not in a valid state (still IN_DISPUTE or cleared)\n// - The IP we&#x27;re trying to tag is not actually a derivative of the disputed IP\n// - The dispute has already been used to tag this IP\nconst response = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId, // The derivative IP to tag\n            disputeId: disputeId, // Using the judged dispute as basis for tagging\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: false, // Force single transaction instead of batch\n    },\n});\n// Verify we got the expected response\n(0, chai_1.expect)(response).to.have.lengthOf(1);\n(0, chai_1.expect)(response[0].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a9592a33-9aeb-468c-aa0d-854b135db1c4&quot;,&quot;parentUUID&quot;:&quot;7450ac1b-8331-433c-aa09-636e8cb2b759&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should tag multiple IPs as infringing using multicall&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag multiple IPs as infringing using multicall&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:25463,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const disputeResponse = await clientA.dispute.raiseDispute({\n    targetIpId: parentIpId,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 1,\n    bond: minimumBond,\n});\nconst testDisputeId = disputeResponse.disputeId;\nconst derivativeResponse2 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nconst newChildIpId = derivativeResponse2.ipId;\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, testDisputeId);\n// This timeout guarantees that the assertion is expired\n// its intended to be longer than the current block time\n// so it won&#x27;t be included in the same block\nawait new Promise((resolve) =&gt; setTimeout(resolve, 3000));\nconst { currentTag, targetTag } = await getDisputeState(testDisputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst response = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: testDisputeId,\n        },\n        {\n            ipId: newChildIpId,\n            disputeId: testDisputeId,\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: true,\n    },\n});\n(0, chai_1.expect)(response).to.have.lengthOf(1);\n(0, chai_1.expect)(response[0].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cebab721-eb3d-4cab-a57f-bcb3c5af4ebd&quot;,&quot;parentUUID&quot;:&quot;7450ac1b-8331-433c-aa09-636e8cb2b759&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should tag multiple IPs without multicall when specified&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag multiple IPs without multicall when specified&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18421,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create two new derivative IPs sequentially\nconst derivativeResponse3 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nconst derivativeResponse4 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst responses = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: derivativeResponse3.ipId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: derivativeResponse4.ipId,\n            disputeId: disputeId,\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: false,\n    },\n});\n(0, chai_1.expect)(responses).to.have.lengthOf(2);\n(0, chai_1.expect)(responses[0].txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(responses[1].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7edf29c2-8436-43b9-baae-f90a3e4f5873&quot;,&quot;parentUUID&quot;:&quot;7450ac1b-8331-433c-aa09-636e8cb2b759&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to tag with invalid dispute ID&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should fail when trying to tag with invalid dispute ID&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:41,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: 999999n,\n        },\n    ],\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0655ad05-4e5e-466c-b961-0c27126368b1&quot;,&quot;parentUUID&quot;:&quot;7450ac1b-8331-433c-aa09-636e8cb2b759&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should resolve a dispute successfully when initiated by dispute initiator&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should resolve a dispute successfully when initiated by dispute initiator&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8730,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst response = await clientA.dispute.resolveDispute({\n    disputeId: disputeId,\n    data: \&quot;0x\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;32e22fc9-46c3-48c4-9144-4dc43f319d57&quot;,&quot;parentUUID&quot;:&quot;7450ac1b-8331-433c-aa09-636e8cb2b759&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when non-initiator tries to resolve the dispute&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should fail when non-initiator tries to resolve the dispute&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:52,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(clientB.dispute.resolveDispute({\n    disputeId: disputeId,\n    data: \&quot;0x\&quot;,\n})).to.be.rejectedWith(\&quot;NotDisputeInitiator\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;05d2c9c2-c55c-437b-adc8-8381cf37c1b4&quot;,&quot;parentUUID&quot;:&quot;7450ac1b-8331-433c-aa09-636e8cb2b759&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should propagate IMPROPER_REGISTRATION tag to derivative IPs&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should propagate IMPROPER_REGISTRATION tag to derivative IPs&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8759,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Verify the dispute state changed correctly\nconst { currentTag: parentCurrentTag, targetTag: parentTargetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(parentCurrentTag).to.equal(parentTargetTag);\n// Propagate the tag to both derivative IPs\nconst results = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: childIpId2,\n            disputeId: disputeId,\n        },\n    ],\n});\nconst logData = results[0].receipt?.logs[0].data;\nconst firstWord = logData.slice(0, 66);\nconst childDisputeId = BigInt(firstWord);\n// Verify successful tagging\n(0, chai_1.expect)(results[0].txHash).to.be.a(\&quot;string\&quot;);\nconst { currentTag: childCurrentTag } = await getDisputeState(childDisputeId);\n// Convert the IMPROPER_USAGE tag to hex for comparison\nconst improperUsageTagHex = (0, viem_1.toHex)(src_1.DisputeTargetTag.IMPROPER_REGISTRATION, { size: 32 });\n// Verify both child IPs have the IMPROPER_USAGE tag by\n// fetching and comparing their dispute tags\n(0, chai_1.expect)(parentCurrentTag).to.equal(parentTargetTag);\n(0, chai_1.expect)(childCurrentTag).to.equal(improperUsageTagHex);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ac5e47f5-c01d-4715-9f35-a7b7c1e33be3&quot;,&quot;parentUUID&quot;:&quot;7450ac1b-8331-433c-aa09-636e8cb2b759&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;247372e2-0c8b-4d87-853c-90ae9365cfcc&quot;,&quot;a9592a33-9aeb-468c-aa0d-854b135db1c4&quot;,&quot;cebab721-eb3d-4cab-a57f-bcb3c5af4ebd&quot;,&quot;7edf29c2-8436-43b9-baae-f90a3e4f5873&quot;,&quot;0655ad05-4e5e-466c-b961-0c27126368b1&quot;,&quot;32e22fc9-46c3-48c4-9144-4dc43f319d57&quot;,&quot;05d2c9c2-c55c-437b-adc8-8381cf37c1b4&quot;,&quot;ac5e47f5-c01d-4715-9f35-a7b7c1e33be3&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:78977,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;3feae60e-08e1-4e60-b251-ab87da2f1e7b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:9066,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;8b2449bd-8221-41ca-8d5c-71129d5dd6ac&quot;,&quot;title&quot;:&quot;Group Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Group Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Group Functions \&quot;before all\&quot; hook in \&quot;Group Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4321,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\n// Create NFT Collection\nspgNftContract = (await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n})).spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1db0d5f8-3c18-4131-bf56-2fc109842164&quot;,&quot;parentUUID&quot;:&quot;8b2449bd-8221-41ca-8d5c-71129d5dd6ac&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;c22a1440-4f81-44e5-bc3a-9badb290310b&quot;,&quot;title&quot;:&quot;Group Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Group Operations\&quot;&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations \&quot;before all\&quot; hook in \&quot;Group Operations\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9040,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create initial IP with license terms\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    allowDuplicates: false,\n    licenseTermsData,\n});\nlicenseTermsId = result.licenseTermsIds[0];\nipId = result.ipId;\n// Set licensing config\nawait client.license.setLicensingConfig({\n    ipId,\n    licenseTermsId,\n    licenseTemplate: generated_1.piLicenseTemplateAddress[util_1.aeneid],\n    licensingConfig: {\n        isSet: true,\n        mintingFee: 0n,\n        licensingHook: viem_1.zeroAddress,\n        hookData: viem_1.zeroAddress,\n        commercialRevShare: 0,\n        disabled: false,\n        expectMinimumGroupRewardShare: 0,\n        expectGroupRewardPool: groupPoolAddress,\n    },\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;53fe6c28-bc94-41a0-92a1-8b835a3f3840&quot;,&quot;parentUUID&quot;:&quot;c22a1440-4f81-44e5-bc3a-9badb290310b&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully register group and attach license&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register group and attach license&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4336,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.registerGroupAndAttachLicense({\n    groupPool: groupPoolAddress,\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n});\ngroupId = result.groupId;\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.groupId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d185d6c4-c2d0-4648-bd77-7f8570624e88&quot;,&quot;parentUUID&quot;:&quot;c22a1440-4f81-44e5-bc3a-9badb290310b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully mint, register IP, attach license and add to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully mint, register IP, attach license and add to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8461,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.mintAndRegisterIpAndAttachLicenseAndAddToGroup({\n    groupId,\n    spgNftContract,\n    licenseData: [\n        {\n            licenseTermsId,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: groupPoolAddress,\n            },\n        },\n    ],\n    maxAllowedRewardShare: 5,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;70529bf7-8bee-483f-93f1-8c529204f3a7&quot;,&quot;parentUUID&quot;:&quot;c22a1440-4f81-44e5-bc3a-9badb290310b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register a basic group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register a basic group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4331,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.registerGroup({\n    groupPool: groupPoolAddress,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.groupId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8e11e334-4a35-48ce-8372-852acd1d86bf&quot;,&quot;parentUUID&quot;:&quot;c22a1440-4f81-44e5-bc3a-9badb290310b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register existing IP with license and add to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register existing IP with license and add to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8847,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(spgNftContract, \&quot;test-metadata\&quot;);\nconst result = await client.groupClient.registerIpAndAttachLicenseAndAddToGroup({\n    groupId,\n    nftContract: spgNftContract,\n    tokenId,\n    maxAllowedRewardShare: 5,\n    licenseData: [\n        {\n            licenseTermsId,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: groupPoolAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b87d4865-8ba5-4459-888f-51fe1b51d01e&quot;,&quot;parentUUID&quot;:&quot;c22a1440-4f81-44e5-bc3a-9badb290310b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register group with license and add multiple IPs&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register group with license and add multiple IPs&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4397,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.registerGroupAndAttachLicenseAndAddIps({\n    groupPool: groupPoolAddress,\n    maxAllowedRewardShare: 5,\n    ipIds: [ipId],\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.groupId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b89c99d7-a72e-4bb4-a90d-efd5c25c4a77&quot;,&quot;parentUUID&quot;:&quot;c22a1440-4f81-44e5-bc3a-9badb290310b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to add unregistered IP to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should fail when trying to add unregistered IP to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:35,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.groupClient.registerGroupAndAttachLicenseAndAddIps({\n    groupPool: groupPoolAddress,\n    maxAllowedRewardShare: 5,\n    ipIds: [viem_1.zeroAddress], // Invalid IP address\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n})).to.be.rejectedWith(\&quot;Failed to register group and attach license and add ips\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1fca043d-0f68-4155-aff4-7a55d91301d6&quot;,&quot;parentUUID&quot;:&quot;c22a1440-4f81-44e5-bc3a-9badb290310b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;3d86f187-c527-40b9-a885-12b535da01d2&quot;,&quot;title&quot;:&quot;Add IPs to Group and Remove IPs from Group&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully add multiple IPs to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should successfully add multiple IPs to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13423,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const registerResult = await client.ipAsset.batchMintAndRegisterIpAssetWithPilTerms({\n    args: [\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n    ],\n});\nipIds = registerResult.results?.map((result) =&gt; result.ipId) ?? [];\nconst result = await client.groupClient.addIpsToGroup({\n    groupIpId: groupId,\n    ipIds: ipIds,\n    maxAllowedRewardSharePercentage: 5,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5d349801-948e-4784-b242-02aea34b3e54&quot;,&quot;parentUUID&quot;:&quot;3d86f187-c527-40b9-a885-12b535da01d2&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully remove IPs from group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should successfully remove IPs from group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4348,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.removeIpsFromGroup({\n    groupIpId: groupId,\n    ipIds: ipIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7d2a09a3-2953-4c91-a686-d48e565d3110&quot;,&quot;parentUUID&quot;:&quot;3d86f187-c527-40b9-a885-12b535da01d2&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to remove IPs from a non-existent group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should fail when trying to remove IPs from a non-existent group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4663,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const registerResult = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData,\n});\nconst testIpId = registerResult.ipId;\nconst nonExistentGroupId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.removeIpsFromGroup({\n    groupIpId: nonExistentGroupId,\n    ipIds: [testIpId],\n})).to.be.rejectedWith(\&quot;Failed to remove IPs from group\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6a5ed62b-df4f-4972-9671-143c67fb8236&quot;,&quot;parentUUID&quot;:&quot;3d86f187-c527-40b9-a885-12b535da01d2&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to remove non-existent IPs from a group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should fail when trying to remove non-existent IPs from a group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4363,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const groupResult = await client.groupClient.registerGroup({\n    groupPool: groupPoolAddress,\n});\nconst testGroupId = groupResult.groupId;\nconst nonExistentIpId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.removeIpsFromGroup({\n    groupIpId: testGroupId,\n    ipIds: [nonExistentIpId],\n})).to.be.rejectedWith(\&quot;Failed to remove IPs from group\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;09315e30-a136-4092-835c-17b1c843d580&quot;,&quot;parentUUID&quot;:&quot;3d86f187-c527-40b9-a885-12b535da01d2&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;5d349801-948e-4784-b242-02aea34b3e54&quot;,&quot;7d2a09a3-2953-4c91-a686-d48e565d3110&quot;,&quot;6a5ed62b-df4f-4972-9671-143c67fb8236&quot;,&quot;09315e30-a136-4092-835c-17b1c843d580&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:26797,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;d185d6c4-c2d0-4648-bd77-7f8570624e88&quot;,&quot;70529bf7-8bee-483f-93f1-8c529204f3a7&quot;,&quot;8e11e334-4a35-48ce-8372-852acd1d86bf&quot;,&quot;b87d4865-8ba5-4459-888f-51fe1b51d01e&quot;,&quot;b89c99d7-a72e-4bb4-a90d-efd5c25c4a77&quot;,&quot;1fca043d-0f68-4155-aff4-7a55d91301d6&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:30407,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;c36b1758-4d2c-4cda-b0bd-5bef19f698f5&quot;,&quot;title&quot;:&quot;Collect Royalty and Claim Reward&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Collect Royalty and Claim Reward\&quot;&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward \&quot;before all\&quot; hook in \&quot;Collect Royalty and Claim Reward\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9059,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Register IP id\nconst result1 = await mintAndRegisterIpAssetWithPilTermsHelper();\nipId = result1.ipId;\nlicenseTermsId = result1.licenseTermsIds[0];\n// Register group id\ngroupIpId = await registerGroupAndAttachLicenseHelper(licenseTermsId, [ipId]);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6c5b9429-0e7e-4bff-9332-32996d44c975&quot;,&quot;parentUUID&quot;:&quot;c36b1758-4d2c-4cda-b0bd-5bef19f698f5&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully collect royalties&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully collect royalties&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17756,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Mint and register child IP id\nconst childIpId = await mintAndRegisterIpAndMakeDerivativeHelper(groupIpId, licenseTermsId);\n// Pay royalties from child IP id to group IP id and transfer to vault\nawait payRoyaltyAndTransferToVaultHelper(childIpId, groupIpId, src_1.WIP_TOKEN_ADDRESS, 100n);\n// Collect royalties\nconst result = await client.groupClient.collectRoyalties({\n    groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.collectedRoyalties).to.equal(10n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1ad2ff08-076a-4b40-b1b2-342fd141668f&quot;,&quot;parentUUID&quot;:&quot;c36b1758-4d2c-4cda-b0bd-5bef19f698f5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully get claimable reward&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully get claimable reward&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:31,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.getClaimableReward({\n    groupIpId: groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n});\n(0, chai_1.expect)(result).to.deep.equal([10n]);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f4ba3212-5f97-4ea7-ad9b-2780f34de660&quot;,&quot;parentUUID&quot;:&quot;c36b1758-4d2c-4cda-b0bd-5bef19f698f5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully claim reward&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully claim reward&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8934,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Mint license tokens to the IP id which doesn&#x27;t have a royalty vault\nawait client.license.mintLicenseTokens({\n    licensorIpId: ipId,\n    licenseTermsId,\n    amount: 100,\n    maxMintingFee: 1,\n    maxRevenueShare: 100,\n});\n// Claim reward\nconst result = await client.groupClient.claimReward({\n    groupIpId: groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.claimedReward?.[0].amount[0]).to.equal(10n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;31f97f74-4425-45bd-bfd0-90b263ebcd63&quot;,&quot;parentUUID&quot;:&quot;c36b1758-4d2c-4cda-b0bd-5bef19f698f5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to claim reward for a non-existent group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should fail when trying to claim reward for a non-existent group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:32,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const nonExistentGroupId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.claimReward({\n    groupIpId: nonExistentGroupId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n})).to.be.rejectedWith(\&quot;Failed to claim reward\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7ff95907-5174-4200-983f-6e786760bd9b&quot;,&quot;parentUUID&quot;:&quot;c36b1758-4d2c-4cda-b0bd-5bef19f698f5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to claim reward with invalid token address&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should fail when trying to claim reward with invalid token address&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:40,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const invalidTokenAddress = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.claimReward({\n    groupIpId: groupIpId,\n    currencyToken: invalidTokenAddress,\n    memberIpIds: [ipId],\n})).to.be.rejectedWith(\&quot;Failed to claim reward\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c14c9140-84f4-45b7-a050-d3e8800c6a57&quot;,&quot;parentUUID&quot;:&quot;c36b1758-4d2c-4cda-b0bd-5bef19f698f5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully collect royalties and claim reward in one transaction&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully collect royalties and claim reward in one transaction&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:45148,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const ipIds = [];\nconst result1 = await mintAndRegisterIpAssetWithPilTermsHelper();\nconst result2 = await mintAndRegisterIpAssetWithPilTermsHelper();\nipIds.push(result1.ipId);\nipIds.push(result2.ipId);\nlicenseTermsId = result1.licenseTermsIds[0];\nconst groupId = await registerGroupAndAttachLicenseHelper(licenseTermsId, ipIds);\nconst childIpId1 = await mintAndRegisterIpAndMakeDerivativeHelper(groupId, licenseTermsId);\nconst childIpId2 = await mintAndRegisterIpAndMakeDerivativeHelper(groupId, licenseTermsId);\nawait payRoyaltyAndTransferToVaultHelper(childIpId1, groupId, src_1.WIP_TOKEN_ADDRESS, 100n);\nawait payRoyaltyAndTransferToVaultHelper(childIpId2, groupId, src_1.WIP_TOKEN_ADDRESS, 100n);\nconst result = await client.groupClient.collectAndDistributeGroupRoyalties({\n    groupIpId: groupId,\n    currencyTokens: [src_1.WIP_TOKEN_ADDRESS],\n    memberIpIds: ipIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.collectedRoyalties?.[0].amount).to.equal(20n);\n(0, chai_1.expect)(result.royaltiesDistributed?.[0].amount).to.equal(10n);\n(0, chai_1.expect)(result.royaltiesDistributed?.[1].amount).to.equal(10n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9b744f20-34d0-45cf-8472-0072d225dc9d&quot;,&quot;parentUUID&quot;:&quot;c36b1758-4d2c-4cda-b0bd-5bef19f698f5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1ad2ff08-076a-4b40-b1b2-342fd141668f&quot;,&quot;f4ba3212-5f97-4ea7-ad9b-2780f34de660&quot;,&quot;31f97f74-4425-45bd-bfd0-90b263ebcd63&quot;,&quot;7ff95907-5174-4200-983f-6e786760bd9b&quot;,&quot;c14c9140-84f4-45b7-a050-d3e8800c6a57&quot;,&quot;9b744f20-34d0-45cf-8472-0072d225dc9d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:71941,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;dae4a30b-9996-408f-baee-ae33555f36d2&quot;,&quot;title&quot;:&quot;IPAccount Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;IPAccount Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions \&quot;before all\&quot; hook in \&quot;IPAccount Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8679,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = registerResult.ipId;\ndata = (0, viem_1.encodeFunctionData)({\n    abi: generated_1.accessControllerAbi,\n    functionName: \&quot;setTransientPermission\&quot;,\n    args: [\n        (0, viem_1.getAddress)(ipId),\n        (0, viem_1.getAddress)(util_1.TEST_WALLET_ADDRESS),\n        (0, viem_1.getAddress)(coreMetadataModule),\n        (0, viem_1.toFunctionSelector)(\&quot;function setAll(address,string,bytes32,bytes32)\&quot;),\n        src_1.AccessPermission.ALLOW,\n    ],\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d4635f42-e4f4-462a-9c37-849309ef1d1c&quot;,&quot;parentUUID&quot;:&quot;dae4a30b-9996-408f-baee-ae33555f36d2&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully set ip metadata&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions should successfully set ip metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4386,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txHash = await client.ipAccount.setIpMetadata({\n    ipId: ipId,\n    metadataURI: \&quot;https://example.com\&quot;,\n    metadataHash: (0, viem_1.toHex)(\&quot;test\&quot;, { size: 32 }),\n});\n(0, chai_1.expect)(txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d22a8669-2b0a-45c5-9029-befe72bd2eab&quot;,&quot;parentUUID&quot;:&quot;dae4a30b-9996-408f-baee-ae33555f36d2&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully transfer ERC20 tokens&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions should successfully transfer ERC20 tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17717,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const erc20 = new generated_1.Erc20Client(util_1.publicClient, util_1.walletClient);\n// 1. Query token balance of ipId and wallet before\nconst initialErc20BalanceOfIpId = await erc20.balanceOf({\n    account: ipId,\n});\nconst initialErc20BalanceOfWallet = await erc20.balanceOf({\n    account: util_1.TEST_WALLET_ADDRESS,\n});\nconst initialWipBalanceOfIpId = await client.wipClient.balanceOf(ipId);\nconst initialWipBalanceOfWallet = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n// 2. transfer erc20 token to the ip account\nconst txHash = await erc20.mint({\n    to: ipId,\n    amount: (0, viem_1.parseEther)(\&quot;0.002\&quot;),\n});\nawait util_1.publicClient.waitForTransactionReceipt({\n    hash: txHash,\n});\n// 3. transfer wip to the ip account\nawait client.wipClient.deposit({\n    amount: 1n,\n});\nawait client.wipClient.transfer({\n    to: ipId,\n    amount: 1n,\n});\n// 4. transfer token of ip account to wallet address\nconst ret = await client.ipAccount.transferErc20({\n    ipId,\n    tokens: [\n        {\n            address: src_1.WIP_TOKEN_ADDRESS,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: 1n,\n        },\n        {\n            address: erc20.address,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: (0, viem_1.parseEther)(\&quot;0.001\&quot;),\n        },\n        {\n            address: erc20.address,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: (0, viem_1.parseEther)(\&quot;0.001\&quot;),\n        },\n    ],\n});\n// 5. query token balance of ipId and wallet address after\nconst finalErc20BalanceOfIpId = await erc20.balanceOf({\n    account: ipId,\n});\nconst finalWipBalanceOfIpId = await client.wipClient.balanceOf(ipId);\nconst finalErc20BalanceOfWallet = await erc20.balanceOf({\n    account: util_1.TEST_WALLET_ADDRESS,\n});\nconst finalWipBalanceOfWallet = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(ret.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(finalErc20BalanceOfIpId).to.equal(initialErc20BalanceOfIpId);\n(0, chai_1.expect)(finalWipBalanceOfIpId).to.equal(initialWipBalanceOfIpId);\n(0, chai_1.expect)(finalErc20BalanceOfWallet).to.equal(initialErc20BalanceOfWallet + (0, viem_1.parseEther)(\&quot;0.002\&quot;));\n(0, chai_1.expect)(finalWipBalanceOfWallet).to.equal(initialWipBalanceOfWallet + 1n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c4d2f74d-516f-48e5-bc65-a322bc5adbf8&quot;,&quot;parentUUID&quot;:&quot;dae4a30b-9996-408f-baee-ae33555f36d2&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;2ea67a18-71de-4fdb-b2e1-044be38889c1&quot;,&quot;title&quot;:&quot;execute&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully execute a transaction&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions execute should successfully execute a transaction&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4348,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.ipAccount.execute({\n    to: permissionAddress,\n    value: 0,\n    data: data,\n    ipId: ipId,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c0caf69a-13b9-430b-a303-42049bbf5626&quot;,&quot;parentUUID&quot;:&quot;2ea67a18-71de-4fdb-b2e1-044be38889c1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid ipId&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions execute should fail with invalid ipId&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:38,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.execute({\n    to: permissionAddress,\n    value: 0,\n    data: data,\n    ipId: \&quot;0x0000000000000000000000000000000000000000\&quot;,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;00e0045f-7614-4e0c-8e21-05e3d870ceed&quot;,&quot;parentUUID&quot;:&quot;2ea67a18-71de-4fdb-b2e1-044be38889c1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;c0caf69a-13b9-430b-a303-42049bbf5626&quot;,&quot;00e0045f-7614-4e0c-8e21-05e3d870ceed&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4386,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;0a30943f-ff23-405b-a30c-09d2afcf6bbf&quot;,&quot;title&quot;:&quot;executeWithSig&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should fail with expired deadline&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with expired deadline&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:38,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: EXPIRED_DEADLINE,\n    signature: \&quot;0x\&quot;,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;786055af-d9a5-49ef-a1f2-0d6ed94aa70d&quot;,&quot;parentUUID&quot;:&quot;0a30943f-ff23-405b-a30c-09d2afcf6bbf&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;786055af-d9a5-49ef-a1f2-0d6ed94aa70d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:38,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;2546abd8-6cab-48ae-935c-88d46da63d96&quot;,&quot;title&quot;:&quot;getIpAccountNonce&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully return account nonce&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getIpAccountNonce should successfully return account nonce&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:60,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.ipAccount.getIpAccountNonce(ipId);\n(0, chai_1.expect)(response).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;51b6ea15-ab73-498c-b0ef-cd700fb3e201&quot;,&quot;parentUUID&quot;:&quot;2546abd8-6cab-48ae-935c-88d46da63d96&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid ipId&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getIpAccountNonce should fail with invalid ipId&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:38,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.getIpAccountNonce(\&quot;0x0000000000000000000000000000000000000000\&quot;))\n    .to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a9ea4d8d-6b9a-4c2b-a991-27140afdcf2e&quot;,&quot;parentUUID&quot;:&quot;2546abd8-6cab-48ae-935c-88d46da63d96&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;51b6ea15-ab73-498c-b0ef-cd700fb3e201&quot;,&quot;a9ea4d8d-6b9a-4c2b-a991-27140afdcf2e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:98,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;cca364f3-6afb-41f7-8b99-1439befbfbb2&quot;,&quot;title&quot;:&quot;getToken&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully return token information&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getToken should successfully return token information&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:36,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.ipAccount.getToken(ipId);\n(0, chai_1.expect)(response.chainId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(response.tokenContract).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.tokenId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(response.tokenContract).to.equal(util_1.mockERC721);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;dfc972bb-d327-4f56-a7c4-bb5380649ea2&quot;,&quot;parentUUID&quot;:&quot;cca364f3-6afb-41f7-8b99-1439befbfbb2&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid ipId&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getToken should fail with invalid ipId&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:37,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.getToken(\&quot;0x0000000000000000000000000000000000000000\&quot;)).to.be\n    .rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9a2ce9c0-a3c8-4874-b1e3-27267538841c&quot;,&quot;parentUUID&quot;:&quot;cca364f3-6afb-41f7-8b99-1439befbfbb2&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;dfc972bb-d327-4f56-a7c4-bb5380649ea2&quot;,&quot;9a2ce9c0-a3c8-4874-b1e3-27267538841c&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:73,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;d22a8669-2b0a-45c5-9029-befe72bd2eab&quot;,&quot;c4d2f74d-516f-48e5-bc65-a322bc5adbf8&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:22103,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;944619b0-e80f-45ed-a2fd-437a642dbd2e&quot;,&quot;title&quot;:&quot;IP Asset Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;IP Asset Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions \&quot;before all\&quot; hook in \&quot;IP Asset Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:37,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst res = await client.license.registerNonComSocialRemixingPIL();\nnoCommercialLicenseTermsId = res.licenseTermsId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;739364fb-5824-46aa-9753-e7495f76de5b&quot;,&quot;parentUUID&quot;:&quot;944619b0-e80f-45ed-a2fd-437a642dbd2e&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;e854be61-980f-4668-b0e8-78dc682ec4df&quot;,&quot;title&quot;:&quot;Basic IP Asset Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register an IP Asset&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register an IP Asset&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8766,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nchildIpId = response.ipId;\n(0, chai_1.expect)(childIpId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9ff7f630-395b-4704-8328-970e5d3a9b84&quot;,&quot;parentUUID&quot;:&quot;e854be61-980f-4668-b0e8-78dc682ec4df&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register an IP Asset with multiple metadata fields&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register an IP Asset with multiple metadata fields&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8845,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    ipMetadata: {\n        ipMetadataURI: \&quot;ipfs://test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataURI: \&quot;ipfs://test-nft-uri\&quot;,\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\nchildIpId2 = response.ipId;\n(0, chai_1.expect)(response.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3d38e5e4-c364-4a4e-a465-80e21750a30d&quot;,&quot;parentUUID&quot;:&quot;e854be61-980f-4668-b0e8-78dc682ec4df&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should not register with invalid metadata hash length&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should not register with invalid metadata hash length&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4459,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    ipMetadata: {\n        ipMetadataHash: \&quot;0x123\&quot;, // Invalid length hash\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;valid-hash\&quot;, { size: 32 }),\n    },\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;96aec222-4ca0-4ff4-ba85-8d253326efd9&quot;,&quot;parentUUID&quot;:&quot;e854be61-980f-4668-b0e8-78dc682ec4df&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should not register with non-existent token ID&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should not register with non-existent token ID&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:129,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: BigInt(Number.MAX_SAFE_INTEGER),\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;158ea6ef-d7b2-4c3b-8348-e3c7d2e2a47e&quot;,&quot;parentUUID&quot;:&quot;e854be61-980f-4668-b0e8-78dc682ec4df&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with Non-Commercial Remix PIL&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with Non-Commercial Remix PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17798,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nparentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [noCommercialLicenseTermsId],\n    maxMintingFee: \&quot;0\&quot;,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: \&quot;0\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b852cbe5-c397-4a7d-aff6-34b73d4e6e0e&quot;,&quot;parentUUID&quot;:&quot;e854be61-980f-4668-b0e8-78dc682ec4df&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with Commercial Remix PIL&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with Commercial Remix PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18079,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Register commercial remix PIL\nconst licenseResponse = await client.license.registerCommercialRemixPIL({\n    defaultMintingFee: 10n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\n// Register parent IP\nconst tokenId = await (0, util_1.getTokenId)();\nconst commercialParentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// Attach license terms to parent IP\nawait client.license.attachLicenseTerms({\n    ipId: commercialParentIpId,\n    licenseTermsId: licenseResponse.licenseTermsId,\n});\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: childIpId2,\n    parentIpIds: [commercialParentIpId],\n    licenseTermsIds: [licenseResponse.licenseTermsId],\n    maxMintingFee: \&quot;100\&quot;,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: \&quot;100\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d388105f-02e1-408d-8cb6-fb58feb8d234&quot;,&quot;parentUUID&quot;:&quot;e854be61-980f-4668-b0e8-78dc682ec4df&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with multiple parent IPs&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with multiple parent IPs&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:40155,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create first parent IP\nconst tokenId1 = await (0, util_1.getTokenId)();\nconst parentIpId1 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n})).ipId;\n// Create second parent IP\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst parentIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId2,\n})).ipId;\n// Attach license terms to both parents\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId1,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId2,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\n// Create child IP\nconst childTokenId = await (0, util_1.getTokenId)();\nconst newChildIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId,\n})).ipId;\n// Register derivative with multiple parents\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: newChildIpId,\n    parentIpIds: [parentIpId1, parentIpId2],\n    licenseTermsIds: [noCommercialLicenseTermsId, noCommercialLicenseTermsId],\n    maxMintingFee: \&quot;0\&quot;,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: \&quot;0\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fe5d7819-5c02-4dad-a3f5-90ba7672538d&quot;,&quot;parentUUID&quot;:&quot;e854be61-980f-4668-b0e8-78dc682ec4df&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:21777,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst ipId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: noCommercialLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \&quot;0\&quot;,\n    maxRevenueShare: 1,\n});\nconst response = await client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;126e7c95-5cae-41fd-820d-139685e1557c&quot;,&quot;parentUUID&quot;:&quot;e854be61-980f-4668-b0e8-78dc682ec4df&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should return true if IP asset is registered&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should return true if IP asset is registered&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:39,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const isRegistered = await client.ipAsset.isRegistered(parentIpId);\n(0, chai_1.expect)(isRegistered).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cc31a6e6-a87b-4d5e-91bf-db093fdfee51&quot;,&quot;parentUUID&quot;:&quot;e854be61-980f-4668-b0e8-78dc682ec4df&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should return false if IP asset is not registered&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should return false if IP asset is not registered&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:37,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const isRegistered = await client.ipAsset.isRegistered(\&quot;0x1234567890123456789012345678901234567890\&quot;);\n(0, chai_1.expect)(isRegistered).to.equal(false);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3822dc10-3f70-4287-8b58-2615a7dfecff&quot;,&quot;parentUUID&quot;:&quot;e854be61-980f-4668-b0e8-78dc682ec4df&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;9ff7f630-395b-4704-8328-970e5d3a9b84&quot;,&quot;3d38e5e4-c364-4a4e-a465-80e21750a30d&quot;,&quot;96aec222-4ca0-4ff4-ba85-8d253326efd9&quot;,&quot;158ea6ef-d7b2-4c3b-8348-e3c7d2e2a47e&quot;,&quot;b852cbe5-c397-4a7d-aff6-34b73d4e6e0e&quot;,&quot;d388105f-02e1-408d-8cb6-fb58feb8d234&quot;,&quot;fe5d7819-5c02-4dad-a3f5-90ba7672538d&quot;,&quot;126e7c95-5cae-41fd-820d-139685e1557c&quot;,&quot;cc31a6e6-a87b-4d5e-91bf-db093fdfee51&quot;,&quot;3822dc10-3f70-4287-8b58-2615a7dfecff&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:120084,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;title&quot;:&quot;SPG NFT Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;SPG NFT Operations\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations \&quot;before all\&quot; hook in \&quot;SPG NFT Operations\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9829,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Setup NFT collection\nconst txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\n// Setup license terms\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContract,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];\n// Setup ERC20\nconst mockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\nawait mockERC20.approve(generated_1.derivativeWorkflowsAddress[util_1.aeneid], viem_1.maxUint256);\nawait mockERC20.approve(generated_1.royaltyTokenDistributionWorkflowsAddress[util_1.aeneid], viem_1.maxUint256);\nawait mockERC20.mint(util_1.TEST_WALLET_ADDRESS, 100000n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5abadcbe-b192-4a9a-b34e-c6cb3e24d358&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register IP Asset with metadata&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP Asset with metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12879,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst response = await client.ipAsset.register({\n    nftContract,\n    tokenId,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(response.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;773d4435-02aa-4eb1-b45e-a09276aa50e0&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative IP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register derivative IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9150,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenChildId = await (0, util_1.mintBySpg)(nftContract);\nconst result = await client.ipAsset.registerDerivativeIp({\n    nftContract: nftContract,\n    tokenId: tokenChildId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: \&quot;0\&quot;,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: \&quot;0\&quot;,\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d922dfea-c8b2-4958-930a-f7205f7d78c3&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach PIL terms&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach PIL terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9232,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: nftContract,\n    tokenId,\n    deadline: 1000n,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 10000n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0d8b8297-5da2-4113-8bde-3cb2609931af&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach PIL terms with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach PIL terms with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9435,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 10000n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6b26ddff-496a-4935-85a4-ec4e99529a14&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and make derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and make derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4753,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0e7f8e9c-a1c4-4ff9-abd6-85061393a86d&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4433,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: nftContract,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    allowDuplicates: false,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;71a06f75-579d-49af-b966-185c42f529f0&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register PIL terms and attach&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register PIL terms and attach&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4552,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerPilTermsAndAttach({\n    ipId: parentIpId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5c32a1da-f1b9-472d-ace1-abe4bce7b084&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register PIL terms and attach with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register PIL terms and attach with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5294,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerPilTermsAndAttach({\n    ipId: parentIpId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f5b5576f-0758-430a-adbf-0f47a0523913&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and make derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and make derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13373,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \&quot;0\&quot;,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], mintLicenseTokensResult.licenseTokenIds[0]);\nconst result = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: nftContract,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c2de9d38-1f69-479c-b1f8-09072242b774&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and make derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and make derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17701,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \&quot;0\&quot;,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], mintLicenseTokensResult.licenseTokenIds[0]);\nconst result = await client.ipAsset.registerIpAndMakeDerivativeWithLicenseTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;24755c4e-9efd-4e73-b1f8-87996a67a534&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach license terms and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13668,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 1,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7f99e04d-8d64-4762-92cd-4353738ff867&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach license terms and distribute royalty tokens with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14537,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 1,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9ae8574a-171b-42dc-97e1-b6aeb920ed97&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach license terms and distribute royalty tokens with complex royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens with complex royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13528,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: generated_1.erc20Address[util_1.aeneid],\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 43,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 17,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 2,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 38,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a4ccdfc7-9833-4fd6-9a2e-295d9c779761&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative and attach license terms and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register derivative and attach license terms and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13429,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: \&quot;0\&quot;,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: \&quot;0\&quot;,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5eb3220c-e97a-481a-96f2-4fa7d1ac851c&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and attach PIL terms and distribute royalty tokens without licensing config&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and attach PIL terms and distribute royalty tokens without licensing config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4652,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: nftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;00ede0c6-cc7f-4f4a-8dce-55604273eca2&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and attach PIL terms and distribute royalty tokens with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and attach PIL terms and distribute royalty tokens with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5135,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: nftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            maxLicenseTokens: 100,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 11n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;94925bd9-e122-4be7-9a95-af2ab0d341c9&quot;,&quot;parentUUID&quot;:&quot;b57092ab-4cde-442f-8b5d-e737eb7eaa1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;773d4435-02aa-4eb1-b45e-a09276aa50e0&quot;,&quot;d922dfea-c8b2-4958-930a-f7205f7d78c3&quot;,&quot;0d8b8297-5da2-4113-8bde-3cb2609931af&quot;,&quot;6b26ddff-496a-4935-85a4-ec4e99529a14&quot;,&quot;0e7f8e9c-a1c4-4ff9-abd6-85061393a86d&quot;,&quot;71a06f75-579d-49af-b966-185c42f529f0&quot;,&quot;5c32a1da-f1b9-472d-ace1-abe4bce7b084&quot;,&quot;f5b5576f-0758-430a-adbf-0f47a0523913&quot;,&quot;c2de9d38-1f69-479c-b1f8-09072242b774&quot;,&quot;24755c4e-9efd-4e73-b1f8-87996a67a534&quot;,&quot;7f99e04d-8d64-4762-92cd-4353738ff867&quot;,&quot;9ae8574a-171b-42dc-97e1-b6aeb920ed97&quot;,&quot;a4ccdfc7-9833-4fd6-9a2e-295d9c779761&quot;,&quot;5eb3220c-e97a-481a-96f2-4fa7d1ac851c&quot;,&quot;00ede0c6-cc7f-4f4a-8dce-55604273eca2&quot;,&quot;94925bd9-e122-4be7-9a95-af2ab0d341c9&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:155751,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;7dd64107-a9f8-4b87-8b8e-f63d015e594b&quot;,&quot;title&quot;:&quot;SPG With Minting Fees with Public Minting SPG NFT Contract&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;SPG With Minting Fees with Public Minting SPG NFT Contract\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract \&quot;before all\&quot; hook in \&quot;SPG With Minting Fees with Public Minting SPG NFT Contract\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13476,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// ensure we start with no wip since we will be wrapping them\nconst wipBalance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nif (wipBalance &gt; 0n) {\n    await client.wipClient.withdraw({\n        amount: wipBalance,\n    });\n}\n// create a nft collection that requires minting fee\nconst rsp = await client.nftClient.createNFTCollection({\n    name: \&quot;Premium Collection\&quot;,\n    symbol: \&quot;PC\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 100n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nnftContractWithMintingFee = rsp.spgNftContract;\n// create parent ip with minting fee\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContractWithMintingFee,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 150n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: true,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: BigInt(0),\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: BigInt(0),\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 150n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;48404e5f-b3da-4baa-9add-fb52a3e413f8&quot;,&quot;parentUUID&quot;:&quot;7dd64107-a9f8-4b87-8b8e-f63d015e594b&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should auto wrap ip when mint and register derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4988,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const userBalanceBefore = await client.getWalletBalance();\nconst rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContractWithMintingFee, // pay 100 here\n    derivData: {\n        parentIpIds: [parentIpId], // pay 150 here\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test\&quot;,\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \&quot;test\&quot;,\n        nftMetadataHash: viem_1.zeroHash,\n    },\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);\nconst userBalanceAfter = await client.getWalletBalance();\nconst cost = 150n + 100n;\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - cost));\n// user should not have any WIP tokens since we swap the exact amount\nconst wipBalance = await client.ipAsset.wipClient.balanceOf({\n    owner: util_1.TEST_WALLET_ADDRESS,\n});\n(0, chai_1.expect)(wipBalance.result).to.be.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7f2cb010-e75b-4386-a03b-c80876857678&quot;,&quot;parentUUID&quot;:&quot;7dd64107-a9f8-4b87-8b8e-f63d015e594b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto wrap ip when mint and register derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22162,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenIds[0]);\n(0, chai_1.expect)(licenseTokenIds).to.be.an(\&quot;array\&quot;);\nconst { txHash, ipId } = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: nftContractWithMintingFee,\n    licenseTokenIds: licenseTokenIds,\n    maxRts: common_1.MAX_ROYALTY_TOKEN,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test\&quot;,\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \&quot;test\&quot;,\n        nftMetadataHash: viem_1.zeroHash,\n    },\n});\n(0, chai_1.expect)(txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(ipId).to.be.a(\&quot;string\&quot;);\nconst isRegistered = await client.ipAsset.isRegistered(ipId);\n(0, chai_1.expect)(isRegistered).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a3448254-c42e-46e0-8dc2-384061e2f1f2&quot;,&quot;parentUUID&quot;:&quot;7dd64107-a9f8-4b87-8b8e-f63d015e594b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto wrap ip when registering derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when registering derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13488,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst balanceBefore = await client.getWalletBalance();\nconst rsp = await client.ipAsset.registerDerivativeIp({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 150n));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;af1e2133-db23-43e0-b5ad-c6fdbe62c633&quot;,&quot;parentUUID&quot;:&quot;7dd64107-a9f8-4b87-8b8e-f63d015e594b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should spend existing wip when register derivative and distribute loyalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should spend existing wip when register derivative and distribute loyalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17849,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nawait client.wipClient.deposit({\n    amount: 150n,\n});\nconst rsp = await client.ipAsset.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.be.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;aeaf920b-a0ad-4748-81f7-93e498003bef&quot;,&quot;parentUUID&quot;:&quot;7dd64107-a9f8-4b87-8b8e-f63d015e594b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto wrap ip when mint and register derivative and distribute loyalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative and distribute loyalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4899,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens({\n    spgNftContract: nftContractWithMintingFee,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test\&quot;,\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \&quot;test\&quot;,\n        nftMetadataHash: viem_1.zeroHash,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c4824b84-ca3f-4cf2-b687-839ecf1fac5b&quot;,&quot;parentUUID&quot;:&quot;7dd64107-a9f8-4b87-8b8e-f63d015e594b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;7f2cb010-e75b-4386-a03b-c80876857678&quot;,&quot;a3448254-c42e-46e0-8dc2-384061e2f1f2&quot;,&quot;af1e2133-db23-43e0-b5ad-c6fdbe62c633&quot;,&quot;aeaf920b-a0ad-4748-81f7-93e498003bef&quot;,&quot;c4824b84-ca3f-4cf2-b687-839ecf1fac5b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:63386,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;4a5d1bc4-ce4c-4c7b-8012-6b9e304e3bcc&quot;,&quot;title&quot;:&quot;IP Asset Registration with Private Minting SPG NFT Contracts&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;IP Asset Registration with Private Minting SPG NFT Contracts\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts \&quot;before all\&quot; hook in \&quot;IP Asset Registration with Private Minting SPG NFT Contracts\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4313,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;Private Minting Collection\&quot;,\n    symbol: \&quot;PMC\&quot;,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 3n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \&quot;\&quot;,\n});\nspgNftContractWithPrivateMinting = privateMintingCollectionResult.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f2da51aa-0b5f-4dde-9cba-40e6d565d318&quot;,&quot;parentUUID&quot;:&quot;4a5d1bc4-ce4c-4c7b-8012-6b9e304e3bcc&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when call mint and register ip asset with pil terms&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip asset with pil terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13413,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a9c1ca46-72de-4e39-9afe-adb8cb8cc010&quot;,&quot;parentUUID&quot;:&quot;4a5d1bc4-ce4c-4c7b-8012-6b9e304e3bcc&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip asset with pil terms with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip asset with pil terms with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9764,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 5n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 5n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n    ipMetadata: {\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;803c922c-2789-4a24-8e58-1dd48b3533ad&quot;,&quot;parentUUID&quot;:&quot;4a5d1bc4-ce4c-4c7b-8012-6b9e304e3bcc&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip and make derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and make derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9141,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 100n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;69187cc5-6623-4f22-8ec1-4d89c1562aa6&quot;,&quot;parentUUID&quot;:&quot;4a5d1bc4-ce4c-4c7b-8012-6b9e304e3bcc&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8906,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    allowDuplicates: false,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1be4dcdb-0e23-4add-afe7-58e33b102656&quot;,&quot;parentUUID&quot;:&quot;4a5d1bc4-ce4c-4c7b-8012-6b9e304e3bcc&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip and make derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and make derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:21841,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \&quot;0\&quot;,\n    maxRevenueShare: 100,\n});\nconst licenseTokenId = mintLicenseTokensResult.licenseTokenIds[0];\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenId);\nconst result = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    licenseTokenIds: [licenseTokenId],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;348da11b-1801-4bd2-86c1-60182fd37b9b&quot;,&quot;parentUUID&quot;:&quot;4a5d1bc4-ce4c-4c7b-8012-6b9e304e3bcc&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip and attach pil terms and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and attach pil terms and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9121,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3eb8632b-2b9f-4255-8148-57384c3230f1&quot;,&quot;parentUUID&quot;:&quot;4a5d1bc4-ce4c-4c7b-8012-6b9e304e3bcc&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should succeed when call mint and register ip and make derivative and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should succeed when call mint and register ip and make derivative and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22300,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: true,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\nconst newParentIpId = result.ipId;\nconst licenseId = result.licenseTermsIds[0];\nconst rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    derivData: {\n        parentIpIds: [newParentIpId],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;249c2e81-8cea-4bf5-909e-f6ca16e26670&quot;,&quot;parentUUID&quot;:&quot;4a5d1bc4-ce4c-4c7b-8012-6b9e304e3bcc&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a9c1ca46-72de-4e39-9afe-adb8cb8cc010&quot;,&quot;803c922c-2789-4a24-8e58-1dd48b3533ad&quot;,&quot;69187cc5-6623-4f22-8ec1-4d89c1562aa6&quot;,&quot;1be4dcdb-0e23-4add-afe7-58e33b102656&quot;,&quot;348da11b-1801-4bd2-86c1-60182fd37b9b&quot;,&quot;3eb8632b-2b9f-4255-8148-57384c3230f1&quot;,&quot;249c2e81-8cea-4bf5-909e-f6ca16e26670&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:94486,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;51382303-3b15-4efd-b0bb-73d8f93d579d&quot;,&quot;title&quot;:&quot;Batch Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Batch Operations\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations \&quot;before all\&quot; hook in \&quot;Batch Operations\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17096,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\nconst tokenId = await (0, util_1.getTokenId)();\nparentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;df749027-a050-4b0c-b23b-726eb4db0404&quot;,&quot;parentUUID&quot;:&quot;51382303-3b15-4efd-b0bb-73d8f93d579d&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should batch register derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch register derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:34779,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const childTokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId,\n})).ipId;\nconst childTokenId2 = await (0, util_1.getTokenId)();\nconst childIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId2,\n})).ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nconst result = await client.ipAsset.batchRegisterDerivative({\n    args: [\n        {\n            childIpId: childIpId,\n            parentIpIds: [parentIpId],\n            licenseTermsIds: [noCommercialLicenseTermsId],\n            maxMintingFee: \&quot;0\&quot;,\n            maxRts: 5 * 10 ** 6,\n            maxRevenueShare: \&quot;0\&quot;,\n        },\n        {\n            childIpId: childIpId2,\n            parentIpIds: [parentIpId],\n            licenseTermsIds: [noCommercialLicenseTermsId],\n            maxMintingFee: \&quot;0\&quot;,\n            maxRts: 5 * 10 ** 6,\n            maxRevenueShare: \&quot;0\&quot;,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a2cda6a1-d07d-4f8c-a722-a52a8fd4a371&quot;,&quot;parentUUID&quot;:&quot;51382303-3b15-4efd-b0bb-73d8f93d579d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should batch mint and register IP asset with PIL terms&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch mint and register IP asset with PIL terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5535,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.batchMintAndRegisterIpAssetWithPilTerms({\n    args: [\n        {\n            spgNftContract: nftContract,\n            licenseTermsData: [\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 8n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \&quot;\&quot;,\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 8n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                    maxLicenseTokens: 100,\n                },\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 80n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \&quot;\&quot;,\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 100n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                },\n            ],\n        },\n        {\n            spgNftContract: nftContract,\n            licenseTermsData: [\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 8n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \&quot;\&quot;,\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 8n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                    maxLicenseTokens: 100,\n                },\n            ],\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.results).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.results[0].licenseTermsIds).to.be.an(\&quot;array\&quot;).and.length(2);\n(0, chai_1.expect)(result.results[0].maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;).and.length(1);\n(0, chai_1.expect)(result.results[1].licenseTermsIds).to.be.an(\&quot;array\&quot;).and.length(1);\n(0, chai_1.expect)(result.results[1].maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;).and.length(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;af65f078-15c0-4bbb-8bd2-2a37f6796aee&quot;,&quot;parentUUID&quot;:&quot;51382303-3b15-4efd-b0bb-73d8f93d579d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should batch mint and register IP asset and make derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch mint and register IP asset and make derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4829,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract: nftContract,\n            derivData: {\n                parentIpIds: [parentIpId],\n                licenseTermsIds: [noCommercialLicenseTermsId],\n                maxMintingFee: \&quot;0\&quot;,\n                maxRts: 5 * 10 ** 6,\n                maxRevenueShare: \&quot;0\&quot;,\n            },\n        },\n        {\n            spgNftContract: nftContract,\n            derivData: {\n                parentIpIds: [parentIpId],\n                licenseTermsIds: [noCommercialLicenseTermsId],\n                maxMintingFee: \&quot;0\&quot;,\n                maxRts: 5 * 10 ** 6,\n                maxRevenueShare: \&quot;0\&quot;,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.results).to.be.an(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b6b262c3-519b-43b3-86f5-168a174f4166&quot;,&quot;parentUUID&quot;:&quot;51382303-3b15-4efd-b0bb-73d8f93d579d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should batch register giving parameters&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch register giving parameters&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22352,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst spgTokenId1 = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst spgTokenId2 = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId,\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2,\n        },\n        {\n            nftContract,\n            tokenId: spgTokenId1,\n            ipMetadata: {\n                ipMetadataURI: \&quot;test-uri2\&quot;,\n                ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash2\&quot;, { size: 32 }),\n                nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash2\&quot;, { size: 32 }),\n            },\n        },\n        {\n            nftContract,\n            tokenId: spgTokenId2,\n            ipMetadata: {\n                ipMetadataURI: \&quot;test-uri\&quot;,\n                ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n                nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.results).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e9295aba-97bb-4355-811d-ef6d908a78b6&quot;,&quot;parentUUID&quot;:&quot;51382303-3b15-4efd-b0bb-73d8f93d579d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a2cda6a1-d07d-4f8c-a722-a52a8fd4a371&quot;,&quot;af65f078-15c0-4bbb-8bd2-2a37f6796aee&quot;,&quot;b6b262c3-519b-43b3-86f5-168a174f4166&quot;,&quot;e9295aba-97bb-4355-811d-ef6d908a78b6&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:67495,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;50bf39c7-98ee-4789-8efa-8377c2aa2f29&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Error Cases\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Error Cases \&quot;before all\&quot; hook in \&quot;Error Cases\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4352,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;14c525d7-d163-416b-be3b-0ae59c1aa1c9&quot;,&quot;parentUUID&quot;:&quot;50bf39c7-98ee-4789-8efa-8377c2aa2f29&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should fail to register unowned NFT&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Error Cases should fail to register unowned NFT&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:106,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: nftContract,\n    tokenId: 999999n, // Non-existent token\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4024e15b-d34f-4b37-88ac-c89c2ad6108d&quot;,&quot;parentUUID&quot;:&quot;50bf39c7-98ee-4789-8efa-8377c2aa2f29&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;4024e15b-d34f-4b37-88ac-c89c2ad6108d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:106,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;b1821ae9-d2e3-40ef-9601-6756546d0f9a&quot;,&quot;title&quot;:&quot;Other Edge Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Other Edge Cases\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases \&quot;before all\&quot; hook in \&quot;Other Edge Cases\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17300,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst parentIpResponse = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nparentIpId = parentIpResponse.ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fd9e4248-5e8b-4253-b8fe-ad963b446dfa&quot;,&quot;parentUUID&quot;:&quot;b1821ae9-d2e3-40ef-9601-6756546d0f9a&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;63476fd1-afb3-4318-ba39-0723e9843eea&quot;,&quot;title&quot;:&quot;License Token Edge Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should fail when trying to use non-existent license token&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases License Token Edge Cases should fail when trying to use non-existent license token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12914,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId,\n    })).ipId,\n    licenseTokenIds: [BigInt(999999)], // Non-existent token\n    maxRts: 5 * 10 ** 6,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c0de18c4-3ed9-40f1-9375-a7a4db5e4614&quot;,&quot;parentUUID&quot;:&quot;63476fd1-afb3-4318-ba39-0723e9843eea&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to use same license token twice&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases License Token Edge Cases should fail when trying to use same license token twice&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30600,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: noCommercialLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \&quot;0\&quot;,\n    maxRevenueShare: 1,\n});\nconst tokenId1 = await (0, util_1.getTokenId)();\nawait client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n    })).ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n});\nconst tokenId2 = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n    })).ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n})).to.be.rejected; // Should fail as token already used&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;597b05ea-99fa-4c7e-8608-881ca15e693b&quot;,&quot;parentUUID&quot;:&quot;63476fd1-afb3-4318-ba39-0723e9843eea&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;c0de18c4-3ed9-40f1-9375-a7a4db5e4614&quot;,&quot;597b05ea-99fa-4c7e-8608-881ca15e693b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:43514,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;ee56c42e-3df7-4571-8606-bf4705f2e5e0&quot;,&quot;title&quot;:&quot;Batch Operation Edge Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should handle partial failures in batch registration&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases Batch Operation Edge Cases should handle partial failures in batch registration&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17233,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nawait client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n});\nawait (0, chai_1.expect)(client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId1, // Already registered\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2, // New registration\n        },\n    ],\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;76f46326-305f-41d5-849a-c1c708b1f406&quot;,&quot;parentUUID&quot;:&quot;ee56c42e-3df7-4571-8606-bf4705f2e5e0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;76f46326-305f-41d5-849a-c1c708b1f406&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:17233,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;17501532-c73a-4f24-a6e6-a98550d7b581&quot;,&quot;title&quot;:&quot;Batch Register IP Assets With Optimized Workflows&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Batch Register IP Assets With Optimized Workflows\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows \&quot;before all\&quot; hook in \&quot;Batch Register IP Assets With Optimized Workflows\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:43458,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create a public minting NFT collection\nconst publicMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;Public Minting Collection\&quot;,\n    symbol: \&quot;PMC\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \&quot;\&quot;,\n});\nspgNftContractWithPublicMinting = publicMintingCollectionResult.spgNftContract;\n// Create a private minting NFT collection\nconst privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;Private Minting Collection\&quot;,\n    symbol: \&quot;PRC\&quot;,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;\&quot;,\n});\nspgNftContractWithPrivateMinting = privateMintingCollectionResult.spgNftContract;\n// Register a commercial remix PIL license\nconst commercialRemixPILResult = await client.license.registerCommercialRemixPIL({\n    defaultMintingFee: 10n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\nlicenseTermsId1 = commercialRemixPILResult.licenseTermsId;\n// Register a commercial use PIL license\nconst commercialUsePILResult = await client.license.registerPILTerms({\n    transferable: true,\n    royaltyPolicy: \&quot;0xBe54FB168b3c982b7AaE60dB6CF75Bd8447b390E\&quot;,\n    defaultMintingFee: 5n,\n    expiration: 0n,\n    commercialUse: true,\n    commercialAttribution: true,\n    commercializerChecker: viem_1.zeroAddress,\n    commercializerCheckerData: viem_1.zeroAddress,\n    commercialRevShare: 10,\n    commercialRevCeiling: 0n,\n    derivativesAllowed: true,\n    derivativesAttribution: true,\n    derivativesApproval: false,\n    derivativesReciprocal: true,\n    derivativeRevCeiling: 0n,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    uri: \&quot;https://github.com/piplabs/pil-document/blob/ad67bb632a310d2557f8abcccd428e4c9c798db1/off-chain-terms/CommercialRemix.json\&quot;,\n});\nlicenseTermsId2 = commercialUsePILResult.licenseTermsId;\n// Mint and register IP with public minting contract\nconst publicMintingIpResult = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPublicMinting,\n});\nparentIpId1 = publicMintingIpResult.ipId;\n// Attach license terms to the first IP\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId1,\n    licenseTermsId: licenseTermsId1,\n});\n// Mint and register IP with private minting contract\nconst privateMintingIpResult = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPrivateMinting,\n});\nparentIpId2 = privateMintingIpResult.ipId;\n// Attach license terms to the second IP\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId2,\n    licenseTermsId: licenseTermsId2,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;872e500c-0559-4d82-b9dc-77b5b0bef3cc&quot;,&quot;parentUUID&quot;:&quot;17501532-c73a-4f24-a6e6-a98550d7b581&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully batch register multiple IP assets with SPG NFT contracts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully batch register multiple IP assets with SPG NFT contracts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:42229,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15(10+5) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall due to the private minting\n     * - `maxLicenseTokens` is set to 1000n for first license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 1000n,\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 3n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 3n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     * - `maxLicenseTokens` is set to 100n for license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 100n,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 20(10+10) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5(0+5) WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the mint tokens is given `msg.sender` as the recipient\n     * - `maxLicenseTokens` is set to 80n and 10n for license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                maxLicenseTokens: 80n,\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 100n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the mint tokens is given `msg.sender` as the recipient\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n            },\n        ],\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10,\n            },\n        ],\n    },\n];\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\nconst totalFees = 10 + 15 + 0 + 10 + 20 + 5 + 10 + 0;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n/**\n * Transaction breakdown:\n *\n * 1. derivativeWorkflowsClient: 1 transaction\n *    - No license terms attached\n *\n * 2. multicall3Client: 3 transactions\n *    - Second transaction includes license terms with maxLicenseTokens: 1000n\n *\n * 3. licenseAttachmentWorkflowsClient: 1 transaction\n *    - Two license terms attached\n *    - First license terms: maxLicenseTokens: 1000n\n *\n * 4. royaltyTokenDistributionWorkflowsClient: 3 transactions\n *    - Second transaction includes two license terms:\n *    -  First license terms: maxLicenseTokens: 80n\n *    - Second license terms: maxLicenseTokens: 10n\n *   - Third transaction includes a license terms\n *\n * Summary:\n * - Total transactions: 4 (4 unique transaction hashes)\n * - Total IP assets registered: 8\n */\n(0, chai_1.expect)(result.registrationResults.length).equal(4);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;511be526-b692-42ce-a070-baa9fd285493&quot;,&quot;parentUUID&quot;:&quot;17501532-c73a-4f24-a6e6-a98550d7b581&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully batch register multiple IP assets with NFT contracts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully batch register multiple IP assets with NFT contracts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:64248,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst tokenId4 = await (0, util_1.getTokenId)();\nconst tokenId5 = await (0, util_1.getTokenId)();\nconst tokenId6 = await (0, util_1.getTokenId)();\nconst tokenId7 = await (0, util_1.getTokenId)();\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst requests = [\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerIpAndAttachPilTerms  workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall\n     * - `maxLicenseTokens` is set to 100n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId3,\n        deadline: 1000n,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: viem_1.zeroAddress,\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: false,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 10000n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 100n,\n            },\n        ],\n    },\n    /**\n     * registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     * - `maxLicenseTokens` is set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId4,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 1n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 6n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n        ],\n        ipMetadata: {\n            ipMetadataURI: \&quot;test-uri\&quot;,\n            ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n            nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 43,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 17,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 2,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 38,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId5,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId6,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId7,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10,\n            },\n        ],\n    },\n];\nconst totalFees = 10 + 5 + 0 + 0 + 5 + 10 + 5;\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n/**\n * Transaction breakdown:\n * 1. royaltyTokenDistributionWorkflowsClient: 4 args\n *  - The third request has two license terms, first one has `maxLicenseTokens` set to 10n\n *\n * 2.licenseAttachmentWorkflowsClient: 1 arg\n *  - The first request have two license terms, second one has `maxLicenseTokens` set to 100n\n *\n * 3.derivativeWorkflowsClient: 2 args\n *  - None license terms and no `maxLicenseTokens` set\n *\n * Summary:\n * - Total transactions: 3 (3 unique transaction hashes)\n * - Total IP assets registered: 7\n */\n(0, chai_1.expect)(result.registrationResults.length).equal(3);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).greaterThan(0);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(4);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes).equal(undefined);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;847e7f36-0f16-4885-8572-ed35a72c7482&quot;,&quot;parentUUID&quot;:&quot;17501532-c73a-4f24-a6e6-a98550d7b581&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register IP assets using a combination of NFT contracts and SPG NFT contracts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully register IP assets using a combination of NFT contracts and SPG NFT contracts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:58815,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst tokenId4 = await (0, util_1.getTokenId)();\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15(10+5) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5(0+5) WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 20(10+10) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10,\n            },\n        ],\n    },\n    /**\n     * registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     * - `maxLicenseTokens` is set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 1n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n        ipMetadata: {\n            ipMetadataURI: \&quot;test-uri\&quot;,\n            ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n            nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 43,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 17,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 2,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 38,\n            },\n        ],\n    },\n    /**\n     * registerIpAndAttachPilTerms  workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall\n     * - the second request has `maxLicenseTokens` set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId3,\n        deadline: 1000n,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: viem_1.zeroAddress,\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: false,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 10000n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId4,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n];\nconst totalFees = 15 + 5 + 20 + 10 + 5 + 0 + 0 + 10;\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n/**\n * Transaction breakdown:\n * 1. multicall3Client: 2 args\n *  - No license terms and no `maxLicenseTokens` set\n *\n * 2. royaltyTokenDistributionWorkflowsClient: 3 args\n *  - The third request has a license terms and `maxLicenseTokens` set to 10n\n *\n * 3. derivativeWorkflowsClient: 2 args\n *  - None license terms and no `maxLicenseTokens` set\n *\n * 4. licenseAttachmentWorkflowsClient: 1 arg\n *  - The first request have two license terms, second one has `maxLicenseTokens` set to 10n\n *\n * Summary:\n * - Total transactions: 4 (4 unique transaction hashes)\n * - Total IP assets registered: 8\n */\n(0, chai_1.expect)(result.registrationResults.length).equal(4);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).greaterThan(0);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[1].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7e8d7a4e-2ed7-461a-965c-70445e99a7f7&quot;,&quot;parentUUID&quot;:&quot;17501532-c73a-4f24-a6e6-a98550d7b581&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register IP assets with multicall disabled&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully register IP assets with multicall disabled&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:49620,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15(10+5) WIP tokens\n     * - Uses `derivativeWorkflowsClient` to call the this method\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` to call the this method\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` to call the this method\n     * - the first request has `maxLicenseTokens` set to 10n\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 10n,\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient`to call the this method\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient`to call the this method\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n];\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst totalFees = 15 + 0 + 10 + 5 + 5;\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n    options: {\n        wipOptions: {\n            useMulticallWhenPossible: false,\n        },\n    },\n});\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n/**\n * Transaction breakdown:\n * 1. None license terms and no `maxLicenseTokens` set\n * 2. The request have one license terms and no `maxLicenseTokens` set\n * 3. The request have two license terms, first one has `maxLicenseTokens` set to 10n\n * 4. The requests have no license terms and no `maxLicenseTokens` set\n * 5. The requests have no license terms and no `maxLicenseTokens` set\n * Summary:\n * - Total transactions: 5 (5 unique transaction hashes)\n * - Total IP assets registered: 5\n */\n(0, chai_1.expect)(result.registrationResults.length).equal(requests.length);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[4].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[4].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[4].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6098bb9d-9701-4d6d-a558-159ab49394a5&quot;,&quot;parentUUID&quot;:&quot;17501532-c73a-4f24-a6e6-a98550d7b581&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;511be526-b692-42ce-a070-baa9fd285493&quot;,&quot;847e7f36-0f16-4885-8572-ed35a72c7482&quot;,&quot;7e8d7a4e-2ed7-461a-965c-70445e99a7f7&quot;,&quot;6098bb9d-9701-4d6d-a558-159ab49394a5&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:214912,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;2ce05b72-4b55-4ffa-814d-a04962c913c0&quot;,&quot;title&quot;:&quot;License Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;License Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions \&quot;before all\&quot; hook in \&quot;License Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:36,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nclientB = derivedClient.clientB;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;843bcfb4-1988-483b-ba7c-81a4573807da&quot;,&quot;parentUUID&quot;:&quot;2ce05b72-4b55-4ffa-814d-a04962c913c0&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;347df0f2-1172-465c-ace3-7dbf5554477a&quot;,&quot;title&quot;:&quot;register license with different types&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register license &quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license &quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:38,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerPILTerms({\n    defaultMintingFee: 0,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    transferable: false,\n    royaltyPolicy: viem_1.zeroAddress,\n    commercialUse: false,\n    commercialAttribution: false,\n    commercializerChecker: viem_1.zeroAddress,\n    commercializerCheckerData: \&quot;0x\&quot;,\n    commercialRevShare: 0,\n    derivativesAllowed: false,\n    derivativesAttribution: false,\n    derivativesApproval: false,\n    derivativesReciprocal: false,\n    uri: \&quot;\&quot;,\n    expiration: \&quot;\&quot;,\n    commercialRevCeiling: \&quot;\&quot;,\n    derivativeRevCeiling: \&quot;\&quot;,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;11adcf2f-6b27-441e-9a03-a23f3ad992e9&quot;,&quot;parentUUID&quot;:&quot;347df0f2-1172-465c-ace3-7dbf5554477a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with non commercial social remixing PIL&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with non commercial social remixing PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:46,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerNonComSocialRemixingPIL();\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7a060803-0cc1-4037-b52c-69f6cc269c6f&quot;,&quot;parentUUID&quot;:&quot;347df0f2-1172-465c-ace3-7dbf5554477a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with commercial use&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with commercial use&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:32,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerCommercialUsePIL({\n    defaultMintingFee: \&quot;1\&quot;,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8578804d-4309-4ff9-b908-4cf5b725bfc6&quot;,&quot;parentUUID&quot;:&quot;347df0f2-1172-465c-ace3-7dbf5554477a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with commercial Remix use&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with commercial Remix use&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:36,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerCommercialRemixPIL({\n    defaultMintingFee: \&quot;1\&quot;,\n    commercialRevShare: 100,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;af2c5d98-2243-46a2-911a-6d8a5531b220&quot;,&quot;parentUUID&quot;:&quot;347df0f2-1172-465c-ace3-7dbf5554477a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with creative commons attribution PIL&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with creative commons attribution PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerCreativeCommonsAttributionPIL({\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicyAddress: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;80f60fe1-01b5-4944-824c-acb43dda2a0d&quot;,&quot;parentUUID&quot;:&quot;347df0f2-1172-465c-ace3-7dbf5554477a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;11adcf2f-6b27-441e-9a03-a23f3ad992e9&quot;,&quot;7a060803-0cc1-4037-b52c-69f6cc269c6f&quot;,&quot;8578804d-4309-4ff9-b908-4cf5b725bfc6&quot;,&quot;af2c5d98-2243-46a2-911a-6d8a5531b220&quot;,&quot;80f60fe1-01b5-4944-824c-acb43dda2a0d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:182,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;f23a9802-8c75-4695-8675-31d6c923e03d&quot;,&quot;title&quot;:&quot;attach License Terms and mint license tokens&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;attach License Terms and mint license tokens\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens \&quot;before all\&quot; hook in \&quot;attach License Terms and mint license tokens\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8949,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;tokenId = await (0, util_1.getTokenId)();\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nconst mockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\nawait mockERC20.approve(generated_1.licensingModuleAddress[util_1.aeneid], viem_1.maxUint256);\nipId = registerResult.ipId;\nconst registerLicenseResult = await client.license.registerCommercialRemixPIL({\n    defaultMintingFee: 0,\n    commercialRevShare: 100,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\nlicenseId = registerLicenseResult.licenseTermsId;\nconst paidLicenseResult = await client.license.registerCommercialRemixPIL({\n    defaultMintingFee: 100n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\npaidLicenseId = paidLicenseResult.licenseTermsId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7b3000bb-4748-4f36-89ad-3683da844a5a&quot;,&quot;parentUUID&quot;:&quot;f23a9802-8c75-4695-8675-31d6c923e03d&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should attach License Terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should attach License Terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8466,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;210d2f3c-3aef-428b-9bde-7d9f593758d1&quot;,&quot;parentUUID&quot;:&quot;f23a9802-8c75-4695-8675-31d6c923e03d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should be able to attach another license terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should be able to attach another license terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4400,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: paidLicenseId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3f940c0e-455d-4ba2-a941-50198779cc43&quot;,&quot;parentUUID&quot;:&quot;f23a9802-8c75-4695-8675-31d6c923e03d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license tokens with ip owner&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license tokens with ip owner&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4470,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseId,\n    licensorIpId: ipId,\n    maxMintingFee: \&quot;1\&quot;,\n    maxRevenueShare: \&quot;100\&quot;,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;456fc83b-3763-40ee-89d0-04acecb55df5&quot;,&quot;parentUUID&quot;:&quot;f23a9802-8c75-4695-8675-31d6c923e03d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license tokens with non ip owner&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license tokens with non ip owner&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17624,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// register ip with another wallet account\nconst tokenIdB = await (0, util_1.getTokenId)();\nconst registerResult = await clientB.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenIdB,\n});\nconst ipIdB = registerResult.ipId;\n// attach license terms to the ip\nawait client.license.attachLicenseTerms({\n    ipId: ipIdB,\n    licenseTermsId: licenseId,\n});\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseId,\n    licensorIpId: ipIdB,\n    maxMintingFee: \&quot;1\&quot;,\n    maxRevenueShare: \&quot;100\&quot;,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;045b717b-4e01-4c96-a022-e48749b30928&quot;,&quot;parentUUID&quot;:&quot;f23a9802-8c75-4695-8675-31d6c923e03d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license token with default license terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license token with default license terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4490,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// get default license terms id\nconst licenseRegistryReadOnlyClient = new generated_1.LicenseRegistryReadOnlyClient(util_1.publicClient);\nconst { licenseTermsId: defaultLicenseTermsId } = await licenseRegistryReadOnlyClient.getDefaultLicenseTerms();\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: defaultLicenseTermsId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 1,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;05ad2c28-f35d-4da0-8dfb-26261db6eb81&quot;,&quot;parentUUID&quot;:&quot;f23a9802-8c75-4695-8675-31d6c923e03d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license tokens with fee and pay with IP&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license tokens with fee and pay with IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4651,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const balanceBefore = await client.getWalletBalance();\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: paidLicenseId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 50,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 100n));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1f244357-c1d3-455a-94c8-26afe2a87422&quot;,&quot;parentUUID&quot;:&quot;f23a9802-8c75-4695-8675-31d6c923e03d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should get license terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should get license terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.getLicenseTerms(licenseId);\n(0, chai_1.expect)(result).to.be.an(\&quot;object\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cebbf738-7b7c-4eae-9586-dc3581f67e8d&quot;,&quot;parentUUID&quot;:&quot;f23a9802-8c75-4695-8675-31d6c923e03d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should predict minting license fee&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should predict minting license fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:92,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.predictMintingLicenseFee({\n    licenseTermsId: licenseId,\n    licensorIpId: ipId,\n    amount: 1,\n});\n(0, chai_1.expect)(result.currencyToken).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenAmount).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fb66ea4f-9a21-404e-9293-dad9eb0c6c88&quot;,&quot;parentUUID&quot;:&quot;f23a9802-8c75-4695-8675-31d6c923e03d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;b3759880-1c0c-420d-8d3a-d3c8c83cd653&quot;,&quot;title&quot;:&quot;licensing config and max license tokens&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should set licensing config&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens licensing config and max license tokens should set licensing config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8415,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.setLicensingConfig({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n    licensingConfig,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c5c66019-0417-4de6-bdfd-9e5cf9c3a938&quot;,&quot;parentUUID&quot;:&quot;b3759880-1c0c-420d-8d3a-d3c8c83cd653&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should get licensing config&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens licensing config and max license tokens should get licensing config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:34,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.getLicensingConfig({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n});\n(0, chai_1.expect)(result).to.deep.equal({\n    ...licensingConfig,\n    expectMinimumGroupRewardShare: 1 * 10 ** 6,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1522c193-81eb-4094-b272-a04af7c31acb&quot;,&quot;parentUUID&quot;:&quot;b3759880-1c0c-420d-8d3a-d3c8c83cd653&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should set max license tokens&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens licensing config and max license tokens should set max license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8795,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.setMaxLicenseTokens({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n    maxLicenseTokens: 100,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;adef4092-da1c-4626-b359-c1df217a8de5&quot;,&quot;parentUUID&quot;:&quot;b3759880-1c0c-420d-8d3a-d3c8c83cd653&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;c5c66019-0417-4de6-bdfd-9e5cf9c3a938&quot;,&quot;1522c193-81eb-4094-b272-a04af7c31acb&quot;,&quot;adef4092-da1c-4626-b359-c1df217a8de5&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:17244,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;210d2f3c-3aef-428b-9bde-7d9f593758d1&quot;,&quot;3f940c0e-455d-4ba2-a941-50198779cc43&quot;,&quot;456fc83b-3763-40ee-89d0-04acecb55df5&quot;,&quot;045b717b-4e01-4c96-a022-e48749b30928&quot;,&quot;05ad2c28-f35d-4da0-8dfb-26261db6eb81&quot;,&quot;1f244357-c1d3-455a-94c8-26afe2a87422&quot;,&quot;cebbf738-7b7c-4eae-9586-dc3581f67e8d&quot;,&quot;fb66ea4f-9a21-404e-9293-dad9eb0c6c88&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:44223,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;543d3652-d0a8-4880-9cdb-22511d9b864d&quot;,&quot;title&quot;:&quot;Creative Commons Attribution License Tests&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Creative Commons Attribution License Tests\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests \&quot;before all\&quot; hook in \&quot;Creative Commons Attribution License Tests\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8737,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;tokenId = await (0, util_1.getTokenId)();\n// Register an IP asset\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = registerResult.ipId;\n// Create a Creative Commons Attribution license\nconst ccLicenseResult = await client.license.registerCreativeCommonsAttributionPIL({\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicyAddress: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n});\nccLicenseTermsId = ccLicenseResult.licenseTermsId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;32b34d47-d695-410c-ac5c-1d718c0029b7&quot;,&quot;parentUUID&quot;:&quot;543d3652-d0a8-4880-9cdb-22511d9b864d&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should verify the license terms match Creative Commons Attribution specifications&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests should verify the license terms match Creative Commons Attribution specifications&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:33,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const licenseTerms = await client.license.getLicenseTerms(ccLicenseTermsId);\n(0, chai_1.expect)(licenseTerms.terms.transferable).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.commercialUse).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesAllowed).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesAttribution).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesReciprocal).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesApproval).to.equal(false);\n(0, chai_1.expect)(licenseTerms.terms.commercialAttribution).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.commercialRevShare).to.equal(0);\n(0, chai_1.expect)(licenseTerms.terms.defaultMintingFee).to.equal(0n);\n(0, chai_1.expect)(licenseTerms.terms.royaltyPolicy).to.equal(generated_1.royaltyPolicyLapAddress[util_1.aeneid]);\n(0, chai_1.expect)(licenseTerms.terms.expiration).to.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;df434dfa-ce05-4d45-9e22-f61d4e27e028&quot;,&quot;parentUUID&quot;:&quot;543d3652-d0a8-4880-9cdb-22511d9b864d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should attach Creative Commons Attribution license to an IP&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests should attach Creative Commons Attribution license to an IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4429,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const attachResult = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: ccLicenseTermsId,\n});\n(0, chai_1.expect)(attachResult.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(attachResult.success).to.equal(true);\nconst licenseRegistryReadOnlyClient = new generated_1.LicenseRegistryReadOnlyClient(util_1.publicClient);\nconst hasLicense = await licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({\n    ipId: ipId,\n    licenseTemplate: client.ipAsset.licenseTemplateClient.address,\n    licenseTermsId: ccLicenseTermsId,\n});\n(0, chai_1.expect)(hasLicense).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d8896865-c674-48b2-a8d2-b40c4cb6d9bb&quot;,&quot;parentUUID&quot;:&quot;543d3652-d0a8-4880-9cdb-22511d9b864d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint CC-BY license tokens with no minting fee&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests should mint CC-BY license tokens with no minting fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8645,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Get wallet balance before minting\nconst balanceBefore = await client.getWalletBalance();\n// Predict the minting fee (should be zero for CC-BY)\nconst feePredict = await client.license.predictMintingLicenseFee({\n    licenseTermsId: ccLicenseTermsId,\n    licensorIpId: ipId,\n    amount: 1,\n});\n// CC-BY licenses should have zero minting fee\n(0, chai_1.expect)(feePredict.tokenAmount).to.equal(0n);\nconst mintResult = await client.license.mintLicenseTokens({\n    licenseTermsId: ccLicenseTermsId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 0,\n});\n(0, chai_1.expect)(mintResult.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(mintResult.licenseTokenIds).to.be.a(\&quot;array\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n// Verify no fee was charged just gas\n// This checks that any difference is very small (just gas costs)\nconst balanceDiff = balanceBefore - balanceAfter;\nconst gasUsed = mintResult.receipt.gasUsed;\nconst effectiveGasPrice = mintResult.receipt.effectiveGasPrice;\nconst totalGas = gasUsed * effectiveGasPrice;\n// Confirms the balance diff only reflects gas cost, since license fee is zero.\n(0, chai_1.expect)(balanceDiff).to.equal(totalGas); // Small amount for gas&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d5c6e489-87ca-417a-9093-979a1ffbcc3b&quot;,&quot;parentUUID&quot;:&quot;543d3652-d0a8-4880-9cdb-22511d9b864d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;df434dfa-ce05-4d45-9e22-f61d4e27e028&quot;,&quot;d8896865-c674-48b2-a8d2-b40c4cb6d9bb&quot;,&quot;d5c6e489-87ca-417a-9093-979a1ffbcc3b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13107,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;5617dd1a-86a9-4141-91f5-29e34f934ce4&quot;,&quot;title&quot;:&quot;nftClient Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;nftClient Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions \&quot;before all\&quot; hook in \&quot;nftClient Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;14b37b83-1b91-4be6-9341-6ecdef626875&quot;,&quot;parentUUID&quot;:&quot;5617dd1a-86a9-4141-91f5-29e34f934ce4&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;da3956af-5d80-41f3-8c7d-8abe663fd179&quot;,&quot;title&quot;:&quot;createNFTCollection&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully create public nft collection with minimal params&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create public nft collection with minimal params&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4312,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(txData.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4bca83e2-006c-4928-af3c-0a58f69e7ec9&quot;,&quot;parentUUID&quot;:&quot;da3956af-5d80-41f3-8c7d-8abe663fd179&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create collection with custom mint fee&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create collection with custom mint fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4312,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;paid-collection\&quot;,\n    symbol: \&quot;PAID\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 10000000n,\n    mintFeeToken: generated_1.erc20Address[mockData_1.aeneid],\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);\nspgNftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5e875dfd-3454-4a4d-a18b-5fd8b9c5548e&quot;,&quot;parentUUID&quot;:&quot;da3956af-5d80-41f3-8c7d-8abe663fd179&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create private collection&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create private collection&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4326,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;private-collection\&quot;,\n    symbol: \&quot;PRIV\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false, // private minting\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: false, // starts closed\n    contractURI: \&quot;test-uri\&quot;,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;40e4b5ad-4cc1-4cd7-b934-ec498cccabca&quot;,&quot;parentUUID&quot;:&quot;da3956af-5d80-41f3-8c7d-8abe663fd179&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create collection with baseURI&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create collection with baseURI&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4342,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;uri-collection\&quot;,\n    symbol: \&quot;URI\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    baseURI: \&quot;ipfs://QmTest/\&quot;,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5911f557-e1d9-4e12-8f90-ec134fc5bc1b&quot;,&quot;parentUUID&quot;:&quot;da3956af-5d80-41f3-8c7d-8abe663fd179&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create collection with custom owner&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create collection with custom owner&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4331,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;owned-collection\&quot;,\n    symbol: \&quot;OWN\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    owner: util_1.TEST_WALLET_ADDRESS,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a4ae57c7-7090-4eb8-9c00-afdf8cb0fd99&quot;,&quot;parentUUID&quot;:&quot;da3956af-5d80-41f3-8c7d-8abe663fd179&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully get encoded transaction data&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully get encoded transaction data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;encoded-collection\&quot;,\n    symbol: \&quot;ENC\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    txOptions: {\n        encodedTxDataOnly: true,\n    },\n});\n(0, chai_1.expect)(txData.encodedTxData).to.be.an(\&quot;object\&quot;);\n(0, chai_1.expect)(txData.encodedTxData?.data).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(txData.encodedTxData?.to).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e4b2b6ad-0937-46cc-8753-f40545ca9db6&quot;,&quot;parentUUID&quot;:&quot;da3956af-5d80-41f3-8c7d-8abe663fd179&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid mint fee token&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should fail with invalid mint fee token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.nftClient.createNFTCollection({\n    name: \&quot;invalid-fee-collection\&quot;,\n    symbol: \&quot;INV\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 1000000000000000000n,\n    mintFeeToken: \&quot;0x0000000000000000000000000000000000000000\&quot;,\n})).to.be.rejectedWith(\&quot;Invalid mint fee token address\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ff3eb753-0005-415b-b009-ee93e2833511&quot;,&quot;parentUUID&quot;:&quot;da3956af-5d80-41f3-8c7d-8abe663fd179&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;4bca83e2-006c-4928-af3c-0a58f69e7ec9&quot;,&quot;5e875dfd-3454-4a4d-a18b-5fd8b9c5548e&quot;,&quot;40e4b5ad-4cc1-4cd7-b934-ec498cccabca&quot;,&quot;5911f557-e1d9-4e12-8f90-ec134fc5bc1b&quot;,&quot;a4ae57c7-7090-4eb8-9c00-afdf8cb0fd99&quot;,&quot;e4b2b6ad-0937-46cc-8753-f40545ca9db6&quot;,&quot;ff3eb753-0005-415b-b009-ee93e2833511&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:21626,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;3ad1c107-6207-4d98-a753-95c61450284a&quot;,&quot;title&quot;:&quot;Mint Fee&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully get mint fee token&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions Mint Fee should successfully get mint fee token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:33,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintFeeToken = await client.nftClient.getMintFeeToken(spgNftContract);\n(0, chai_1.expect)(mintFeeToken).to.equal(generated_1.erc20Address[mockData_1.aeneid]);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3bee8d74-0412-4dc4-bfb3-954c550efbf4&quot;,&quot;parentUUID&quot;:&quot;3ad1c107-6207-4d98-a753-95c61450284a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully get mint fee&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions Mint Fee should successfully get mint fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintFee = await client.nftClient.getMintFee(spgNftContract);\n(0, chai_1.expect)(mintFee).to.equal(10000000n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fdb2a76b-99fe-4fdf-afc6-d668dd8da2d9&quot;,&quot;parentUUID&quot;:&quot;3ad1c107-6207-4d98-a753-95c61450284a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;3bee8d74-0412-4dc4-bfb3-954c550efbf4&quot;,&quot;fdb2a76b-99fe-4fdf-afc6-d668dd8da2d9&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:63,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;9500d70b-9d24-4951-9af5-7cdd1cd286a0&quot;,&quot;title&quot;:&quot;set and get tokenURI&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully set token URI&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions set and get tokenURI should successfully set token URI&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12971,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Setup: Approve the contract for ERC20 transfers\nconst erc20Client = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[mockData_1.aeneid]);\nconst txHash = await erc20Client.approve(spgNftContract, viem_1.maxUint256);\nawait util_1.publicClient.waitForTransactionReceipt({ hash: txHash });\n// Mint a new token with initial metadata\nconst tokenId = await (0, util_1.mintBySpg)(spgNftContract, \&quot;ipfs://QmTest/\&quot;);\n(0, chai_1.expect)(tokenId).to.be.a(\&quot;bigint\&quot;);\n// Update the token URI\nconst updatedMetadata = \&quot;ipfs://QmUpdated/metadata.json\&quot;;\nconst result = await client.nftClient.setTokenURI({\n    tokenId: tokenId,\n    tokenURI: updatedMetadata,\n    spgNftContract,\n});\n// Verify the transaction\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n// Verification that the URI was updated\nconst tokenURI = await client.nftClient.getTokenURI({\n    tokenId,\n    spgNftContract,\n});\n(0, chai_1.expect)(tokenURI).to.equal(updatedMetadata);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5a8657f0-7ded-4e03-b3da-8f22f55e898b&quot;,&quot;parentUUID&quot;:&quot;9500d70b-9d24-4951-9af5-7cdd1cd286a0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;5a8657f0-7ded-4e03-b3da-8f22f55e898b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:12971,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;26d70e59-ab77-47c8-ac1b-cf09748f4069&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;fails with invalid token ID&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions Error Cases fails with invalid token ID&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4341,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const erc20Client = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[mockData_1.aeneid]);\nconst txHash = await erc20Client.approve(spgNftContract, viem_1.maxUint256);\nawait util_1.publicClient.waitForTransactionReceipt({ hash: txHash });\nconst invalidTokenId = 999999999999999n;\nconst updatedMetadata = \&quot;ipfs://QmUpdated/metadata.json\&quot;;\nawait (0, chai_1.expect)(client.nftClient.setTokenURI({\n    tokenId: invalidTokenId,\n    tokenURI: updatedMetadata,\n    spgNftContract,\n})).to.be.rejectedWith(\&quot;Failed to set token URI\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9a5ed69c-2db8-4d6e-ad06-6ac32a182bf7&quot;,&quot;parentUUID&quot;:&quot;26d70e59-ab77-47c8-ac1b-cf09748f4069&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;9a5ed69c-2db8-4d6e-ad06-6ac32a182bf7&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4341,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;2abb7eb5-838b-4e9b-b534-006f84bad435&quot;,&quot;title&quot;:&quot;Permission Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Permission Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Permission Functions \&quot;before all\&quot; hook in \&quot;Permission Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8733,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = response.ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f36fda8e-a152-4e84-977f-4a7f3a23714d&quot;,&quot;parentUUID&quot;:&quot;2abb7eb5-838b-4e9b-b534-006f84bad435&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;5fafca9a-385e-4ffe-bd78-15f43f285f6e&quot;,&quot;title&quot;:&quot;Single Permission Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should set permission successfully&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Single Permission Operations should set permission successfully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4370,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.setPermission({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n    func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;db69dc2e-96c1-4d1b-83d6-d99aa164ad59&quot;,&quot;parentUUID&quot;:&quot;5fafca9a-385e-4ffe-bd78-15f43f285f6e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should set all permissions successfully&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Single Permission Operations should set all permissions successfully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4330,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.setAllPermissions({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    permission: permission_1.AccessPermission.ALLOW,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a17a0bc7-7210-4e5b-8130-443d2966187b&quot;,&quot;parentUUID&quot;:&quot;5fafca9a-385e-4ffe-bd78-15f43f285f6e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;db69dc2e-96c1-4d1b-83d6-d99aa164ad59&quot;,&quot;a17a0bc7-7210-4e5b-8130-443d2966187b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:8700,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;f0cb9130-eb71-42af-a399-775cf6965b8f&quot;,&quot;title&quot;:&quot;Permission Signatures&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should create set permission signature&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Permission Signatures should create set permission signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4413,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.createSetPermissionSignature({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n    permission: permission_1.AccessPermission.ALLOW,\n    deadline: 60000n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;32920276-804a-417c-9ca4-09dcf772b334&quot;,&quot;parentUUID&quot;:&quot;f0cb9130-eb71-42af-a399-775cf6965b8f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;32920276-804a-417c-9ca4-09dcf772b334&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4413,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;99c15263-95c2-4160-a03e-ef079aab8560&quot;,&quot;title&quot;:&quot;Batch Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should set batch permissions successfully&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Batch Operations should set batch permissions successfully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4377,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.setBatchPermissions({\n    permissions: [\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.ALLOW,\n            func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n        },\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.DENY,\n            func: \&quot;function freezeMetadata(address)\&quot;,\n        },\n    ],\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0066d2a8-2f4a-4343-90e8-c319f4700f38&quot;,&quot;parentUUID&quot;:&quot;99c15263-95c2-4160-a03e-ef079aab8560&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should create batch permission signature&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Batch Operations should create batch permission signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4448,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.createBatchPermissionSignature({\n    ipId: ipId,\n    permissions: [\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.ALLOW,\n            func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n        },\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.DENY,\n            func: \&quot;function freezeMetadata(address)\&quot;,\n        },\n    ],\n    deadline: 60000n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1f66fb56-9c4a-4452-9ff1-fc38128c9368&quot;,&quot;parentUUID&quot;:&quot;99c15263-95c2-4160-a03e-ef079aab8560&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;0066d2a8-2f4a-4343-90e8-c319f4700f38&quot;,&quot;1f66fb56-9c4a-4452-9ff1-fc38128c9368&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:8825,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;fefd7c12-7be4-4dc0-b945-1d7e61f3dda9&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should fail when setting permission for unregistered IP&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Error Cases should fail when setting permission for unregistered IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:32,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const unregisteredIpId = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nawait (0, chai_1.expect)(client.permission.setPermission({\n    ipId: unregisteredIpId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n})).to.be.rejectedWith(`IP id with ${unregisteredIpId} is not registered.`);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e6d5980d-089c-4c7c-94db-ebb40418d1d0&quot;,&quot;parentUUID&quot;:&quot;fefd7c12-7be4-4dc0-b945-1d7e61f3dda9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid function signature&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Error Cases should fail with invalid function signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:33,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.permission.setPermission({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n    func: \&quot;invalid_function_signature\&quot;,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2c7f5a51-409b-4a32-a7a6-090ee4f76947&quot;,&quot;parentUUID&quot;:&quot;fefd7c12-7be4-4dc0-b945-1d7e61f3dda9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;e6d5980d-089c-4c7c-94db-ebb40418d1d0&quot;,&quot;2c7f5a51-409b-4a32-a7a6-090ee4f76947&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:65,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;86bb7f81-bf3e-4f08-acb7-0453db76f821&quot;,&quot;title&quot;:&quot;Royalty Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Royalty Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions \&quot;before all\&quot; hook in \&quot;Royalty Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:31219,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nmockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\n// Setup initial state\nparentIpId = await getIpId();\nchildIpId = await getIpId();\nlicenseTermsId = await getCommercialPolicyId();\n// Setup relationships and approvals\nawait attachLicenseTerms(parentIpId, licenseTermsId);\nawait mockERC20.mint(util_1.TEST_WALLET_ADDRESS, (0, viem_1.parseEther)(\&quot;10\&quot;));\nawait mockERC20.approve(generated_1.royaltyModuleAddress[util_1.aeneid], viem_1.maxUint256);\n// Register derivative\nawait client.ipAsset.registerDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [licenseTermsId],\n    maxMintingFee: \&quot;0\&quot;,\n    maxRts: \&quot;0\&quot;,\n    maxRevenueShare: \&quot;0\&quot;,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4bf26aa4-9585-491e-b73b-ece4d80625f8&quot;,&quot;parentUUID&quot;:&quot;86bb7f81-bf3e-4f08-acb7-0453db76f821&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;308e4c93-e8da-49bb-9cc8-e60e5853e61a&quot;,&quot;title&quot;:&quot;Royalty Payments&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully pay royalty on behalf&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should successfully pay royalty on behalf&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4521,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: parentIpId,\n    payerIpId: childIpId,\n    token: generated_1.erc20Address[util_1.aeneid],\n    amount: 1,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;553f4424-6473-4bb1-baef-8d18f211c410&quot;,&quot;parentUUID&quot;:&quot;308e4c93-e8da-49bb-9cc8-e60e5853e61a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto convert IP to WIP when paying WIP on behalf&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should auto convert IP to WIP when paying WIP on behalf&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4664,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const balanceBefore = await client.getWalletBalance();\nconst response = await client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: parentIpId,\n    payerIpId: childIpId,\n    token: common_1.WIP_TOKEN_ADDRESS,\n    amount: 100n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 100n));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;67a517b2-99d3-41c8-a9b3-3656ecea73c1&quot;,&quot;parentUUID&quot;:&quot;308e4c93-e8da-49bb-9cc8-e60e5853e61a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail to pay royalty with unregistered receiver&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should fail to pay royalty with unregistered receiver&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:47,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const unregisteredIpId = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nawait (0, chai_1.expect)(client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: unregisteredIpId,\n    payerIpId: childIpId,\n    token: generated_1.erc20Address[util_1.aeneid],\n    amount: 10 * 10 ** 2,\n})).to.be.rejectedWith(`The receiver IP with id ${unregisteredIpId} is not registered.`);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;89853447-b8d3-43ea-9b93-135239ee3427&quot;,&quot;parentUUID&quot;:&quot;308e4c93-e8da-49bb-9cc8-e60e5853e61a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow the royalty vault to transfer its native tokens to a wallet address&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should allow the royalty vault to transfer its native tokens to a wallet address&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4730,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const royaltyVaultAddress = await client.royalty.getRoyaltyVaultAddress(parentIpId);\nconst royaltyVaultToken = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, royaltyVaultAddress);\nconst transferAmount = BigInt(10 * 10 ** 6); // 10 million tokens\n// Check initial balances of the vault token\nconst initialTargetBalance = await royaltyVaultToken.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst initialParentBalance = await royaltyVaultToken.balanceOf(parentIpId);\n(0, chai_1.expect)(Number(initialParentBalance)).greaterThanOrEqual(Number(transferAmount));\nconst transferResult = await client.ipAccount.execute({\n    to: royaltyVaultAddress,\n    value: 0,\n    ipId: parentIpId,\n    data: (0, viem_1.encodeFunctionData)({\n        abi: viem_1.erc20Abi,\n        functionName: \&quot;transfer\&quot;,\n        args: [util_1.TEST_WALLET_ADDRESS, transferAmount],\n    }),\n});\n(0, chai_1.expect)(transferResult.txHash).to.be.a(\&quot;string\&quot;);\n// Check final balances to confirm the transfer worked\nconst finalTargetBalance = await royaltyVaultToken.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst finalParentBalance = await royaltyVaultToken.balanceOf(parentIpId);\n(0, chai_1.expect)(finalTargetBalance).to.equal(initialTargetBalance + transferAmount, \&quot;Target wallet balance should increase by the transfer amount\&quot;);\n(0, chai_1.expect)(Number(finalParentBalance)).equal(Number(initialParentBalance - transferAmount));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;db71a49c-7b8e-4979-9425-81c6cba815f7&quot;,&quot;parentUUID&quot;:&quot;308e4c93-e8da-49bb-9cc8-e60e5853e61a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;553f4424-6473-4bb1-baef-8d18f211c410&quot;,&quot;67a517b2-99d3-41c8-a9b3-3656ecea73c1&quot;,&quot;89853447-b8d3-43ea-9b93-135239ee3427&quot;,&quot;db71a49c-7b8e-4979-9425-81c6cba815f7&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13962,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;f02f2772-bed9-494e-b0cc-b545e8865fe1&quot;,&quot;title&quot;:&quot;Revenue Queries&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should return claimable revenue amount&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Revenue Queries should return claimable revenue amount&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:133,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.royalty.claimableRevenue({\n    ipId: parentIpId,\n    claimer: util_1.TEST_WALLET_ADDRESS,\n    token: generated_1.erc20Address[util_1.aeneid],\n});\n(0, chai_1.expect)(response).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a508ca53-7c98-402a-a22f-647ef61bb639&quot;,&quot;parentUUID&quot;:&quot;f02f2772-bed9-494e-b0cc-b545e8865fe1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail to get royalty vault address for unregistered IP&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Revenue Queries should fail to get royalty vault address for unregistered IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:36,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const unregisteredIpId = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nawait (0, chai_1.expect)(client.royalty.getRoyaltyVaultAddress(unregisteredIpId)).to.be.rejectedWith(`The royalty vault IP with id ${unregisteredIpId} is not registered.`);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b24fb361-8c28-4a3d-aa53-eef7e3686afb&quot;,&quot;parentUUID&quot;:&quot;f02f2772-bed9-494e-b0cc-b545e8865fe1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a508ca53-7c98-402a-a22f-647ef61bb639&quot;,&quot;b24fb361-8c28-4a3d-aa53-eef7e3686afb&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:169,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;83fa0757-d475-4668-8a0f-8f7a5ee381a4&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should return zero for claimable revenue with invalid token&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Error Cases should return zero for claimable revenue with invalid token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:102,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.royalty.claimableRevenue({\n    ipId: parentIpId,\n    claimer: util_1.TEST_WALLET_ADDRESS,\n    token: \&quot;0x0000000000000000000000000000000000000000\&quot;,\n});\n(0, chai_1.expect)(response).to.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1a0311e9-5fb3-4117-a595-70668e0f7246&quot;,&quot;parentUUID&quot;:&quot;83fa0757-d475-4668-8a0f-8f7a5ee381a4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1a0311e9-5fb3-4117-a595-70668e0f7246&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:102,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;228739ef-d9c1-4f68-ad0b-8895d11f69d0&quot;,&quot;title&quot;:&quot;ClaimAllRevenue With WIP&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;ClaimAllRevenue With WIP\&quot;&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions ClaimAllRevenue With WIP \&quot;before all\&quot; hook in \&quot;ClaimAllRevenue With WIP\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:23657,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// set up\n// minting Fee: 100, 10% LAP rev share, A expect to get 120 WIP\n// A -&gt; B -&gt; C -&gt; D\nconst txData = await client.nftClient.createNFTCollection({\n    name: \&quot;free-collection\&quot;,\n    symbol: \&quot;FREE\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: viem_1.zeroAddress,\n});\nspgNftContract = txData.spgNftContract;\nconst retA = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 100n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 100n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nipA = retA.ipId;\nlicenseId = retA.licenseTermsIds[0];\nconst retB = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipA],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\nipB = retB.ipId;\nconst retC = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipB],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\nipC = retC.ipId;\nawait client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipC],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fdb56851-19eb-4b99-965e-2c6a93ff9cd0&quot;,&quot;parentUUID&quot;:&quot;228739ef-d9c1-4f68-ad0b-8895d11f69d0&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should claim all revenue&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions ClaimAllRevenue With WIP should claim all revenue&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13136,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const ret = await client.royalty.claimAllRevenue({\n    ancestorIpId: ipA,\n    claimer: ipA,\n    childIpIds: [ipB, ipC],\n    royaltyPolicies: [generated_1.royaltyPolicyLapAddress[util_1.aeneid], generated_1.royaltyPolicyLapAddress[util_1.aeneid]],\n    currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n});\n(0, chai_1.expect)(ret.txHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(ret.claimedTokens[0].amount).to.equal(120n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f30f9bb0-0e83-4d6f-9825-e4d93d977ad4&quot;,&quot;parentUUID&quot;:&quot;228739ef-d9c1-4f68-ad0b-8895d11f69d0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;f30f9bb0-0e83-4d6f-9825-e4d93d977ad4&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13136,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;a884a88d-72d2-4ece-9d92-a4a0dbcdb127&quot;,&quot;title&quot;:&quot;BatchClaimAllRevenue With WIP&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;BatchClaimAllRevenue With WIP\&quot;&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions BatchClaimAllRevenue With WIP \&quot;before all\&quot; hook in \&quot;BatchClaimAllRevenue With WIP\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:50284,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nanotherAddress = derivedClient.address;\nawait client.wipClient.deposit({\n    amount: (0, viem_1.parseEther)(\&quot;5\&quot;),\n});\n/**\n * Asset Hierarchy Setup for Revenue Collection Tests\n *\n * Overview:\n * This test setup creates two distinct IP asset hierarchies (IpA and IpB) to demonstrate\n * different revenue collection scenarios using LAP (Licensing Agreement Policy) and LRP\n * (Licensing Revenue Policy) respectively.\n *\n * IpA Hierarchy (LAP - Licensing Agreement Policy):                           IpB Hierarchy (LRP - Licensing Revenue Policy):\n * ┌─────────────────────────────────────────────────────────────┐          ┌─────────────────────────────────────────────────────────────┐\n * │ IpA (Parent) - Total Expected Revenue: 130 WIP              │          │ IpB (Parent) - Total Expected Revenue: 330 WIP              │\n * ├─────────────────────────────────────────────────────────────┤          ├─────────────────────────────────────────────────────────────┤\n * │ Revenue Sources:                                            │          │ Revenue Sources:                                            │\n * │ ├── Minting Fee: 100 WIP                                    │          │ ├── Minting Fee: 150 WIP                                    │\n * │ ├── Revenue Share (ipA2-&gt;ipA1): 10 WIP (10% LAP)            │          │ ├── LRP Revenue Share: 10%                                  │\n * │ ├── Revenue Share (ipA3-&gt;ipA2): 10 WIP (10% LAP)            │          │ ├── Total Revenue: 330 WIP                                  │\n * │ └── Direct Payment (ipA3): 10 WIP (10% LAP)                 │          │    └── From ipB1: 150 WIP + 10% revenue share               │\n * │                                                             │          │    └── From ipB2: 150 WIP + 10% revenue share               │\n * │                                                             │          │                                                             │\n * | Ownership Distribution:                                     │          |                                                             │\n * │ ├── Wallet Address: 50%  65 WIP                             │          │ Revenue Flow:                                               │\n * │ └── Another Address: 50% 65 WIP                             │          │ ipB3                                                        │\n * │                                                             │          │ ├── ipB1 ─┐                                                 │\n * │ Revenue Flow:                                               │          │ └── ipB2 ─┴──&gt; ipB (collects 330 WIP)                       │\n * │ ipA3                                                        │          │                                                             │\n * │  └──&gt; ipA2 (20% LAP) ──&gt; ipA1 (10% LAP) ──&gt; ipA             │          │                                                             │\n * │       └──&gt; Direct Payment: 100 WIP                          │          │                                                             │\n * └─────────────────────────────────────────────────────────────┘          └─────────────────────────────────────────────────────────────┘\n */\nconst txData = await client.nftClient.createNFTCollection({\n    name: \&quot;free-collection\&quot;,\n    symbol: \&quot;FREE\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: viem_1.zeroAddress,\n});\nspgNftContract = txData.spgNftContract;\n// 1. Register ipA\nconst ret1A = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 100n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 100n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 50,\n        },\n        {\n            recipient: anotherAddress,\n            percentage: 50,\n        },\n    ],\n});\nipA = ret1A.ipId;\nlicenseId = ret1A.licenseTermsIds[0];\n// 2. Register ipB\nconst ret1B = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n                defaultMintingFee: 150n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 150n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nipB = ret1B.ipId;\nlicenseId1 = ret1B.licenseTermsIds[0];\n// 3. Register ipA1 from ipA and ipB1 from ipB\nconst { results: ret2 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB],\n                licenseTermsIds: [licenseId1],\n            },\n        },\n    ],\n});\nipA1 = ret2[0].ipId;\nipB1 = ret2[1].ipId;\n// 4. Register ipA2 from ipA1 and ipB2 from ipB\nconst { results: ret3 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA1],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB],\n                licenseTermsIds: [licenseId1],\n            },\n        },\n    ],\n});\nipA2 = ret3[0].ipId;\nipB2 = ret3[1].ipId;\n// 5. Register ipA3 from ipA2 and ipB3 from ipB1 and ipB2\nconst { results: ret4 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA2],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB1, ipB2],\n                licenseTermsIds: [licenseId1, licenseId1],\n            },\n        },\n    ],\n});\nipA3 = ret4[0].ipId;\n// 6. Pay royalty on behalf of ipA2 to ipA3\nawait client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: ipA2,\n    payerIpId: ipA3,\n    token: common_1.WIP_TOKEN_ADDRESS,\n    amount: 100n,\n});\nconst balance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nawait client.wipClient.withdraw({\n    amount: balance,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fddbd3e1-8c78-484e-a470-f7a003b5ace1&quot;,&quot;parentUUID&quot;:&quot;a884a88d-72d2-4ece-9d92-a4a0dbcdb127&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should batch claim all revenue&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions BatchClaimAllRevenue With WIP should batch claim all revenue&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13343,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const anotherAddressWipBalanceBefore = await client.wipClient.balanceOf(anotherAddress);\nconst result = await client.royalty.batchClaimAllRevenue({\n    ancestorIps: [\n        {\n            ipId: ipA,\n            claimer: util_1.TEST_WALLET_ADDRESS,\n            childIpIds: [ipA1, ipA2],\n            royaltyPolicies: [generated_1.royaltyPolicyLapAddress[util_1.aeneid], generated_1.royaltyPolicyLapAddress[util_1.aeneid]],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n        },\n        {\n            ipId: ipA,\n            claimer: anotherAddress,\n            childIpIds: [],\n            royaltyPolicies: [],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS],\n        },\n        {\n            ipId: ipB,\n            claimer: ipB,\n            childIpIds: [ipB1, ipB2],\n            royaltyPolicies: [generated_1.royaltyPolicyLrpAddress[util_1.aeneid], generated_1.royaltyPolicyLrpAddress[util_1.aeneid]],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n        },\n    ],\n});\nconst anotherAddressWipBalanceAfter = await client.wipClient.balanceOf(anotherAddress);\nconst walletWipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(result.txHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.claimedTokens[0].amount).to.equal(65n);\n(0, chai_1.expect)(result.claimedTokens[1].amount).to.equal(65n);\n(0, chai_1.expect)(result.claimedTokens[2].amount).to.equal(330n);\n(0, chai_1.expect)(walletWipBalanceAfter).to.equal(0n);\n(0, chai_1.expect)(anotherAddressWipBalanceAfter).to.equal(anotherAddressWipBalanceBefore + 65n);\n// Note: The final wallet balance cannot be precisely calculated because:\n// The test involves multiple transactions (claimAllRevenue, token transfers, etc.)\n// batchClaimAllRevenue only returns receipts for claimAllRevenue calls\n// Additional gas costs and token transfers occur outside the returned receipts&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4106b203-73b7-40c4-93cd-fd81399b0fc3&quot;,&quot;parentUUID&quot;:&quot;a884a88d-72d2-4ece-9d92-a4a0dbcdb127&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;4106b203-73b7-40c4-93cd-fd81399b0fc3&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13343,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;34e07fca-db91-4da7-a787-3db3ebbe0963&quot;,&quot;title&quot;:&quot;WIP Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;WIP Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;WIP Functions \&quot;before all\&quot; hook in \&quot;WIP Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8a8016b6-9dc9-42e4-8e58-ea34c60654f1&quot;,&quot;parentUUID&quot;:&quot;34e07fca-db91-4da7-a787-3db3ebbe0963&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;a26accff-b8ef-4bff-af6e-64c7fd0a0389&quot;,&quot;title&quot;:&quot;deposit&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should deposit 0.01 WIP&quot;,&quot;fullTitle&quot;:&quot;WIP Functions deposit should deposit 0.01 WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4484,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const ipAmt = (0, viem_1.parseEther)(\&quot;0.01\&quot;);\nconst balanceBefore = await client.getWalletBalance();\nconst wipBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst rsp = await client.wipClient.deposit({\n    amount: ipAmt,\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.equal(wipBefore + ipAmt);\nconst gasCost = rsp.receipt.gasUsed * rsp.receipt.effectiveGasPrice;\n(0, chai_1.expect)(balanceAfter).to.equal(balanceBefore - ipAmt - gasCost);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ce8cbae1-dfc8-428b-98ed-6cb9a09685b1&quot;,&quot;parentUUID&quot;:&quot;a26accff-b8ef-4bff-af6e-64c7fd0a0389&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;ce8cbae1-dfc8-428b-98ed-6cb9a09685b1&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4484,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;31dbd33d-f74b-439e-b056-df9b231ce303&quot;,&quot;title&quot;:&quot;transfer&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should transfer WIP&quot;,&quot;fullTitle&quot;:&quot;WIP Functions transfer should transfer WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4379,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const rsp = await client.wipClient.transfer({\n    to: util_1.TEST_WALLET_ADDRESS,\n    amount: (0, viem_1.parseEther)(\&quot;0.01\&quot;),\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n//Due to approve cannot approve msy.sender, so skip transferFrom test&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;96ae7bb0-db98-421a-8442-b1b9aec53d63&quot;,&quot;parentUUID&quot;:&quot;31dbd33d-f74b-439e-b056-df9b231ce303&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;96ae7bb0-db98-421a-8442-b1b9aec53d63&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4379,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;56310545-8989-473c-becd-e280efbbf3dd&quot;,&quot;title&quot;:&quot;withdraw&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should withdrawal WIP&quot;,&quot;fullTitle&quot;:&quot;WIP Functions withdraw should withdrawal WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4474,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const balanceBefore = await client.getWalletBalance();\nconst wipBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst rsp = await client.wipClient.withdraw({\n    amount: wipBefore,\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.equal(0n);\nconst balanceAfter = await client.getWalletBalance();\nconst gasCost = rsp.receipt.gasUsed * rsp.receipt.effectiveGasPrice;\n(0, chai_1.expect)(balanceAfter).to.equal(balanceBefore + wipBefore - gasCost);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;42b764b8-69a5-4888-bca4-6f69ab6bef25&quot;,&quot;parentUUID&quot;:&quot;56310545-8989-473c-becd-e280efbbf3dd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;42b764b8-69a5-4888-bca4-6f69ab6bef25&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4474,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:300000}],&quot;meta&quot;:{&quot;mocha&quot;:{&quot;version&quot;:&quot;10.8.2&quot;},&quot;mochawesome&quot;:{&quot;options&quot;:{&quot;quiet&quot;:false,&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;saveHtml&quot;:true,&quot;saveJson&quot;:true,&quot;consoleReporter&quot;:&quot;spec&quot;,&quot;useInlineDiffs&quot;:false,&quot;code&quot;:true},&quot;version&quot;:&quot;7.1.3&quot;},&quot;marge&quot;:{&quot;version&quot;:&quot;6.2.0&quot;}}}" data-config="{&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;reportDir&quot;:&quot;mochawesome-report&quot;,&quot;reportTitle&quot;:&quot;core-sdk&quot;,&quot;reportPageTitle&quot;:&quot;Mochawesome Report&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;cdn&quot;:false,&quot;charts&quot;:false,&quot;enableCharts&quot;:false,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;showPassed&quot;:true,&quot;showFailed&quot;:true,&quot;showPending&quot;:true,&quot;showSkipped&quot;:false,&quot;showHooks&quot;:&quot;failed&quot;,&quot;saveJson&quot;:true,&quot;saveHtml&quot;:true,&quot;dev&quot;:false,&quot;assetsDir&quot;:&quot;mochawesome-report/assets&quot;,&quot;jsonFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/mochawesome-report/mochawesome.json&quot;,&quot;htmlFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/mochawesome-report/mochawesome.html&quot;}"><div id="report"></div><script src="assets/app.js"></script></body></html>