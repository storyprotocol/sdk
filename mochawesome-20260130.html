<!doctype html>
<html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Mochawesome Report</title><link rel="stylesheet" href="assets/app.css"/></head><body data-raw="{&quot;stats&quot;:{&quot;suites&quot;:53,&quot;tests&quot;:160,&quot;passes&quot;:160,&quot;pending&quot;:0,&quot;failures&quot;:0,&quot;start&quot;:&quot;2026-01-30T08:48:05.622Z&quot;,&quot;end&quot;:&quot;2026-01-30T09:29:37.855Z&quot;,&quot;duration&quot;:2492233,&quot;testsRegistered&quot;:160,&quot;passPercent&quot;:100,&quot;pendingPercent&quot;:0,&quot;other&quot;:0,&quot;hasOther&quot;:false,&quot;skipped&quot;:0,&quot;hasSkipped&quot;:false},&quot;results&quot;:[{&quot;uuid&quot;:&quot;6ace6973-1f9b-45aa-a2c3-9b8b5e08edd4&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;bd3c3765-3385-4c34-81a5-941b175e4f3e&quot;,&quot;title&quot;:&quot;Dispute Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/dispute.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Dispute Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions \&quot;before all\&quot; hook in \&quot;Dispute Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9036,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;clientA = (0, util_1.getStoryClient)();\nconst derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nclientB = derivedClient.clientB;\nminimumBond = await (0, oov3_1.getMinimumBond)(util_1.publicClient, new generated_1.ArbitrationPolicyUmaClient(util_1.publicClient, util_1.walletClient), src_1.WIP_TOKEN_ADDRESS);\nconst txData = await clientA.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nconst nftContract = txData.spgNftContract;\nipIdB = (await clientB.ipAsset.mintAndRegisterIp({\n    spgNftContract: nftContract,\n})).ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b3e49b04-2abe-4dfc-8697-0b74f37ca863&quot;,&quot;parentUUID&quot;:&quot;bd3c3765-3385-4c34-81a5-941b175e4f3e&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;it should not cancel a dispute (yet)&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions it should not cancel a dispute (yet)&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9045,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const raiseResponse = await clientA.dispute.raiseDispute({\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 2592000,\n    bond: minimumBond,\n});\nawait (0, chai_1.expect)(clientA.dispute.cancelDispute({\n    disputeId: raiseResponse.disputeId,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a47a47a3-368a-4a40-a02b-81db06493649&quot;,&quot;parentUUID&quot;:&quot;bd3c3765-3385-4c34-81a5-941b175e4f3e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;4cbe703e-0cd1-4376-ae41-fb0bce69076b&quot;,&quot;title&quot;:&quot;raiseDispute and counter dispute&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/dispute.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should raise a dispute&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should raise a dispute&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9020,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const raiseDisputeRequest = {\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 2592000,\n    bond: minimumBond,\n};\nconst response = await clientA.dispute.raiseDispute(raiseDisputeRequest);\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.disputeId).to.be.a(\&quot;bigint\&quot;);\ndisputeId = response.disputeId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4bd6d9e3-5cc5-4a8d-97d4-3fe52dd0b2cb&quot;,&quot;parentUUID&quot;:&quot;4cbe703e-0cd1-4376-ae41-fb0bce69076b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should raise disputes with different DisputeTargetTag enum values&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should raise disputes with different DisputeTargetTag enum values&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:36068,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const allTags = Object.values(src_1.DisputeTargetTag);\nfor (const tag of allTags) {\n    const raiseDisputeRequest = {\n        targetIpId: ipIdB,\n        cid: await generateCID(),\n        targetTag: tag,\n        liveness: 2592000,\n        bond: minimumBond,\n    };\n    if (tag === src_1.DisputeTargetTag.IN_DISPUTE) {\n        await (0, chai_1.expect)(clientA.dispute.raiseDispute(raiseDisputeRequest)).to.be.rejectedWith(\&quot;The target tag IN_DISPUTE is not whitelisted\&quot;);\n    }\n    else {\n        const response = await clientA.dispute.raiseDispute(raiseDisputeRequest);\n        (0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n        (0, chai_1.expect)(response.disputeId).to.be.a(\&quot;bigint\&quot;);\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;83030fbf-c80d-4d03-a018-51867b9a9e70&quot;,&quot;parentUUID&quot;:&quot;4cbe703e-0cd1-4376-ae41-fb0bce69076b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should be able to counter existing dispute once&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should be able to counter existing dispute once&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13450,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const assertionId = await clientB.dispute.disputeIdToAssertionId(disputeId);\nconst counterEvidenceCID = await generateCID();\nconst ret = await clientB.dispute.disputeAssertion({\n    ipId: ipIdB,\n    assertionId,\n    counterEvidenceCID,\n});\n(0, chai_1.expect)(ret.txHash).to.be.a(\&quot;string\&quot;);\n// should throw error if attempting to dispute assertion again\nawait (0, chai_1.expect)(clientB.dispute.disputeAssertion({\n    ipId: ipIdB,\n    assertionId,\n    counterEvidenceCID,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1c28683f-fa03-4022-84dc-6f91cd657443&quot;,&quot;parentUUID&quot;:&quot;4cbe703e-0cd1-4376-ae41-fb0bce69076b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;4bd6d9e3-5cc5-4a8d-97d4-3fe52dd0b2cb&quot;,&quot;83030fbf-c80d-4d03-a018-51867b9a9e70&quot;,&quot;1c28683f-fa03-4022-84dc-6f91cd657443&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:58538,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;dc5361eb-91d3-4c8b-ae05-24d625ac7763&quot;,&quot;title&quot;:&quot;Dispute resolution&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/dispute.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before each\&quot; hook in \&quot;Dispute resolution\&quot;&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution \&quot;before each\&quot; hook in \&quot;Dispute resolution\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30809,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Setup NFT collection\nconst txData = await clientA.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\n// Get parent IP ID and license terms ID\nconst ipIdAndLicenseResponse = await clientA.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContract,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: src_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: generated_1.evenSplitGroupPoolAddress[util_1.aeneid],\n            },\n        },\n    ],\n});\nparentIpId = ipIdAndLicenseResponse.ipId;\nlicenseTermsId = ipIdAndLicenseResponse.licenseTermsIds[0];\n//Create a derivative ip\nconst derivativeIpIdResponse1 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\nchildIpId = derivativeIpIdResponse1.ipId;\n// Create a second derivative ip\nconst derivativeIpIdResponse2 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\nchildIpId2 = derivativeIpIdResponse2.ipId;\n// Raise a dispute\nconst response = await clientA.dispute.raiseDispute({\n    targetIpId: parentIpId,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 1,\n    bond: minimumBond,\n});\ndisputeId = response.disputeId;\n// This timeout guarantees that the assertion is expired\n// its intended to be longer than the current block time\n// so it won&#x27;t be included in the same block\nawait new Promise((resolve) =&gt; setTimeout(resolve, 3000));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a5707dfd-04a4-4c4a-9349-c8648ad117e5&quot;,&quot;parentUUID&quot;:&quot;dc5361eb-91d3-4c8b-ae05-24d625ac7763&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should tag infringing ip&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag infringing ip&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8660,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Tag derivative IP as infringing\nconst results = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: childIpId2,\n            disputeId: disputeId,\n        },\n    ],\n});\n(0, chai_1.expect)(results[0].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ac40f44e-b870-41b0-b79b-ecb2b86e595a&quot;,&quot;parentUUID&quot;:&quot;dc5361eb-91d3-4c8b-ae05-24d625ac7763&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should tag a single IP as infringing without using multicall&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag a single IP as infringing without using multicall&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8735,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;/**\n * Test Flow:\n * 1. Set judgment on an existing dispute to mark it as valid (did in `before each` block)\n * 2. Verify the dispute state changed correctly after judgment\n * 3. Try to tag a derivative IP using the judged dispute\n */\n// Step 1: Set judgment on an existing dispute to mark it as valid\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Step 2: Verify dispute state\n// The disputes() function returns multiple values about the dispute:\n// - targetTag: the tag we wanted to apply when raising the dispute\n// - currentTag: the current state of the dispute after judgment\n// After a successful judgment, currentTag should equal targetTag\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag); // Verify judgment was recorded correctly\n// Step 3: Attempt to tag a derivative IP\n// This will fail if:\n// - The dispute is not in a valid state (still IN_DISPUTE or cleared)\n// - The IP we&#x27;re trying to tag is not actually a derivative of the disputed IP\n// - The dispute has already been used to tag this IP\nconst response = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId, // The derivative IP to tag\n            disputeId: disputeId, // Using the judged dispute as basis for tagging\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: false, // Force single transaction instead of batch\n    },\n});\n// Verify we got the expected response\n(0, chai_1.expect)(response).to.have.lengthOf(1);\n(0, chai_1.expect)(response[0].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e4a4b749-6e14-4935-8a3e-7609e0f3b7d3&quot;,&quot;parentUUID&quot;:&quot;dc5361eb-91d3-4c8b-ae05-24d625ac7763&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should tag multiple IPs as infringing using multicall&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag multiple IPs as infringing using multicall&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:25611,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const disputeResponse = await clientA.dispute.raiseDispute({\n    targetIpId: parentIpId,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 1,\n    bond: minimumBond,\n});\nconst testDisputeId = disputeResponse.disputeId;\nconst derivativeResponse2 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nconst newChildIpId = derivativeResponse2.ipId;\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, testDisputeId);\n// This timeout guarantees that the assertion is expired\n// its intended to be longer than the current block time\n// so it won&#x27;t be included in the same block\nawait new Promise((resolve) =&gt; setTimeout(resolve, 3000));\nconst { currentTag, targetTag } = await getDisputeState(testDisputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst response = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: testDisputeId,\n        },\n        {\n            ipId: newChildIpId,\n            disputeId: testDisputeId,\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: true,\n    },\n});\n(0, chai_1.expect)(response).to.have.lengthOf(1);\n(0, chai_1.expect)(response[0].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;38f72fb1-e4df-445a-983c-e1180ef2f324&quot;,&quot;parentUUID&quot;:&quot;dc5361eb-91d3-4c8b-ae05-24d625ac7763&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should tag multiple IPs without multicall when specified&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag multiple IPs without multicall when specified&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18422,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create two new derivative IPs sequentially\nconst derivativeResponse3 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nconst derivativeResponse4 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst responses = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: derivativeResponse3.ipId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: derivativeResponse4.ipId,\n            disputeId: disputeId,\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: false,\n    },\n});\n(0, chai_1.expect)(responses).to.have.lengthOf(2);\n(0, chai_1.expect)(responses[0].txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(responses[1].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6d585772-b510-42bc-98a8-6ffd25542b57&quot;,&quot;parentUUID&quot;:&quot;dc5361eb-91d3-4c8b-ae05-24d625ac7763&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should resolve a dispute successfully when initiated by dispute initiator&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should resolve a dispute successfully when initiated by dispute initiator&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12724,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst response = await clientA.dispute.resolveDispute({\n    disputeId: disputeId,\n    data: \&quot;0x\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;428631fe-3e8e-476d-821f-e886a249d459&quot;,&quot;parentUUID&quot;:&quot;dc5361eb-91d3-4c8b-ae05-24d625ac7763&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when non-initiator tries to resolve the dispute&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should fail when non-initiator tries to resolve the dispute&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:42,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(clientB.dispute.resolveDispute({\n    disputeId: disputeId,\n    data: \&quot;0x\&quot;,\n})).to.be.rejectedWith(\&quot;NotDisputeInitiator\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8096c30a-2286-4296-baa4-c8fc05b26ac8&quot;,&quot;parentUUID&quot;:&quot;dc5361eb-91d3-4c8b-ae05-24d625ac7763&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should propagate IMPROPER_REGISTRATION tag to derivative IPs&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should propagate IMPROPER_REGISTRATION tag to derivative IPs&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8778,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Verify the dispute state changed correctly\nconst { currentTag: parentCurrentTag, targetTag: parentTargetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(parentCurrentTag).to.equal(parentTargetTag);\n// Propagate the tag to both derivative IPs\nconst results = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: childIpId2,\n            disputeId: disputeId,\n        },\n    ],\n});\nconst logData = results[0].receipt?.logs[0].data;\nconst firstWord = logData.slice(0, 66);\nconst childDisputeId = BigInt(firstWord);\n// Verify successful tagging\n(0, chai_1.expect)(results[0].txHash).to.be.a(\&quot;string\&quot;);\nconst { currentTag: childCurrentTag } = await getDisputeState(childDisputeId);\n// Convert the IMPROPER_USAGE tag to hex for comparison\nconst improperUsageTagHex = (0, viem_1.toHex)(src_1.DisputeTargetTag.IMPROPER_REGISTRATION, { size: 32 });\n// Verify both child IPs have the IMPROPER_USAGE tag by\n// fetching and comparing their dispute tags\n(0, chai_1.expect)(parentCurrentTag).to.equal(parentTargetTag);\n(0, chai_1.expect)(childCurrentTag).to.equal(improperUsageTagHex);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ed013f71-c9ed-4d79-8cf8-e73f7bf46c56&quot;,&quot;parentUUID&quot;:&quot;dc5361eb-91d3-4c8b-ae05-24d625ac7763&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;ac40f44e-b870-41b0-b79b-ecb2b86e595a&quot;,&quot;e4a4b749-6e14-4935-8a3e-7609e0f3b7d3&quot;,&quot;38f72fb1-e4df-445a-983c-e1180ef2f324&quot;,&quot;6d585772-b510-42bc-98a8-6ffd25542b57&quot;,&quot;428631fe-3e8e-476d-821f-e886a249d459&quot;,&quot;8096c30a-2286-4296-baa4-c8fc05b26ac8&quot;,&quot;ed013f71-c9ed-4d79-8cf8-e73f7bf46c56&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:82972,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;a47a47a3-368a-4a40-a02b-81db06493649&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:9045,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;f16df3be-ee1d-4b1d-aabd-4f5700a9a877&quot;,&quot;title&quot;:&quot;Group Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Group Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Group Functions \&quot;before all\&quot; hook in \&quot;Group Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4345,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\n// Create NFT Collection\nspgNftContract = (await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n})).spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9cee52e5-ca8b-4e10-ac5c-0ba3f1b5d31d&quot;,&quot;parentUUID&quot;:&quot;f16df3be-ee1d-4b1d-aabd-4f5700a9a877&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;fca86349-216d-42e8-b3c8-2605281ff541&quot;,&quot;title&quot;:&quot;Group Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Group Operations\&quot;&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations \&quot;before all\&quot; hook in \&quot;Group Operations\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9129,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create initial IP with license terms\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    allowDuplicates: false,\n    licenseTermsData,\n});\nlicenseTermsId = result.licenseTermsIds[0];\nipId = result.ipId;\n// Set licensing config\nawait client.license.setLicensingConfig({\n    ipId,\n    licenseTermsId,\n    licenseTemplate: generated_1.piLicenseTemplateAddress[util_1.aeneid],\n    licensingConfig: {\n        isSet: true,\n        mintingFee: 0n,\n        licensingHook: viem_1.zeroAddress,\n        hookData: viem_1.zeroAddress,\n        commercialRevShare: 0,\n        disabled: false,\n        expectMinimumGroupRewardShare: 0,\n        expectGroupRewardPool: groupPoolAddress,\n    },\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f617af53-29d1-4838-a691-48eb118da0d8&quot;,&quot;parentUUID&quot;:&quot;fca86349-216d-42e8-b3c8-2605281ff541&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully register group and attach license&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register group and attach license&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4343,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.registerGroupAndAttachLicense({\n    groupPool: groupPoolAddress,\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n});\ngroupId = result.groupId;\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.groupId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0a5561e0-23b2-4e8d-94ad-5e32d2d8d40d&quot;,&quot;parentUUID&quot;:&quot;fca86349-216d-42e8-b3c8-2605281ff541&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully mint, register IP, attach license and add to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully mint, register IP, attach license and add to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4473,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.mintAndRegisterIpAndAttachLicenseAndAddToGroup({\n    groupId,\n    spgNftContract,\n    licenseData: [\n        {\n            licenseTermsId,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: groupPoolAddress,\n            },\n        },\n    ],\n    maxAllowedRewardShare: 100,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d2b011f6-0c88-4ac1-880e-154a3d8675c2&quot;,&quot;parentUUID&quot;:&quot;fca86349-216d-42e8-b3c8-2605281ff541&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register a basic group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register a basic group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4317,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.registerGroup({\n    groupPool: groupPoolAddress,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.groupId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;49c95f7c-02e0-421a-9798-f066af9833ec&quot;,&quot;parentUUID&quot;:&quot;fca86349-216d-42e8-b3c8-2605281ff541&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register existing IP with license and add to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register existing IP with license and add to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8877,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(spgNftContract, \&quot;test-metadata\&quot;);\nconst result = await client.groupClient.registerIpAndAttachLicenseAndAddToGroup({\n    groupId,\n    nftContract: spgNftContract,\n    tokenId,\n    licenseData: [\n        {\n            licenseTermsId,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: groupPoolAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;65bb80f3-f71f-4bdc-9779-b880f090fc84&quot;,&quot;parentUUID&quot;:&quot;fca86349-216d-42e8-b3c8-2605281ff541&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register group with license and add multiple IPs&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register group with license and add multiple IPs&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4431,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.registerGroupAndAttachLicenseAndAddIps({\n    groupPool: groupPoolAddress,\n    maxAllowedRewardShare: 50,\n    ipIds: [ipId],\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.groupId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;23a92d4d-f43f-4c8b-8fcb-e851b51c5182&quot;,&quot;parentUUID&quot;:&quot;fca86349-216d-42e8-b3c8-2605281ff541&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;b376e1bc-33e9-4730-86ee-77efec1cfc7b&quot;,&quot;title&quot;:&quot;Add IPs to Group and Remove IPs from Group&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully add multiple IPs to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should successfully add multiple IPs to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9517,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const registerResult = await client.ipAsset.batchMintAndRegisterIpAssetWithPilTerms({\n    args: [\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n    ],\n});\nipIds = registerResult.results?.map((result) =&gt; result.ipId) ?? [];\nconst result = await client.groupClient.addIpsToGroup({\n    groupIpId: groupId,\n    ipIds: ipIds,\n    maxAllowedRewardSharePercentage: 55,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;929fc562-21b6-466c-943e-654fe702093d&quot;,&quot;parentUUID&quot;:&quot;b376e1bc-33e9-4730-86ee-77efec1cfc7b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully remove IPs from group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should successfully remove IPs from group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4339,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.removeIpsFromGroup({\n    groupIpId: groupId,\n    ipIds: ipIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ee35f257-c0a7-480c-b6a7-a2a80691c446&quot;,&quot;parentUUID&quot;:&quot;b376e1bc-33e9-4730-86ee-77efec1cfc7b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;929fc562-21b6-466c-943e-654fe702093d&quot;,&quot;ee35f257-c0a7-480c-b6a7-a2a80691c446&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13856,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;0a5561e0-23b2-4e8d-94ad-5e32d2d8d40d&quot;,&quot;d2b011f6-0c88-4ac1-880e-154a3d8675c2&quot;,&quot;49c95f7c-02e0-421a-9798-f066af9833ec&quot;,&quot;65bb80f3-f71f-4bdc-9779-b880f090fc84&quot;,&quot;23a92d4d-f43f-4c8b-8fcb-e851b51c5182&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:26441,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;642fd308-db46-44ee-9b41-b3217219d3c9&quot;,&quot;title&quot;:&quot;Collect Royalty and Claim Reward&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Collect Royalty and Claim Reward\&quot;&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward \&quot;before all\&quot; hook in \&quot;Collect Royalty and Claim Reward\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9169,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Register IP id\nconst result1 = await mintAndRegisterIpAssetWithPilTermsHelper();\nipId = result1.ipId;\nlicenseTermsId = result1.licenseTermsIds[0];\n// Register group id\ngroupIpId = await registerGroupAndAttachLicenseHelper(licenseTermsId, [ipId]);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d7f9ad81-498c-4e80-8a45-74e0e5621782&quot;,&quot;parentUUID&quot;:&quot;642fd308-db46-44ee-9b41-b3217219d3c9&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully collect royalties&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully collect royalties&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18017,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Mint and register child IP id\nconst childIpId = await mintAndRegisterIpAndMakeDerivativeHelper(groupIpId, licenseTermsId);\n// Pay royalties from child IP id to group IP id and transfer to vault\nawait payRoyaltyAndTransferToVaultHelper(childIpId, groupIpId, src_1.WIP_TOKEN_ADDRESS, 100n);\n// Collect royalties\nconst result = await client.groupClient.collectRoyalties({\n    groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.collectedRoyalties).to.equal(10n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;645230b4-f155-4f36-8548-87fec61e1ade&quot;,&quot;parentUUID&quot;:&quot;642fd308-db46-44ee-9b41-b3217219d3c9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully get claimable reward&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully get claimable reward&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:44,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.getClaimableReward({\n    groupIpId: groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n});\n(0, chai_1.expect)(result).to.deep.equal([10n]);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;16072d34-0141-47ad-8a1c-d1559051af2b&quot;,&quot;parentUUID&quot;:&quot;642fd308-db46-44ee-9b41-b3217219d3c9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully claim reward&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully claim reward&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8864,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Mint license tokens to the IP id which doesn&#x27;t have a royalty vault\nawait client.license.mintLicenseTokens({\n    licensorIpId: ipId,\n    licenseTermsId,\n    amount: 1,\n    maxMintingFee: 1,\n    maxRevenueShare: 100,\n});\n// Claim reward\nconst result = await client.groupClient.claimReward({\n    groupIpId: groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.claimedReward?.[0].amount[0]).to.equal(10n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;772644ca-d3eb-4323-8cfb-dec15b76671f&quot;,&quot;parentUUID&quot;:&quot;642fd308-db46-44ee-9b41-b3217219d3c9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully collect royalties and claim reward in one transaction&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully collect royalties and claim reward in one transaction&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:45812,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const ipIds = [];\nconst result1 = await mintAndRegisterIpAssetWithPilTermsHelper();\nconst result2 = await mintAndRegisterIpAssetWithPilTermsHelper();\nipIds.push(result1.ipId);\nipIds.push(result2.ipId);\nlicenseTermsId = result1.licenseTermsIds[0];\nconst groupId = await registerGroupAndAttachLicenseHelper(licenseTermsId, ipIds);\nconst childIpId1 = await mintAndRegisterIpAndMakeDerivativeHelper(groupId, licenseTermsId);\nconst childIpId2 = await mintAndRegisterIpAndMakeDerivativeHelper(groupId, licenseTermsId);\nawait payRoyaltyAndTransferToVaultHelper(childIpId1, groupId, src_1.WIP_TOKEN_ADDRESS, 100n);\nawait payRoyaltyAndTransferToVaultHelper(childIpId2, groupId, src_1.WIP_TOKEN_ADDRESS, 100n);\nconst result = await client.groupClient.collectAndDistributeGroupRoyalties({\n    groupIpId: groupId,\n    currencyTokens: [src_1.WIP_TOKEN_ADDRESS],\n    memberIpIds: ipIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.collectedRoyalties?.[0].amount).to.equal(20n);\n(0, chai_1.expect)(result.royaltiesDistributed?.[0].amount).to.equal(10n);\n(0, chai_1.expect)(result.royaltiesDistributed?.[1].amount).to.equal(10n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9714138e-487b-428f-9cb6-7d7293739b33&quot;,&quot;parentUUID&quot;:&quot;642fd308-db46-44ee-9b41-b3217219d3c9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;645230b4-f155-4f36-8548-87fec61e1ade&quot;,&quot;16072d34-0141-47ad-8a1c-d1559051af2b&quot;,&quot;772644ca-d3eb-4323-8cfb-dec15b76671f&quot;,&quot;9714138e-487b-428f-9cb6-7d7293739b33&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:72737,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;70de9c08-5fe4-4d43-8f7a-1c7ea85d23d6&quot;,&quot;title&quot;:&quot;IPAccount Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;IPAccount Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions \&quot;before all\&quot; hook in \&quot;IPAccount Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8710,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = registerResult.ipId;\ndata = (0, viem_1.encodeFunctionData)({\n    abi: generated_1.accessControllerAbi,\n    functionName: \&quot;setTransientPermission\&quot;,\n    args: [\n        (0, viem_1.getAddress)(ipId),\n        (0, viem_1.getAddress)(util_1.TEST_WALLET_ADDRESS),\n        (0, viem_1.getAddress)(coreMetadataModule),\n        (0, viem_1.toFunctionSelector)(\&quot;function setAll(address,string,bytes32,bytes32)\&quot;),\n        src_1.AccessPermission.ALLOW,\n    ],\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;94b26138-c7d8-4f33-98e5-ed96fc693e32&quot;,&quot;parentUUID&quot;:&quot;70de9c08-5fe4-4d43-8f7a-1c7ea85d23d6&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully return account nonce&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions should successfully return account nonce&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:46,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.ipAccount.getIpAccountNonce(ipId);\n(0, chai_1.expect)(response).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c9a45ddc-f0a6-4bb5-8a3c-fae8b6944f38&quot;,&quot;parentUUID&quot;:&quot;70de9c08-5fe4-4d43-8f7a-1c7ea85d23d6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully return token information&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions should successfully return token information&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:43,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.ipAccount.getToken(ipId);\n(0, chai_1.expect)(response.chainId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(response.tokenContract).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.tokenId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(response.tokenContract).to.equal(util_1.mockERC721);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;25a8d4ce-9a19-4e55-93d2-bdc6c6f1d6af&quot;,&quot;parentUUID&quot;:&quot;70de9c08-5fe4-4d43-8f7a-1c7ea85d23d6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully set ip metadata&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions should successfully set ip metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8593,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txHash = await client.ipAccount.setIpMetadata({\n    ipId: ipId,\n    metadataURI: \&quot;https://example.com\&quot;,\n    metadataHash: (0, viem_1.toHex)(\&quot;test\&quot;, { size: 32 }),\n});\n(0, chai_1.expect)(txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;738db551-80b1-4c43-a44f-1d02dfb35041&quot;,&quot;parentUUID&quot;:&quot;70de9c08-5fe4-4d43-8f7a-1c7ea85d23d6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully transfer ERC20 tokens&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions should successfully transfer ERC20 tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17642,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const erc20 = new generated_1.Erc20Client(util_1.publicClient, util_1.walletClient);\n// 1. Query token balance of ipId and wallet before\nconst initialErc20BalanceOfIpId = await erc20.balanceOf({\n    account: ipId,\n});\nconst initialErc20BalanceOfWallet = await erc20.balanceOf({\n    account: util_1.TEST_WALLET_ADDRESS,\n});\nconst initialWipBalanceOfIpId = await client.wipClient.balanceOf(ipId);\nconst initialWipBalanceOfWallet = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n// 2. transfer erc20 token to the ip account\nconst txHash = await erc20.mint({\n    to: ipId,\n    amount: (0, viem_1.parseEther)(\&quot;0.002\&quot;),\n});\nawait util_1.publicClient.waitForTransactionReceipt({\n    hash: txHash,\n});\n// 3. transfer wip to the ip account\nawait client.wipClient.deposit({\n    amount: 1n,\n});\nawait client.wipClient.transfer({\n    to: ipId,\n    amount: 1n,\n});\n// 4. transfer token of ip account to wallet address\nconst ret = await client.ipAccount.transferErc20({\n    ipId,\n    tokens: [\n        {\n            address: src_1.WIP_TOKEN_ADDRESS,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: 1n,\n        },\n        {\n            address: erc20.address,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: (0, viem_1.parseEther)(\&quot;0.001\&quot;),\n        },\n        {\n            address: erc20.address,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: (0, viem_1.parseEther)(\&quot;0.001\&quot;),\n        },\n    ],\n});\n// 5. query token balance of ipId and wallet address after\nconst finalErc20BalanceOfIpId = await erc20.balanceOf({\n    account: ipId,\n});\nconst finalWipBalanceOfIpId = await client.wipClient.balanceOf(ipId);\nconst finalErc20BalanceOfWallet = await erc20.balanceOf({\n    account: util_1.TEST_WALLET_ADDRESS,\n});\nconst finalWipBalanceOfWallet = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(ret.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(finalErc20BalanceOfIpId).to.equal(initialErc20BalanceOfIpId);\n(0, chai_1.expect)(finalWipBalanceOfIpId).to.equal(initialWipBalanceOfIpId);\n(0, chai_1.expect)(finalErc20BalanceOfWallet).to.equal(initialErc20BalanceOfWallet + (0, viem_1.parseEther)(\&quot;0.002\&quot;));\n(0, chai_1.expect)(finalWipBalanceOfWallet).to.equal(initialWipBalanceOfWallet + 1n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e16797bc-cec9-41c1-a6cb-c377243a8686&quot;,&quot;parentUUID&quot;:&quot;70de9c08-5fe4-4d43-8f7a-1c7ea85d23d6&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;fffa0c5f-88f4-4b64-b48b-fc8a8854eb39&quot;,&quot;title&quot;:&quot;execute&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully execute a transaction&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions execute should successfully execute a transaction&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4309,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.ipAccount.execute({\n    to: permissionAddress,\n    value: 0,\n    data: data,\n    ipId: ipId,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cd1d0d23-5858-46a3-97a3-69a06b0ab103&quot;,&quot;parentUUID&quot;:&quot;fffa0c5f-88f4-4b64-b48b-fc8a8854eb39&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;cd1d0d23-5858-46a3-97a3-69a06b0ab103&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4309,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;0553e258-77ec-43d1-8607-8eeaed89de00&quot;,&quot;title&quot;:&quot;executeWithSig&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully execute with valid signature&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should successfully execute with valid signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4367,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Get the IP Account nonce (state)\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\n// Generate signature for the execute operation itself\n// We need to sign the data that will be executed, not the permission data\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\n// Execute with signature\nconst response = await client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0bb6f8d6-2be5-488a-a5c2-074f111e94c1&quot;,&quot;parentUUID&quot;:&quot;0553e258-77ec-43d1-8607-8eeaed89de00&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with expired deadline&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with expired deadline&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:55,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: EXPIRED_DEADLINE,\n    signature: \&quot;0x\&quot;,\n})).to.be.rejectedWith(\&quot;IPAccount__ExpiredSignature\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2f9a7586-58a7-4e78-afb8-7e4647a360b5&quot;,&quot;parentUUID&quot;:&quot;0553e258-77ec-43d1-8607-8eeaed89de00&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with signature from wrong signer&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with signature from wrong signer&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:87,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Generate signature with wrong signer\nconst wrongSigner = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: wrongSigner,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3c422902-d3ed-4098-959c-0e429edd4a8b&quot;,&quot;parentUUID&quot;:&quot;0553e258-77ec-43d1-8607-8eeaed89de00&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should execute with zero value transaction&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should execute with zero value transaction&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4374,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Test successful execution with zero value\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nconst response = await client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n    value: 0, // Explicitly set zero value\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;da92a439-7d81-40f1-924a-6aee50c85e4e&quot;,&quot;parentUUID&quot;:&quot;0553e258-77ec-43d1-8607-8eeaed89de00&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;0bb6f8d6-2be5-488a-a5c2-074f111e94c1&quot;,&quot;2f9a7586-58a7-4e78-afb8-7e4647a360b5&quot;,&quot;3c422902-d3ed-4098-959c-0e429edd4a8b&quot;,&quot;da92a439-7d81-40f1-924a-6aee50c85e4e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:8883,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;c9a45ddc-f0a6-4bb5-8a3c-fae8b6944f38&quot;,&quot;25a8d4ce-9a19-4e55-93d2-bdc6c6f1d6af&quot;,&quot;738db551-80b1-4c43-a44f-1d02dfb35041&quot;,&quot;e16797bc-cec9-41c1-a6cb-c377243a8686&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:26324,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;167de16f-26b5-48ab-8151-37a300678d54&quot;,&quot;title&quot;:&quot;IP Asset Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;IP Asset Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions \&quot;before all\&quot; hook in \&quot;IP Asset Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:47,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst res = await client.license.registerPILTerms(src_1.PILFlavor.nonCommercialSocialRemixing());\nnoCommercialLicenseTermsId = res.licenseTermsId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;14936828-d081-49ae-852a-832349266435&quot;,&quot;parentUUID&quot;:&quot;167de16f-26b5-48ab-8151-37a300678d54&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;0aaa336f-d51c-4196-9875-5de9cc1fd4dd&quot;,&quot;title&quot;:&quot;Basic IP Asset Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register an IP Asset&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register an IP Asset&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8704,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nchildIpId = response.ipId;\n(0, chai_1.expect)(childIpId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;753aea72-d685-4af2-b6e6-e5abcfcca74a&quot;,&quot;parentUUID&quot;:&quot;0aaa336f-d51c-4196-9875-5de9cc1fd4dd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register an IP Asset with multiple metadata fields&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register an IP Asset with multiple metadata fields&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8789,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    ipMetadata: {\n        ipMetadataURI: \&quot;ipfs://test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataURI: \&quot;ipfs://test-nft-uri\&quot;,\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\nchildIpId2 = response.ipId;\n(0, chai_1.expect)(response.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;aaa4e0c1-1ce8-4ad6-8505-2678bd9d2db7&quot;,&quot;parentUUID&quot;:&quot;0aaa336f-d51c-4196-9875-5de9cc1fd4dd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with Non-Commercial Remix PIL&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with Non-Commercial Remix PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17799,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nparentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [noCommercialLicenseTermsId],\n    maxMintingFee: 0,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: 0.32423,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c5eea57b-8d94-4e64-8ad5-9220a573a03a&quot;,&quot;parentUUID&quot;:&quot;0aaa336f-d51c-4196-9875-5de9cc1fd4dd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with Commercial Remix PIL&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with Commercial Remix PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22260,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Register commercial remix PIL\nconst licenseResponse = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 10n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n}));\n// Register parent IP\nconst tokenId = await (0, util_1.getTokenId)();\nconst commercialParentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// Attach license terms to parent IP\nawait client.license.attachLicenseTerms({\n    ipId: commercialParentIpId,\n    licenseTermsId: licenseResponse.licenseTermsId,\n});\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: childIpId2,\n    parentIpIds: [commercialParentIpId],\n    licenseTermsIds: [licenseResponse.licenseTermsId],\n    maxMintingFee: 100,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: 10,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;db6f5264-9739-4d18-9bbe-b456e6f858cb&quot;,&quot;parentUUID&quot;:&quot;0aaa336f-d51c-4196-9875-5de9cc1fd4dd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with multiple parent IPs&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with multiple parent IPs&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:39908,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create first parent IP\nconst tokenId1 = await (0, util_1.getTokenId)();\nconst parentIpId1 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n})).ipId;\n// Create second parent IP\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst parentIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId2,\n})).ipId;\n// Attach license terms to both parents\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId1,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId2,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\n// Create child IP\nconst childTokenId = await (0, util_1.getTokenId)();\nconst newChildIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId,\n})).ipId;\n// Register derivative with multiple parents\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: newChildIpId,\n    parentIpIds: [parentIpId1, parentIpId2],\n    licenseTermsIds: [noCommercialLicenseTermsId, noCommercialLicenseTermsId],\n    maxMintingFee: 0,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: 0.9999999999,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4c56bcda-4d33-4987-9137-5c4e4c3f0ec8&quot;,&quot;parentUUID&quot;:&quot;0aaa336f-d51c-4196-9875-5de9cc1fd4dd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17675,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst ipId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: noCommercialLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 1,\n});\nconst response = await client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;981de5ae-858b-47b8-b559-40dcfc07e65a&quot;,&quot;parentUUID&quot;:&quot;0aaa336f-d51c-4196-9875-5de9cc1fd4dd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should return true if IP asset is registered&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should return true if IP asset is registered&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:46,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const isRegistered = await client.ipAsset.isRegistered(parentIpId);\n(0, chai_1.expect)(isRegistered).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a05dff47-8959-4384-a9a4-594c33851e37&quot;,&quot;parentUUID&quot;:&quot;0aaa336f-d51c-4196-9875-5de9cc1fd4dd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;753aea72-d685-4af2-b6e6-e5abcfcca74a&quot;,&quot;aaa4e0c1-1ce8-4ad6-8505-2678bd9d2db7&quot;,&quot;c5eea57b-8d94-4e64-8ad5-9220a573a03a&quot;,&quot;db6f5264-9739-4d18-9bbe-b456e6f858cb&quot;,&quot;4c56bcda-4d33-4987-9137-5c4e4c3f0ec8&quot;,&quot;981de5ae-858b-47b8-b559-40dcfc07e65a&quot;,&quot;a05dff47-8959-4384-a9a4-594c33851e37&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:115181,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;title&quot;:&quot;SPG NFT Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;SPG NFT Operations\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations \&quot;before all\&quot; hook in \&quot;SPG NFT Operations\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9469,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Setup NFT collection\nconst txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\n// Setup license terms\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContract,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];\n// Setup ERC20\nconst mockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\nawait mockERC20.approve(generated_1.derivativeWorkflowsAddress[util_1.aeneid], viem_1.maxUint256);\nawait mockERC20.approve(generated_1.royaltyTokenDistributionWorkflowsAddress[util_1.aeneid], viem_1.maxUint256);\nawait mockERC20.mint(util_1.TEST_WALLET_ADDRESS, 100000n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d07629fd-2685-4343-8533-5731218f1db6&quot;,&quot;parentUUID&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register IP Asset with metadata&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP Asset with metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8773,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst response = await client.ipAsset.register({\n    nftContract,\n    tokenId,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(response.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a7171159-99e0-4752-a618-ce0b7f4596b1&quot;,&quot;parentUUID&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative IP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register derivative IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9068,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenChildId = await (0, util_1.mintBySpg)(nftContract);\nconst result = await client.ipAsset.registerDerivativeIp({\n    nftContract: nftContract,\n    tokenId: tokenChildId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 0,\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6fbe0852-39b9-4dfd-a9f6-a51d50865b37&quot;,&quot;parentUUID&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach PIL terms&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach PIL terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9213,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: nftContract,\n    tokenId,\n    deadline: 1000n,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.commercialUse({\n                defaultMintingFee: 10000n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 10000n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c762bfe4-de97-41bd-bc03-fdab23aa1003&quot;,&quot;parentUUID&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach PIL terms with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach PIL terms with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9340,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 10000n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0b1a6c5d-d1a1-448b-99ed-7491d5886c3f&quot;,&quot;parentUUID&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and make derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and make derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4818,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7ff50f47-548f-4f87-9499-fd28bad779bb&quot;,&quot;parentUUID&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4440,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: nftContract,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    allowDuplicates: false,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6167e9e0-3ba7-45f0-85c2-0175de5ce378&quot;,&quot;parentUUID&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and make derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and make derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13298,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: nftContract,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9ee58ae9-a529-416f-96c7-1001bfb3134e&quot;,&quot;parentUUID&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and make derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and make derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17681,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerIpAndMakeDerivativeWithLicenseTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b5c73a60-160d-465c-8b8e-40e8d25be6e4&quot;,&quot;parentUUID&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach license terms and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14015,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 10,\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 0.00020302,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f4c664e3-1096-4d27-adf7-b43d7f8a992d&quot;,&quot;parentUUID&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach license terms and distribute royalty tokens with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14356,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 12.232131,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;878eb7ff-281c-444c-8bbd-46dd8e6a67c9&quot;,&quot;parentUUID&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach license terms and distribute royalty tokens with complex royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens with complex royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13570,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: generated_1.erc20Address[util_1.aeneid],\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 43.000301,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 17.0003011,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 2.000301,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 32.0003012,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ff685043-a619-4470-81a8-4963f8ca7201&quot;,&quot;parentUUID&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative and attach license terms and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register derivative and attach license terms and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13542,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 0,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;65547045-82af-4695-a2f8-27f555c312a3&quot;,&quot;parentUUID&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and attach PIL terms and distribute royalty tokens without licensing config&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and attach PIL terms and distribute royalty tokens without licensing config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4821,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: nftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.2,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b25b325e-96e2-480b-b827-9f10c7d6e969&quot;,&quot;parentUUID&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and attach PIL terms and distribute royalty tokens with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and attach PIL terms and distribute royalty tokens with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5572,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: nftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            maxLicenseTokens: 100,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 11n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.434,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(3);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d842ae9c-593f-4b7f-a99a-54e1962b640d&quot;,&quot;parentUUID&quot;:&quot;8b976d16-6e60-47fc-a4cc-1aad8118312d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a7171159-99e0-4752-a618-ce0b7f4596b1&quot;,&quot;6fbe0852-39b9-4dfd-a9f6-a51d50865b37&quot;,&quot;c762bfe4-de97-41bd-bc03-fdab23aa1003&quot;,&quot;0b1a6c5d-d1a1-448b-99ed-7491d5886c3f&quot;,&quot;7ff50f47-548f-4f87-9499-fd28bad779bb&quot;,&quot;6167e9e0-3ba7-45f0-85c2-0175de5ce378&quot;,&quot;9ee58ae9-a529-416f-96c7-1001bfb3134e&quot;,&quot;b5c73a60-160d-465c-8b8e-40e8d25be6e4&quot;,&quot;f4c664e3-1096-4d27-adf7-b43d7f8a992d&quot;,&quot;878eb7ff-281c-444c-8bbd-46dd8e6a67c9&quot;,&quot;ff685043-a619-4470-81a8-4963f8ca7201&quot;,&quot;65547045-82af-4695-a2f8-27f555c312a3&quot;,&quot;b25b325e-96e2-480b-b827-9f10c7d6e969&quot;,&quot;d842ae9c-593f-4b7f-a99a-54e1962b640d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:142507,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;73f6f945-72d3-4709-98b9-1797475009f5&quot;,&quot;title&quot;:&quot;SPG With Minting Fees with Public Minting SPG NFT Contract&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;SPG With Minting Fees with Public Minting SPG NFT Contract\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract \&quot;before all\&quot; hook in \&quot;SPG With Minting Fees with Public Minting SPG NFT Contract\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13637,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// ensure we start with no wip since we will be wrapping them\nconst wipBalance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nif (wipBalance &gt; 0n) {\n    await client.wipClient.withdraw({\n        amount: wipBalance,\n    });\n}\n// create a nft collection that requires minting fee\nconst rsp = await client.nftClient.createNFTCollection({\n    name: \&quot;Premium Collection\&quot;,\n    symbol: \&quot;PC\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 100n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nnftContractWithMintingFee = rsp.spgNftContract;\n// create parent ip with minting fee\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContractWithMintingFee,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 150n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: true,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: BigInt(0),\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: BigInt(0),\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 150n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7c39f0e2-b673-4308-ae33-057d728309a0&quot;,&quot;parentUUID&quot;:&quot;73f6f945-72d3-4709-98b9-1797475009f5&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should auto wrap ip when mint and register derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5225,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const userBalanceBefore = await client.getWalletBalance();\nconst rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContractWithMintingFee, // pay 100 here\n    derivData: {\n        parentIpIds: [parentIpId], // pay 150 here\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test\&quot;,\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \&quot;test\&quot;,\n        nftMetadataHash: viem_1.zeroHash,\n    },\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);\nconst userBalanceAfter = await client.getWalletBalance();\nconst cost = 150n + 100n;\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - cost));\n// user should not have any WIP tokens since we swap the exact amount\nconst wipBalance = await client.ipAsset.wipClient.balanceOf({\n    owner: util_1.TEST_WALLET_ADDRESS,\n});\n(0, chai_1.expect)(wipBalance.result).to.be.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1208dcff-e66c-436e-a0f1-928b5b79cc38&quot;,&quot;parentUUID&quot;:&quot;73f6f945-72d3-4709-98b9-1797475009f5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto wrap ip when mint and register derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22306,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nconst { txHash, ipId } = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: nftContractWithMintingFee,\n    licenseTokenIds: licenseTokenIds,\n    maxRts: 0,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test\&quot;,\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \&quot;test\&quot;,\n        nftMetadataHash: viem_1.zeroHash,\n    },\n});\n(0, chai_1.expect)(txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(ipId).to.be.a(\&quot;string\&quot;);\nconst isRegistered = await client.ipAsset.isRegistered(ipId);\n(0, chai_1.expect)(isRegistered).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3e5ca45d-f870-415b-aa6f-4be174fd2608&quot;,&quot;parentUUID&quot;:&quot;73f6f945-72d3-4709-98b9-1797475009f5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto wrap ip when registering derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when registering derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13634,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst balanceBefore = await client.getWalletBalance();\nconst rsp = await client.ipAsset.registerDerivativeIp({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 150n));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c80393b7-b54a-4fcc-8220-8daefa158e54&quot;,&quot;parentUUID&quot;:&quot;73f6f945-72d3-4709-98b9-1797475009f5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should spend existing wip when register derivative and distribute loyalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should spend existing wip when register derivative and distribute loyalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17972,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nawait client.wipClient.deposit({\n    amount: 150n,\n});\nconst rsp = await client.ipAsset.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 4.000301,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.be.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;12fd77bc-9e46-41de-ab55-d753123ad95d&quot;,&quot;parentUUID&quot;:&quot;73f6f945-72d3-4709-98b9-1797475009f5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto wrap ip when mint and register derivative and distribute loyalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative and distribute loyalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5054,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens({\n    spgNftContract: nftContractWithMintingFee,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test\&quot;,\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \&quot;test\&quot;,\n        nftMetadataHash: viem_1.zeroHash,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 0.34343234234,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4b46edb8-b05a-4a5a-99ba-475c6f2d2cf1&quot;,&quot;parentUUID&quot;:&quot;73f6f945-72d3-4709-98b9-1797475009f5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1208dcff-e66c-436e-a0f1-928b5b79cc38&quot;,&quot;3e5ca45d-f870-415b-aa6f-4be174fd2608&quot;,&quot;c80393b7-b54a-4fcc-8220-8daefa158e54&quot;,&quot;12fd77bc-9e46-41de-ab55-d753123ad95d&quot;,&quot;4b46edb8-b05a-4a5a-99ba-475c6f2d2cf1&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:64191,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;8ec34e85-a80d-4480-b519-8433e90440f8&quot;,&quot;title&quot;:&quot;IP Asset Registration with Private Minting SPG NFT Contracts&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;IP Asset Registration with Private Minting SPG NFT Contracts\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts \&quot;before all\&quot; hook in \&quot;IP Asset Registration with Private Minting SPG NFT Contracts\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4307,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;Private Minting Collection\&quot;,\n    symbol: \&quot;PMC\&quot;,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 3n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \&quot;\&quot;,\n});\nspgNftContractWithPrivateMinting = privateMintingCollectionResult.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;85722c47-f275-416d-aade-e1257dfe8b81&quot;,&quot;parentUUID&quot;:&quot;8ec34e85-a80d-4480-b519-8433e90440f8&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when call mint and register ip asset with pil terms&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip asset with pil terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13756,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 6n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                commercialRevShare: 90,\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;550786f2-bbcd-42b5-9993-45d05e7cc52d&quot;,&quot;parentUUID&quot;:&quot;8ec34e85-a80d-4480-b519-8433e90440f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip asset with pil terms with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip asset with pil terms with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9716,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 5n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 5n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n    ipMetadata: {\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;681dfbee-8a49-4046-ac5f-5fe66d31895d&quot;,&quot;parentUUID&quot;:&quot;8ec34e85-a80d-4480-b519-8433e90440f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip and make derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and make derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9354,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 100n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4e6ae4c3-4782-4888-ae5f-487043bd8997&quot;,&quot;parentUUID&quot;:&quot;8ec34e85-a80d-4480-b519-8433e90440f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12956,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    allowDuplicates: false,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3d2ab99f-d85b-47d9-985f-98dba4597d55&quot;,&quot;parentUUID&quot;:&quot;8ec34e85-a80d-4480-b519-8433e90440f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip and make derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and make derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22112,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst licenseTokenId = mintLicenseTokensResult.licenseTokenIds[0];\nconst result = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    licenseTokenIds: [licenseTokenId],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;444d5fd8-403d-4d37-9d9d-096f2157999d&quot;,&quot;parentUUID&quot;:&quot;8ec34e85-a80d-4480-b519-8433e90440f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip and attach pil terms and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and attach pil terms and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9342,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.434,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1045eb39-7630-46b6-ac6c-f475d40aabcd&quot;,&quot;parentUUID&quot;:&quot;8ec34e85-a80d-4480-b519-8433e90440f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should succeed when call mint and register ip and make derivative and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should succeed when call mint and register ip and make derivative and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22826,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: true,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\nconst newParentIpId = result.ipId;\nconst licenseId = result.licenseTermsIds[0];\nconst rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    derivData: {\n        parentIpIds: [newParentIpId],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.434,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f86c71c1-3ae7-492a-8415-1ab3a6e03393&quot;,&quot;parentUUID&quot;:&quot;8ec34e85-a80d-4480-b519-8433e90440f8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;550786f2-bbcd-42b5-9993-45d05e7cc52d&quot;,&quot;681dfbee-8a49-4046-ac5f-5fe66d31895d&quot;,&quot;4e6ae4c3-4782-4888-ae5f-487043bd8997&quot;,&quot;3d2ab99f-d85b-47d9-985f-98dba4597d55&quot;,&quot;444d5fd8-403d-4d37-9d9d-096f2157999d&quot;,&quot;1045eb39-7630-46b6-ac6c-f475d40aabcd&quot;,&quot;f86c71c1-3ae7-492a-8415-1ab3a6e03393&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:100062,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;b0c53573-8311-46e5-b2fa-89bec8157c27&quot;,&quot;title&quot;:&quot;Batch Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Batch Operations\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations \&quot;before all\&quot; hook in \&quot;Batch Operations\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13057,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\nconst tokenId = await (0, util_1.getTokenId)();\nparentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;872fa772-557d-4e1f-a44d-9a40118627a3&quot;,&quot;parentUUID&quot;:&quot;b0c53573-8311-46e5-b2fa-89bec8157c27&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should batch register derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch register derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:26786,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const childTokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId,\n})).ipId;\nconst childTokenId2 = await (0, util_1.getTokenId)();\nconst childIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId2,\n})).ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nconst result = await client.ipAsset.batchRegisterDerivative({\n    args: [\n        {\n            childIpId: childIpId,\n            parentIpIds: [parentIpId],\n            licenseTermsIds: [noCommercialLicenseTermsId],\n        },\n        {\n            childIpId: childIpId2,\n            parentIpIds: [parentIpId],\n            licenseTermsIds: [noCommercialLicenseTermsId],\n            maxMintingFee: 10000000,\n            maxRts: 5 * 10 ** 6,\n            maxRevenueShare: 0,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e4b56b53-9ff8-42f5-9f51-ccf6ef0fe846&quot;,&quot;parentUUID&quot;:&quot;b0c53573-8311-46e5-b2fa-89bec8157c27&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should batch mint and register IP asset with PIL terms&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch mint and register IP asset with PIL terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9377,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.batchMintAndRegisterIpAssetWithPilTerms({\n    args: [\n        {\n            spgNftContract: nftContract,\n            licenseTermsData: [\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 8n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \&quot;\&quot;,\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 8n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                    maxLicenseTokens: 100,\n                },\n                {\n                    terms: src_1.PILFlavor.commercialRemix({\n                        defaultMintingFee: 100n,\n                        commercialRevShare: 10,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                    }),\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 100n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                },\n            ],\n        },\n        {\n            spgNftContract: nftContract,\n            licenseTermsData: [\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 8n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \&quot;\&quot;,\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 8n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                    maxLicenseTokens: 100,\n                },\n            ],\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.results).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.results[0].licenseTermsIds).to.be.an(\&quot;array\&quot;).and.length(2);\n(0, chai_1.expect)(result.results[0].maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;).and.length(1);\n(0, chai_1.expect)(result.results[1].licenseTermsIds).to.be.an(\&quot;array\&quot;).and.length(1);\n(0, chai_1.expect)(result.results[1].maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;).and.length(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e4512570-7e04-4baf-943b-fc404977fe77&quot;,&quot;parentUUID&quot;:&quot;b0c53573-8311-46e5-b2fa-89bec8157c27&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should batch mint and register IP asset and make derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch mint and register IP asset and make derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4975,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract: nftContract,\n            derivData: {\n                parentIpIds: [parentIpId],\n                licenseTermsIds: [noCommercialLicenseTermsId],\n                maxMintingFee: 0,\n                maxRts: 5 * 10 ** 6,\n                maxRevenueShare: 0,\n            },\n        },\n        {\n            spgNftContract: nftContract,\n            derivData: {\n                parentIpIds: [parentIpId],\n                licenseTermsIds: [noCommercialLicenseTermsId],\n                maxMintingFee: 0,\n                maxRts: 5 * 10 ** 6,\n                maxRevenueShare: 0,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.results).to.be.an(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c4e70081-a790-4c81-9aaf-de82819e3383&quot;,&quot;parentUUID&quot;:&quot;b0c53573-8311-46e5-b2fa-89bec8157c27&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should batch register giving parameters&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch register giving parameters&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:26270,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst spgTokenId1 = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst spgTokenId2 = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId,\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2,\n        },\n        {\n            nftContract,\n            tokenId: spgTokenId1,\n            ipMetadata: {\n                ipMetadataURI: \&quot;test-uri2\&quot;,\n                ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash2\&quot;, { size: 32 }),\n                nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash2\&quot;, { size: 32 }),\n            },\n        },\n        {\n            nftContract,\n            tokenId: spgTokenId2,\n            ipMetadata: {\n                ipMetadataURI: \&quot;test-uri\&quot;,\n                ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n                nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.results).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;337f2168-b4a4-48ca-958a-23dcc129dcff&quot;,&quot;parentUUID&quot;:&quot;b0c53573-8311-46e5-b2fa-89bec8157c27&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;e4b56b53-9ff8-42f5-9f51-ccf6ef0fe846&quot;,&quot;e4512570-7e04-4baf-943b-fc404977fe77&quot;,&quot;c4e70081-a790-4c81-9aaf-de82819e3383&quot;,&quot;337f2168-b4a4-48ca-958a-23dcc129dcff&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:67408,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;53f89bee-bf3a-4e72-ac38-4b0a7d42f0fd&quot;,&quot;title&quot;:&quot;Other Edge Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Other Edge Cases\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases \&quot;before all\&quot; hook in \&quot;Other Edge Cases\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13161,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst parentIpResponse = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nparentIpId = parentIpResponse.ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;31dc230d-9b6f-4995-a7fd-189ae22cf914&quot;,&quot;parentUUID&quot;:&quot;53f89bee-bf3a-4e72-ac38-4b0a7d42f0fd&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should fail when trying to use same license token twice&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases should fail when trying to use same license token twice&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:26470,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: noCommercialLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 1,\n});\nconst tokenId1 = await (0, util_1.getTokenId)();\nawait client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n    })).ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 0,\n});\nconst tokenId2 = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n    })).ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n})).to.be.rejected; // Should fail as token already used&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d46a76e1-a312-4650-8d09-ea71ec9f336f&quot;,&quot;parentUUID&quot;:&quot;53f89bee-bf3a-4e72-ac38-4b0a7d42f0fd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should handle partial failures in batch registration&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases should handle partial failures in batch registration&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17117,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nawait client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n});\nawait (0, chai_1.expect)(client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId1, // Already registered\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2, // New registration\n        },\n    ],\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fe68b3f8-a9f8-467b-9b9c-7b85c11cba02&quot;,&quot;parentUUID&quot;:&quot;53f89bee-bf3a-4e72-ac38-4b0a7d42f0fd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;d46a76e1-a312-4650-8d09-ea71ec9f336f&quot;,&quot;fe68b3f8-a9f8-467b-9b9c-7b85c11cba02&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:43587,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;4b6c8a80-8299-44b3-89c1-d185ba409434&quot;,&quot;title&quot;:&quot;Batch Register IP Assets With Optimized Workflows&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Batch Register IP Assets With Optimized Workflows\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows \&quot;before all\&quot; hook in \&quot;Batch Register IP Assets With Optimized Workflows\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:47724,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create a public minting NFT collection\nconst publicMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;Public Minting Collection\&quot;,\n    symbol: \&quot;PMC\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \&quot;\&quot;,\n});\nspgNftContractWithPublicMintingWithWip = publicMintingCollectionResult.spgNftContract;\n// Create a private minting NFT collection\nconst privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;Private Minting Collection\&quot;,\n    symbol: \&quot;PRC\&quot;,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: generated_1.erc20Address[util_1.aeneid],\n    contractURI: \&quot;\&quot;,\n});\nspgNftContractWithPrivateMintingWithErc20 = privateMintingCollectionResult.spgNftContract;\n// Register a commercial remix PIL license\nconst commercialRemixPILResult = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 10n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n}));\nlicenseTermsIdWithWIP = commercialRemixPILResult.licenseTermsId;\n// Register a commercial use PIL license\nconst commercialUsePILResult = await client.license.registerPILTerms({\n    transferable: true,\n    royaltyPolicy: \&quot;0xBe54FB168b3c982b7AaE60dB6CF75Bd8447b390E\&quot;,\n    defaultMintingFee: 5n,\n    expiration: 0n,\n    commercialUse: true,\n    commercialAttribution: true,\n    commercializerChecker: viem_1.zeroAddress,\n    commercializerCheckerData: viem_1.zeroAddress,\n    commercialRevShare: 10,\n    commercialRevCeiling: 0n,\n    derivativesAllowed: true,\n    derivativesAttribution: true,\n    derivativesApproval: false,\n    derivativesReciprocal: true,\n    derivativeRevCeiling: 0n,\n    currency: generated_1.erc20Address[util_1.aeneid],\n    uri: \&quot;https://github.com/piplabs/pil-document/blob/ad67bb632a310d2557f8abcccd428e4c9c798db1/off-chain-terms/CommercialRemix.json\&quot;,\n});\nlicenseTermsIdWithErc20 = commercialUsePILResult.licenseTermsId;\n// Mint and register IP with public minting contract\nconst publicMintingIpResult = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPublicMintingWithWip,\n});\nparentIpId1 = publicMintingIpResult.ipId;\n// Attach license terms to the first IP\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId1,\n    licenseTermsId: licenseTermsIdWithWIP,\n});\n// Mint and register IP with private minting contract\nconst privateMintingIpResult = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n});\nparentIpId2 = privateMintingIpResult.ipId;\n// Attach license terms to the second IP\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId2,\n    licenseTermsId: licenseTermsIdWithErc20,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e1ab9467-5249-4dc4-9b7b-e755f3f5bf73&quot;,&quot;parentUUID&quot;:&quot;4b6c8a80-8299-44b3-89c1-d185ba409434&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully batch register multiple IP assets with SPG NFT contracts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully batch register multiple IP assets with SPG NFT contracts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30334,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10 WIP tokens + 10 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15 WIP tokens + 5 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the ERC20 token is used\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 0 WIP tokens + 10 ERC20 tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall due to the private minting\n     * - Two license terms\n     * - `maxLicenseTokens` is set to 1000n for first license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 1000n,\n            },\n            {\n                terms: src_1.PILFlavor.commercialUse({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 3n,\n                    override: {\n                        commercialRevShare: 90,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesReciprocal: true,\n                        commercialAttribution: false,\n                    },\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 3n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     * - One license terms\n     * - `maxLicenseTokens` is set to 100n for license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 0n,\n                    commercialRevShare: 90,\n                    override: {\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesReciprocal: true,\n                        commercialAttribution: false,\n                    },\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 100n,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 20(10+10) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 3.000301,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10 ERC20 tokens +5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.434,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the mint tokens is given `msg.sender` as the recipient\n     * - Two license terms\n     * - `maxLicenseTokens` is set to 80n and 10n for license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                maxLicenseTokens: 80n,\n            },\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 100n,\n                    commercialRevShare: 0,\n                    override: {\n                        derivativesReciprocal: true,\n                        commercialAttribution: false,\n                        expiration: 1000n,\n                    },\n                }),\n                maxLicenseTokens: 10n,\n            },\n        ],\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 1.211,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens + 10 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the mint tokens is given `msg.sender` as the recipient\n     * - One license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.creativeCommonsAttribution({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    override: {\n                        defaultMintingFee: 10000n,\n                    },\n                }),\n            },\n        ],\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 1.231,\n            },\n        ],\n    },\n];\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\n/**\n * Transaction breakdown:\n *\n * 1. derivativeWorkflowsClient: 2 args\n *    - First arg:\n *      - 10WIP tokens +10 ERC20 tokens\n *    - Second arg:\n *      - 15WIP tokens + 5 ERC20 tokens\n *\n * 2. licenseAttachmentWorkflowsClient: 1 args\n *    - 10 ERC20 tokens\n *    - Two license terms attached\n *    - First license terms: maxLicenseTokens: 1000n\n *\n * 3. multicall3Client: 2 args\n *    - First arg:\n *      - 10 WIP tokens\n *      - One license terms\n *      - First license terms: maxLicenseTokens: 100n\n *    - Second arg:\n *      - 20 WIP tokens\n *\n * 3. multicall3Client: 2 args\n *    - First arg:\n *      - 10 WIP tokens\n *      - One license terms\n *      - First license terms: maxLicenseTokens: 100n\n *    - Second arg:\n *      - 20 WIP tokens\n *\n * 4. royaltyTokenDistributionWorkflowsClient: 3 args\n *    - First arg:\n *      - 10 ERC20+ 5 ERC20 tokens\n *    - Second arg:\n *      - 15 WIP tokens\n *      - Two license terms\n *      - First license terms: maxLicenseTokens: 80n\n *      - Second license terms: maxLicenseTokens: 10n\n *    - Third arg:\n *      - 10 ERC20 tokens\n *      - One license terms\n *\n * Summary:\n * - Total transactions: 4 (4 unique transaction hashes)\n * - Total IP assets registered: 8\n */\nconst totalFeesForWIP = 10 + 15 + 10 + 20 + 15;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFeesForWIP)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(4);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes).equal(undefined);\n// Derivative workflow\n// First arg\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(undefined);\n// Second arg\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(undefined);\n// license attachment workflow\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n// multicall3 workflow\n// First arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(2);\n// First arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n// Second arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(undefined);\n// royalty token distribution workflow\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(3);\n// First arg\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(undefined);\n// Second arg\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(2);\n// Third arg\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(undefined);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4dc56002-4355-4c02-ba71-752f939c5054&quot;,&quot;parentUUID&quot;:&quot;4b6c8a80-8299-44b3-89c1-d185ba409434&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully batch register multiple IP assets with NFT contracts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully batch register multiple IP assets with NFT contracts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:64375,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst tokenId4 = await (0, util_1.getTokenId)();\nconst tokenId5 = await (0, util_1.getTokenId)();\nconst tokenId6 = await (0, util_1.getTokenId)();\nconst tokenId7 = await (0, util_1.getTokenId)();\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst requests = [\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerIpAndAttachPilTerms  workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall\n     * - Two license terms\n     * - `maxLicenseTokens` is set to 100n for second license terms\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId3,\n        deadline: 1000n,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 0n,\n                    commercialRevShare: 100,\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 10000n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 100n,\n            },\n        ],\n    },\n    /**\n     * registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Two license terms\n     * - Need to distribute royalty tokens\n     * - `maxLicenseTokens` is set to 10n for first license terms\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId4,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 1n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n            {\n                terms: src_1.PILFlavor.creativeCommonsAttribution({\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 6n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n        ],\n        ipMetadata: {\n            ipMetadataURI: \&quot;test-uri\&quot;,\n            ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n            nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 43.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 17.0003011,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 2.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 30.0003012,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId5,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId6,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId7,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.434,\n            },\n        ],\n    },\n];\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\n/**\n * Transaction breakdown:\n * 1. royaltyTokenDistributionWorkflowsClient: 4 args\n *  - First arg:\n *    - 10 WIP tokens\n *    - Need to distribute royalty tokens\n *  - Second arg:\n *    - 5 ERC20 tokens\n *    - Need to distribute royalty tokens\n *  - Third arg:\n *    - 0 WIP tokens\n *    - Two license terms\n *    - First license terms: maxLicenseTokens: 10n\n *    - Need to distribute royalty tokens\n *  - Fourth arg:\n *    - 5 ERC20 tokens\n *    - Need to distribute royalty tokens\n * 2. licenseAttachmentWorkflowsClient: 1 arg\n *  - 0 WIP tokens\n *  - Two license terms\n *  - Second license terms: maxLicenseTokens: 100n\n * 3. derivativeWorkflowsClient: 2 args\n *  - First arg:\n *    - 5 ERC20 tokens\n *  - Second arg:\n *    - 10 WIP tokens\n *\n * Summary:\n * - Total transactions: 3 (3 unique transaction hashes)\n * - Total IP assets registered: 7\n */\nconst totalFees = 10 + 10;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(3);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).equal(1);\n// royaltyTokenDistributionWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(4);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[0].ipRoyaltyVault?.length).equal(4);\n// licenseAttachmentWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipRoyaltyVault?.length).equal(0);\n//derivativeWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipRoyaltyVault?.length).equal(0);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b05361a2-079b-4639-b78f-92d4bb71c6af&quot;,&quot;parentUUID&quot;:&quot;4b6c8a80-8299-44b3-89c1-d185ba409434&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register IP assets using a combination of NFT contracts and SPG NFT contracts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully register IP assets using a combination of NFT contracts and SPG NFT contracts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:51284,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst tokenId4 = await (0, util_1.getTokenId)();\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10 WIP tokens +5 ERC20 tokens\n     * - Uses `derivativeWorkflowsClient` multicall3 due to contains ERC20 token\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10 ERC20 tokens+ 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.434,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 20(10+10) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.4341111111,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10 ERC20 tokens+10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.2312332,\n            },\n        ],\n    },\n    /**\n     * registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     * - One license terms\n     * - `maxLicenseTokens` is set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 1n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n        ipMetadata: {\n            ipMetadataURI: \&quot;test-uri\&quot;,\n            ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n            nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 43.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 17.0003011,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 2.000301,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 30.0003012,\n            },\n        ],\n    },\n    /**\n     * registerIpAndAttachPilTerms  workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall\n     * - Two license terms\n     * - The second request has `maxLicenseTokens` set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId3,\n        deadline: 1000n,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 0n,\n                    commercialRevShare: 100,\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 10000n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId4,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsIdWithWIP],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n];\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\n/**\n * Transaction breakdown:\n * 1. derivativeWorkflowsClient:3 args\n * - First arg\n *   - 10 WIP tokens+ 5 ERC20 tokens\n * - Second arg\n *   - 10 ERC20 + 10 WIP tokens\n * - Third arg\n *   - 10 WIP tokens\n *\n * 2. royaltyTokenDistributionWorkflowsClient: 3 args\n *  - First arg\n *    - 15 ERC20 tokens\n *  - Second arg\n *    - 5 ERC20 tokens\n *    - Need to distribute royalty tokens\n *  - Third arg\n *    - 0 WIP tokens\n *    - One license terms\n *    - First license terms: maxLicenseTokens: 10n\n *    - Need to distribute royalty tokens\n *\n * 3. licenseAttachmentWorkflowsClient: 1 arg\n * - 0 WIP tokens\n * - Two license terms\n * - Second license terms: maxLicenseTokens: 100n\n *\n * Summary:\n * - Total transactions: 4 (4 unique transaction hashes)\n * - Total IP assets registered: 8\n */\nconst totalFeesWithWIP = 10 + 10 + 10;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFeesWithWIP)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(4);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).equal(1);\n// derivativeWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[0].ipRoyaltyVault?.length).equal(0);\n// royaltyTokenDistributionWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipRoyaltyVault?.length).equal(2);\n//licenseAttachmentWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipRoyaltyVault?.length).equal(0);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e9ec8c22-6c71-4958-ac8f-5a725318661a&quot;,&quot;parentUUID&quot;:&quot;4b6c8a80-8299-44b3-89c1-d185ba409434&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register IP assets with multicall disabled&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully register IP assets with multicall disabled&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:41721,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15(10+5) WIP tokens\n     * - Uses `derivativeWorkflowsClient` to call the this method\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` to call the this method\n     * - One license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMintingWithErc20,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` to call the this method\n     * - Two license terms\n     * - The first request has `maxLicenseTokens` set to 10n\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMintingWithWip,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 10n,\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient`to call the this method\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10.4341212321,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 ERC20 tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient`to call the this method\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsIdWithErc20],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 3.000301,\n            },\n        ],\n    },\n];\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n    options: {\n        wipOptions: {\n            useMulticallWhenPossible: false,\n        },\n    },\n});\n/**\n * Transaction breakdown:\n *  1. derivativeWorkflowsClient:1 arg\n *    - 15 WIP\n * 2. licenseAttachmentWorkflowsClient: 2 args\n *    - First arg\n *      - 0 WIP tokens\n *      - One license terms\n *    - Second arg\n *      - 10  WIP tokens\n *      - Two license terms\n *      - First license terms: maxLicenseTokens: 10n\n * 3. royaltyTokenDistributionWorkflowsClient: 2 args\n *    - First arg\n *      - 5 ERC20 tokens\n *      - Need to distribute royalty tokens\n *    - Second arg\n *      - 5 ERC20 tokens\n *      - Need to distribute royalty tokens\n * Summary:\n * - Total transactions: 5 (5 unique transaction hashes) due to the multicall disabled\n * - Total IP assets registered: 5\n * - Two distribute royalty tokens transactions\n */\nconst totalFees = 15 + 10;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(result.registrationResults.length).equal(requests.length);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).equal(2);\n//derivativeWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipRoyaltyVault?.length).equal(0);\n//licenseAttachmentWorkflowsClient\n//First arg\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n//Second arg\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n//royaltyTokenDistributionWorkflowsClient\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipRoyaltyVault?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[4].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[4].ipRoyaltyVault?.length).equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;09f09a29-d049-4713-9d9d-83513da81a9f&quot;,&quot;parentUUID&quot;:&quot;4b6c8a80-8299-44b3-89c1-d185ba409434&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;4dc56002-4355-4c02-ba71-752f939c5054&quot;,&quot;b05361a2-079b-4639-b78f-92d4bb71c6af&quot;,&quot;e9ec8c22-6c71-4958-ac8f-5a725318661a&quot;,&quot;09f09a29-d049-4713-9d9d-83513da81a9f&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:187714,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;574f6cfe-13b4-4d4e-b2a8-34a600bc78db&quot;,&quot;title&quot;:&quot;Batch Mint and Register IP Asset&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Batch Mint and Register IP Asset\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset \&quot;before all\&quot; hook in \&quot;Batch Mint and Register IP Asset\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8646,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const publicMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContractWithPublicMinting = publicMintingCollectionResult.spgNftContract;\nconst privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 20n,\n    mintFeeToken: generated_1.erc20Address[util_1.aeneid],\n});\nspgNftContractWithPrivateMinting = privateMintingCollectionResult.spgNftContract;\nconst { address } = await (0, BIP32_1.getDerivedStoryClient)();\nanotherWalletAddress = address;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a0d91b24-448d-48be-9c52-9c139ec644a7&quot;,&quot;parentUUID&quot;:&quot;574f6cfe-13b4-4d4e-b2a8-34a600bc78db&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when public minting of spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should successfully when public minting of spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4996,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst { registrationResults } = await client.ipAsset.batchMintAndRegisterIp({\n    requests: [\n        { spgNftContract: spgNftContractWithPublicMinting },\n        { spgNftContract: spgNftContractWithPublicMinting, recipient: anotherWalletAddress },\n        { spgNftContract: spgNftContractWithPublicMinting, allowDuplicates: false },\n    ],\n});\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(registrationResults.length).equal(1);\n(0, chai_1.expect)(registrationResults[0].ipIdsAndTokenIds.length).equal(3);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6eeadb79-a11f-4f5c-bc91-dcb658d9d752&quot;,&quot;parentUUID&quot;:&quot;574f6cfe-13b4-4d4e-b2a8-34a600bc78db&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when private minting of spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should successfully when private minting of spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9397,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst { registrationResults } = await client.ipAsset.batchMintAndRegisterIp({\n    requests: [\n        { spgNftContract: spgNftContractWithPrivateMinting },\n        { spgNftContract: spgNftContractWithPrivateMinting, recipient: anotherWalletAddress },\n        {\n            spgNftContract: spgNftContractWithPrivateMinting,\n            allowDuplicates: false,\n            recipient: anotherWalletAddress,\n        },\n    ],\n});\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(registrationResults.length).equal(1);\n(0, chai_1.expect)(registrationResults[0].ipIdsAndTokenIds.length).equal(3);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1af439b7-7eba-45e7-832d-9c37cc57e705&quot;,&quot;parentUUID&quot;:&quot;574f6cfe-13b4-4d4e-b2a8-34a600bc78db&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when hybrid private minting and public minting of spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should successfully when hybrid private minting and public minting of spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9580,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst { registrationResults } = await client.ipAsset.batchMintAndRegisterIp({\n    requests: [\n        { spgNftContract: spgNftContractWithPublicMinting },\n        { spgNftContract: spgNftContractWithPrivateMinting, recipient: anotherWalletAddress },\n        { spgNftContract: spgNftContractWithPrivateMinting, allowDuplicates: false },\n        { spgNftContract: spgNftContractWithPublicMinting, recipient: anotherWalletAddress },\n    ],\n});\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(registrationResults.length).equal(2);\n(0, chai_1.expect)(registrationResults[0].ipIdsAndTokenIds.length).equal(2);\n(0, chai_1.expect)(registrationResults[1].ipIdsAndTokenIds.length).equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5764d2fe-8a15-4e93-8678-00bc7c6a87a0&quot;,&quot;parentUUID&quot;:&quot;574f6cfe-13b4-4d4e-b2a8-34a600bc78db&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when private minting of spgNftContract but caller does not have the minter role&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should fail when private minting of spgNftContract but caller does not have the minter role&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4526,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Register a new SPG NFT contract with private minting with clientB\nconst { address, clientB } = await (0, BIP32_1.getDerivedStoryClient)();\nconst { spgNftContract: privateMintingContractOfClientB } = await clientB.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: address,\n    contractURI: \&quot;test-uri\&quot;,\n});\nawait (0, chai_1.expect)(client.ipAsset.batchMintAndRegisterIp({\n    requests: [{ spgNftContract: privateMintingContractOfClientB }],\n})).to.be.rejectedWith(\&quot;does not have the minter role\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b9efb846-9e6a-40b1-a8f0-380a025faf54&quot;,&quot;parentUUID&quot;:&quot;574f6cfe-13b4-4d4e-b2a8-34a600bc78db&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;6eeadb79-a11f-4f5c-bc91-dcb658d9d752&quot;,&quot;1af439b7-7eba-45e7-832d-9c37cc57e705&quot;,&quot;5764d2fe-8a15-4e93-8678-00bc7c6a87a0&quot;,&quot;b9efb846-9e6a-40b1-a8f0-380a025faf54&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:28499,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;2443e238-9fb2-48a0-abee-4ed6ad854ad9&quot;,&quot;title&quot;:&quot;Register ip asset with minted and mint nft&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;afca3c6b-089a-43dc-ad7b-4902cf4daa36&quot;,&quot;title&quot;:&quot;Register IP Asset with Minted NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give license terms data and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when give license terms data and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13723,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 2.000000001,\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds.length).to.be.equal(1);\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5db6c445-90c6-44fc-ab52-ebb6ff09049c&quot;,&quot;parentUUID&quot;:&quot;afca3c6b-089a-43dc-ad7b-4902cf4daa36&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give license terms data without royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when give license terms data without royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9145,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;383be235-6875-4b81-9853-3705e28a67ca&quot;,&quot;parentUUID&quot;:&quot;afca3c6b-089a-43dc-ad7b-4902cf4daa36&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when without license terms data, royalty shares, ip metadata&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when without license terms data, royalty shares, ip metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8694,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8d3afda4-cf84-40ff-bd8e-08a680182c06&quot;,&quot;parentUUID&quot;:&quot;afca3c6b-089a-43dc-ad7b-4902cf4daa36&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when without license terms data and royalty shares, with ip metadata&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when without license terms data and royalty shares, with ip metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8739,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataURI: \&quot;test-nft-uri\&quot;,\n    },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;60a4b873-cecb-4a3d-882d-d68be0c2d4ce&quot;,&quot;parentUUID&quot;:&quot;afca3c6b-089a-43dc-ad7b-4902cf4daa36&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;5db6c445-90c6-44fc-ab52-ebb6ff09049c&quot;,&quot;383be235-6875-4b81-9853-3705e28a67ca&quot;,&quot;8d3afda4-cf84-40ff-bd8e-08a680182c06&quot;,&quot;60a4b873-cecb-4a3d-882d-d68be0c2d4ce&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:40301,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;85766e0a-b9fa-49c1-87fe-42baf9cfe78d&quot;,&quot;title&quot;:&quot;Register IP Asset by minting a new NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Register IP Asset by minting a new NFT\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT \&quot;before all\&quot; hook in \&quot;Register IP Asset by minting a new NFT\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4316,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST_FOR_MINT\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a732c395-4e21-4300-8bd6-25945cf997ae&quot;,&quot;parentUUID&quot;:&quot;85766e0a-b9fa-49c1-87fe-42baf9cfe78d&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give license terms data and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT should successfully when give license terms data and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13925,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgNftContract },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 0.000001,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4aeba963-4472-4c7f-be7c-1b4b99930ea1&quot;,&quot;parentUUID&quot;:&quot;85766e0a-b9fa-49c1-87fe-42baf9cfe78d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give license terms data without royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT should successfully when give license terms data without royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9563,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgNftContract },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ac51e0b1-81a7-45a8-b5c0-19d27da7ce6b&quot;,&quot;parentUUID&quot;:&quot;85766e0a-b9fa-49c1-87fe-42baf9cfe78d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when without license terms data and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT should successfully when without license terms data and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8993,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgNftContract },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataURI: \&quot;test-nft-uri\&quot;,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;32889445-66ef-4b7f-922e-166407a5c7eb&quot;,&quot;parentUUID&quot;:&quot;85766e0a-b9fa-49c1-87fe-42baf9cfe78d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;4aeba963-4472-4c7f-be7c-1b4b99930ea1&quot;,&quot;ac51e0b1-81a7-45a8-b5c0-19d27da7ce6b&quot;,&quot;32889445-66ef-4b7f-922e-166407a5c7eb&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:32481,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;16a5c21d-900d-4a79-b902-54d312bdc362&quot;,&quot;title&quot;:&quot;Register derivative IP Asset&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Register derivative IP Asset\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset \&quot;before all\&quot; hook in \&quot;Register derivative IP Asset\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9021,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\nparentIpId = result.ipId;\ncommercialRemixLicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;efbca050-6d6a-46b7-b17f-42314cb46ac1&quot;,&quot;parentUUID&quot;:&quot;16a5c21d-900d-4a79-b902-54d312bdc362&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;919e4e8b-56ed-487f-bbd1-2b677e9973af&quot;,&quot;title&quot;:&quot;Register derivative IP Asset with Minted NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give derivData and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset with Minted NFT should successfully when give derivData and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17961,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.equal(BigInt(tokenId));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1154158f-d3bf-4d07-9ede-f336ee41d1ca&quot;,&quot;parentUUID&quot;:&quot;919e4e8b-56ed-487f-bbd1-2b677e9973af&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully given derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset with Minted NFT should successfully given derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17552,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.equal(BigInt(tokenId));\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;089b033a-69f4-4757-8378-ace5a1837bde&quot;,&quot;parentUUID&quot;:&quot;919e4e8b-56ed-487f-bbd1-2b677e9973af&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully given licenseTokenIds and maxRts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset with Minted NFT should successfully given licenseTokenIds and maxRts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22079,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: commercialRemixLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nconst tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    licenseTokenIds: licenseTokenIds,\n    maxRts: 100,\n    maxMintingFee: 10000n,\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.equal(BigInt(tokenId));\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a5953bd6-0642-47e6-b3ec-e757b91de74c&quot;,&quot;parentUUID&quot;:&quot;919e4e8b-56ed-487f-bbd1-2b677e9973af&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1154158f-d3bf-4d07-9ede-f336ee41d1ca&quot;,&quot;089b033a-69f4-4757-8378-ace5a1837bde&quot;,&quot;a5953bd6-0642-47e6-b3ec-e757b91de74c&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:57592,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;de002a9b-36fc-4fc2-86a8-94ce29bc1ffa&quot;,&quot;title&quot;:&quot;Register derivative IP Asset by minting a new NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Register derivative IP Asset by minting a new NFT\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT \&quot;before all\&quot; hook in \&quot;Register derivative IP Asset by minting a new NFT\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4308,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST_FOR_MINT\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cb4f500d-4352-4d64-b3f6-6f354ed4d282&quot;,&quot;parentUUID&quot;:&quot;de002a9b-36fc-4fc2-86a8-94ce29bc1ffa&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give derivData and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT should successfully when give derivData and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13597,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 1.23,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;74e259f2-7854-4ab1-9ca1-9e532aef1c2a&quot;,&quot;parentUUID&quot;:&quot;de002a9b-36fc-4fc2-86a8-94ce29bc1ffa&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give licenseTokenIds and maxRts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT should successfully when give licenseTokenIds and maxRts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18022,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: commercialRemixLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract },\n    licenseTokenIds: licenseTokenIds,\n    maxRts: 100,\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7f450843-8272-415b-baa3-a2bfbda6c860&quot;,&quot;parentUUID&quot;:&quot;de002a9b-36fc-4fc2-86a8-94ce29bc1ffa&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT should successfully when give derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9540,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b978296e-4b5b-4d46-97ae-b65ca9c20d0d&quot;,&quot;parentUUID&quot;:&quot;de002a9b-36fc-4fc2-86a8-94ce29bc1ffa&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;74e259f2-7854-4ab1-9ca1-9e532aef1c2a&quot;,&quot;7f450843-8272-415b-baa3-a2bfbda6c860&quot;,&quot;b978296e-4b5b-4d46-97ae-b65ca9c20d0d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:41159,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;e9aaae76-aa7b-4f45-9587-b7a6de1e782f&quot;,&quot;title&quot;:&quot;Link Derivative&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give childIpId and licenseTokenIds&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative should successfully when give childIpId and licenseTokenIds&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:35158,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst { parentIpId, licenseTermsId } = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a8a13986-80c1-4183-8b0d-a6e66ca29c78&quot;,&quot;parentUUID&quot;:&quot;e9aaae76-aa7b-4f45-9587-b7a6de1e782f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;a4695c71-b916-4a90-82bb-e951d090187f&quot;,&quot;title&quot;:&quot;parentIpId and licenseTermsId&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully give ERC20 token&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative parentIpId and licenseTermsId should successfully give ERC20 token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30974,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// 1. register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// 2. create parent ip and license terms for ERC20\nconst parentIpIdAndLicenseTermsIdForERC20 = await createParentIpAndLicenseTerms(client, generated_1.erc20Address[util_1.aeneid]);\n// 3. link derivative\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpIdAndLicenseTermsIdForERC20.parentIpId],\n    licenseTermsIds: [parentIpIdAndLicenseTermsIdForERC20.licenseTermsId],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ca7dbf6e-72e2-4745-93da-79e76e0032c0&quot;,&quot;parentUUID&quot;:&quot;a4695c71-b916-4a90-82bb-e951d090187f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully give sufficient WIP token&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative parentIpId and licenseTermsId should successfully give sufficient WIP token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:35518,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// 1. deposit 100 WIP token\nawait client.wipClient.deposit({\n    amount: 100n,\n});\n// 2. register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// 3. create parent ip and license terms for WIP\nconst parentIpIdAndLicenseTermsIdForWIP = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\n// 4. link derivative\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpIdAndLicenseTermsIdForWIP.parentIpId],\n    licenseTermsIds: [parentIpIdAndLicenseTermsIdForWIP.licenseTermsId],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n// 5. withdraw all WIP token\nconst wipBalance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nawait client.wipClient.withdraw({\n    amount: wipBalance,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8ff8d4a5-5dfd-48ab-bc26-1bdd69d68ff5&quot;,&quot;parentUUID&quot;:&quot;a4695c71-b916-4a90-82bb-e951d090187f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully give insufficient WIP token&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative parentIpId and licenseTermsId should successfully give insufficient WIP token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22563,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// 1. register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// 2. create parent ip and license terms for WIP\nconst parentIpIdAndLicenseTermsIdForWIP = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\n// 3. link derivative\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpIdAndLicenseTermsIdForWIP.parentIpId],\n    licenseTermsIds: [parentIpIdAndLicenseTermsIdForWIP.licenseTermsId],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;058d7fd3-c736-4bea-ad6c-9929ec0ed6de&quot;,&quot;parentUUID&quot;:&quot;a4695c71-b916-4a90-82bb-e951d090187f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully give wip token with insufficient balance and sufficient erc20 token&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative parentIpId and licenseTermsId should successfully give wip token with insufficient balance and sufficient erc20 token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:36606,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;//1. register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// 2. create parent ip and license terms for WIP\nconst parentIpIdAndLicenseTermsIdForWIP1 = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\nconst parentIpIdAndLicenseTermsIdForERC20 = await createParentIpAndLicenseTerms(client, generated_1.erc20Address[util_1.aeneid]);\n// 3. link derivative\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [\n        parentIpIdAndLicenseTermsIdForWIP1.parentIpId,\n        parentIpIdAndLicenseTermsIdForERC20.parentIpId,\n    ],\n    licenseTermsIds: [\n        parentIpIdAndLicenseTermsIdForWIP1.licenseTermsId,\n        parentIpIdAndLicenseTermsIdForERC20.licenseTermsId,\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bcc467c3-e37f-4a06-999e-cb50491343b3&quot;,&quot;parentUUID&quot;:&quot;a4695c71-b916-4a90-82bb-e951d090187f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully give wip token with sufficient balance and sufficient erc20 token&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative parentIpId and licenseTermsId should successfully give wip token with sufficient balance and sufficient erc20 token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:53305,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// 1. deposit 100 WIP token\nawait client.wipClient.deposit({\n    amount: 100n,\n});\n// 2. register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// 3. create parent ip and license terms for WIP\nconst parentIpIdAndLicenseTermsIdForWIP1 = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\n// 4. create parent ip and license terms for ERC20\nconst parentIpIdAndLicenseTermsIdForERC20 = await createParentIpAndLicenseTerms(client, generated_1.erc20Address[util_1.aeneid]);\n// 5. link derivative\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [\n        parentIpIdAndLicenseTermsIdForWIP1.parentIpId,\n        parentIpIdAndLicenseTermsIdForERC20.parentIpId,\n    ],\n    licenseTermsIds: [\n        parentIpIdAndLicenseTermsIdForWIP1.licenseTermsId,\n        parentIpIdAndLicenseTermsIdForERC20.licenseTermsId,\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n// 6. withdraw all WIP token\nconst wipBalance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nawait client.wipClient.withdraw({\n    amount: wipBalance,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;72d90fab-ce21-42d9-8a18-1193c4695fee&quot;,&quot;parentUUID&quot;:&quot;a4695c71-b916-4a90-82bb-e951d090187f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully give wip token with insufficient balance and sufficient erc20 token and useMulticallWhenPossible is false&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative parentIpId and licenseTermsId should successfully give wip token with insufficient balance and sufficient erc20 token and useMulticallWhenPossible is false&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:57813,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// 1. register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// 2. create parent ip and license terms for WIP\nconst parentIpIdAndLicenseTermsIdForWIP1 = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\n// 3. create parent ip and license terms for ERC20\nconst parentIpIdAndLicenseTermsIdForERC20 = await createParentIpAndLicenseTerms(client, generated_1.erc20Address[util_1.aeneid]);\n// 4. link derivative\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [\n        parentIpIdAndLicenseTermsIdForWIP1.parentIpId,\n        parentIpIdAndLicenseTermsIdForERC20.parentIpId,\n    ],\n    licenseTermsIds: [\n        parentIpIdAndLicenseTermsIdForWIP1.licenseTermsId,\n        parentIpIdAndLicenseTermsIdForERC20.licenseTermsId,\n    ],\n    options: {\n        wipOptions: {\n            useMulticallWhenPossible: false,\n        },\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3a6007ea-16eb-4493-9e43-e2d31af47e13&quot;,&quot;parentUUID&quot;:&quot;a4695c71-b916-4a90-82bb-e951d090187f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;ca7dbf6e-72e2-4745-93da-79e76e0032c0&quot;,&quot;8ff8d4a5-5dfd-48ab-bc26-1bdd69d68ff5&quot;,&quot;058d7fd3-c736-4bea-ad6c-9929ec0ed6de&quot;,&quot;bcc467c3-e37f-4a06-999e-cb50491343b3&quot;,&quot;72d90fab-ce21-42d9-8a18-1193c4695fee&quot;,&quot;3a6007ea-16eb-4493-9e43-e2d31af47e13&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:236779,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;a8a13986-80c1-4183-8b0d-a6e66ca29c78&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:35158,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;f2b4b4ca-ddca-4b81-a690-c1539e837c7c&quot;,&quot;title&quot;:&quot;with ERC20 and WIP token fee&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;with ERC20 and WIP token fee\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee \&quot;before all\&quot; hook in \&quot;with ERC20 and WIP token fee\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:22667,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;spgContractWith100WIP = (await client.nftClient.createNFTCollection({\n    name: \&quot;100 WIP\&quot;,\n    symbol: \&quot;100WIP\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 100n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \&quot;\&quot;,\n})).spgNftContract;\nspgContractWith10ERC20 = (await client.nftClient.createNFTCollection({\n    name: \&quot;10 ERC20\&quot;,\n    symbol: \&quot;10ERC20\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 100n,\n    mintFeeToken: generated_1.erc20Address[util_1.aeneid],\n    contractURI: \&quot;\&quot;,\n})).spgNftContract;\nconst result1 = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10n,\n                commercialRevShare: 10,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\nparentIpIdForWIP = result1.ipId;\nlicenseTermsIdFor100WIP = result1.licenseTermsIds[0];\nconst result2 = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10n,\n                commercialRevShare: 10,\n                currency: generated_1.erc20Address[util_1.aeneid],\n            }),\n        },\n    ],\n});\nparentIpIdForERC20 = result2.ipId;\nlicenseTermsIdFor10ERC20 = result2.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;970a3fff-9585-4420-9d5e-74072768bb21&quot;,&quot;parentUUID&quot;:&quot;f2b4b4ca-ddca-4b81-a690-c1539e837c7c&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;25eb5a29-ff9f-40e6-9d5b-2d2de4a0000f&quot;,&quot;title&quot;:&quot;SpgNftContract with ERC20 token&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when register ip with license terms data and royalty shares for ERC20&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register ip with license terms data and royalty shares for ERC20&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5393,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licenseTermsId: licenseTermsIdFor10ERC20,\n        },\n        {\n            licenseTermsId: licenseTermsIdFor10ERC20,\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8ccac1ca-f68b-4bfc-a54a-2a09882f58df&quot;,&quot;parentUUID&quot;:&quot;25eb5a29-ff9f-40e6-9d5b-2d2de4a0000f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register ip with license terms data&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register ip with license terms data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4811,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    licenseTermsData: [\n        {\n            licenseTermsId: licenseTermsIdFor10ERC20,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;097c1575-f2f3-4b78-aa3b-d2c09b19eb32&quot;,&quot;parentUUID&quot;:&quot;25eb5a29-ff9f-40e6-9d5b-2d2de4a0000f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register ip with spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register ip with spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8572,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;10e868fc-a531-4631-8e9c-d32d2c77ca19&quot;,&quot;parentUUID&quot;:&quot;25eb5a29-ff9f-40e6-9d5b-2d2de4a0000f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with derivData and royalty shares for ERC20&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register derivative ip with derivData and royalty shares for ERC20&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4996,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForERC20],\n        licenseTermsIds: [licenseTermsIdFor10ERC20],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c36614dd-3463-405c-8d91-9d33d3119691&quot;,&quot;parentUUID&quot;:&quot;25eb5a29-ff9f-40e6-9d5b-2d2de4a0000f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with license token ids and derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register derivative ip with license token ids and derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9547,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsIdFor10ERC20,\n    licensorIpId: parentIpIdForERC20,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForERC20],\n        licenseTermsIds: [licenseTermsIdFor10ERC20],\n    },\n    licenseTokenIds: licenseTokenIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fadae97c-20a9-409b-bf50-c0c61856373e&quot;,&quot;parentUUID&quot;:&quot;25eb5a29-ff9f-40e6-9d5b-2d2de4a0000f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when register derivative ip with derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4909,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForERC20],\n        licenseTermsIds: [licenseTermsIdFor10ERC20],\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6555f61f-cce9-4766-a4ed-83695400bc89&quot;,&quot;parentUUID&quot;:&quot;25eb5a29-ff9f-40e6-9d5b-2d2de4a0000f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when link derivative ip given childIpId and license token ids&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when link derivative ip given childIpId and license token ids&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17765,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpIdForERC20],\n    licenseTermsIds: [licenseTermsIdFor10ERC20],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9d2c8b96-4e5a-47ef-9aa0-a3a2b2ce9b13&quot;,&quot;parentUUID&quot;:&quot;25eb5a29-ff9f-40e6-9d5b-2d2de4a0000f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when batch register derivatives&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with ERC20 token should successfully when batch register derivatives&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:53656,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst childIpId1 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n})).ipId;\nconst childIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId2,\n})).ipId;\nconst { parentIpId: parentIpId1, licenseTermsId: licenseTermsId1 } = await createParentIpAndLicenseTerms(client, generated_1.erc20Address[util_1.aeneid]);\nconst { parentIpId: parentIpId2, licenseTermsId: licenseTermsId2 } = await createParentIpAndLicenseTerms(client, generated_1.erc20Address[util_1.aeneid]);\nconst result = await client.ipAsset.batchRegisterDerivatives({\n    requests: [\n        {\n            childIpId: childIpId1,\n            parentIpIds: [parentIpId1, parentIpId2],\n            licenseTermsIds: [licenseTermsId1, licenseTermsId2],\n        },\n        {\n            childIpId: childIpId2,\n            parentIpIds: [parentIpIdForERC20],\n            licenseTermsIds: [licenseTermsIdFor10ERC20],\n        },\n    ],\n});\n(0, chai_1.expect)(result.length).to.equal(2);\n(0, chai_1.expect)(result[0]).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;96c22755-664d-4791-9d37-6afd0dc3ac5c&quot;,&quot;parentUUID&quot;:&quot;25eb5a29-ff9f-40e6-9d5b-2d2de4a0000f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;8ccac1ca-f68b-4bfc-a54a-2a09882f58df&quot;,&quot;097c1575-f2f3-4b78-aa3b-d2c09b19eb32&quot;,&quot;10e868fc-a531-4631-8e9c-d32d2c77ca19&quot;,&quot;c36614dd-3463-405c-8d91-9d33d3119691&quot;,&quot;fadae97c-20a9-409b-bf50-c0c61856373e&quot;,&quot;6555f61f-cce9-4766-a4ed-83695400bc89&quot;,&quot;9d2c8b96-4e5a-47ef-9aa0-a3a2b2ce9b13&quot;,&quot;96c22755-664d-4791-9d37-6afd0dc3ac5c&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:109649,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;bfe76aff-a2cc-4cd3-a266-88e85ef0770d&quot;,&quot;title&quot;:&quot;SpgNftContract with WIP token&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when register ip with license terms data and royalty shares for WIP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register ip with license terms data and royalty shares for WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13804,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n        {\n            licenseTermsId: licenseTermsIdFor100WIP,\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bbbad200-0ebb-45d7-be88-ad2427612d6d&quot;,&quot;parentUUID&quot;:&quot;bfe76aff-a2cc-4cd3-a266-88e85ef0770d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register ip with license terms data&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register ip with license terms data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4920,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 100n,\n                commercialRevShare: 10,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c3f28b82-cf0b-4e94-b42c-52b104b0c2de&quot;,&quot;parentUUID&quot;:&quot;bfe76aff-a2cc-4cd3-a266-88e85ef0770d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register ip with spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register ip with spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8877,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cf5fbf7f-d892-4357-874d-22fc7d7c265d&quot;,&quot;parentUUID&quot;:&quot;bfe76aff-a2cc-4cd3-a266-88e85ef0770d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with derivData and royalty shares for WIP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register derivative ip with derivData and royalty shares for WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5021,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10.232132,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2e696a9a-6bda-409f-83c3-b87d9c8cf251&quot;,&quot;parentUUID&quot;:&quot;bfe76aff-a2cc-4cd3-a266-88e85ef0770d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with license token ids and derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register derivative ip with license token ids and derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9747,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsIdFor100WIP,\n    licensorIpId: parentIpIdForWIP,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n    licenseTokenIds: licenseTokenIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;84f269ec-53d2-44ba-9a61-f1d0e59e0fce&quot;,&quot;parentUUID&quot;:&quot;bfe76aff-a2cc-4cd3-a266-88e85ef0770d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when register derivative ip with derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5014,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith100WIP },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3ac9a944-6a75-4215-b579-ba10f08726c9&quot;,&quot;parentUUID&quot;:&quot;bfe76aff-a2cc-4cd3-a266-88e85ef0770d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when link derivative ip given childIpId and license token ids&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when link derivative ip given childIpId and license token ids&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13394,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpIdForWIP],\n    licenseTermsIds: [licenseTermsIdFor100WIP],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;72d4880a-6e66-4706-aeb2-24dee26e466b&quot;,&quot;parentUUID&quot;:&quot;bfe76aff-a2cc-4cd3-a266-88e85ef0770d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when batch register derivatives&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee SpgNftContract with WIP token should successfully when batch register derivatives&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:40795,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst registerResponse = await client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId1,\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2,\n        },\n    ],\n});\nconst childIpId1 = registerResponse.results[0]?.ipId;\nconst childIpId2 = registerResponse.results[1]?.ipId;\nconst { parentIpId: parentIpId1, licenseTermsId: licenseTermsId1 } = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\nconst { parentIpId: parentIpId2, licenseTermsId: licenseTermsId2 } = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\nconst result = await client.ipAsset.batchRegisterDerivatives({\n    requests: [\n        {\n            childIpId: childIpId1,\n            parentIpIds: [parentIpId1, parentIpId2],\n            licenseTermsIds: [licenseTermsId1, licenseTermsId2],\n        },\n        {\n            childIpId: childIpId2,\n            parentIpIds: [parentIpIdForWIP],\n            licenseTermsIds: [licenseTermsIdFor100WIP],\n        },\n    ],\n});\n(0, chai_1.expect)(result.length).to.equal(2);\n(0, chai_1.expect)(result[0]).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result[1]).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1e437fd5-61f1-465b-9644-e12647c1774d&quot;,&quot;parentUUID&quot;:&quot;bfe76aff-a2cc-4cd3-a266-88e85ef0770d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;bbbad200-0ebb-45d7-be88-ad2427612d6d&quot;,&quot;c3f28b82-cf0b-4e94-b42c-52b104b0c2de&quot;,&quot;cf5fbf7f-d892-4357-874d-22fc7d7c265d&quot;,&quot;2e696a9a-6bda-409f-83c3-b87d9c8cf251&quot;,&quot;84f269ec-53d2-44ba-9a61-f1d0e59e0fce&quot;,&quot;3ac9a944-6a75-4215-b579-ba10f08726c9&quot;,&quot;72d4880a-6e66-4706-aeb2-24dee26e466b&quot;,&quot;1e437fd5-61f1-465b-9644-e12647c1774d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:101572,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;c583b014-184e-4cef-adb4-5f03bd3dc5ad&quot;,&quot;title&quot;:&quot;Mixed ERC20 and WIP token&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when register derivative ip with derivData and royalty shares for mixed ERC20 and WIP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee Mixed ERC20 and WIP token should successfully when register derivative ip with derivData and royalty shares for mixed ERC20 and WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9351,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;576becb5-9f1c-4a1a-b1dd-42759c8167c3&quot;,&quot;parentUUID&quot;:&quot;c583b014-184e-4cef-adb4-5f03bd3dc5ad&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when register derivative ip with license token ids and derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee Mixed ERC20 and WIP token should successfully when register derivative ip with license token ids and derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18160,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsIdFor100WIP,\n    licensorIpId: parentIpIdForWIP,\n    maxMintingFee: 0,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgContractWith10ERC20 },\n    derivData: {\n        parentIpIds: [parentIpIdForWIP],\n        licenseTermsIds: [licenseTermsIdFor100WIP],\n    },\n    licenseTokenIds: licenseTokenIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0deb704e-79a4-44ea-8155-ccbc92132bb4&quot;,&quot;parentUUID&quot;:&quot;c583b014-184e-4cef-adb4-5f03bd3dc5ad&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when batch register derivatives&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions with ERC20 and WIP token fee Mixed ERC20 and WIP token should successfully when batch register derivatives&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:58276,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst registerResponse = await client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId1,\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2,\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId3,\n        },\n    ],\n});\nconst childIpId1 = registerResponse.results[0]?.ipId;\nconst childIpId2 = registerResponse.results[1]?.ipId;\nconst childIpId3 = registerResponse.results[2]?.ipId;\nconst { parentIpId: parentIpId1, licenseTermsId: licenseTermsId1 } = await createParentIpAndLicenseTerms(client, generated_1.erc20Address[util_1.aeneid]);\nconst { parentIpId: parentIpId2, licenseTermsId: licenseTermsId2 } = await createParentIpAndLicenseTerms(client, common_1.WIP_TOKEN_ADDRESS);\nconst result = await client.ipAsset.batchRegisterDerivatives({\n    requests: [\n        {\n            childIpId: childIpId1,\n            parentIpIds: [parentIpId1, parentIpId2],\n            licenseTermsIds: [licenseTermsId1, licenseTermsId2],\n        },\n        {\n            childIpId: childIpId2,\n            parentIpIds: [parentIpIdForWIP],\n            licenseTermsIds: [licenseTermsIdFor100WIP],\n        },\n        {\n            childIpId: childIpId3,\n            parentIpIds: [parentIpIdForWIP],\n            licenseTermsIds: [licenseTermsIdFor100WIP],\n        },\n    ],\n});\n(0, chai_1.expect)(result.length).to.equal(3);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;70b36969-85d7-4cd6-9ad6-a0f7adf46cce&quot;,&quot;parentUUID&quot;:&quot;c583b014-184e-4cef-adb4-5f03bd3dc5ad&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;576becb5-9f1c-4a1a-b1dd-42759c8167c3&quot;,&quot;0deb704e-79a4-44ea-8155-ccbc92132bb4&quot;,&quot;70b36969-85d7-4cd6-9ad6-a0f7adf46cce&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:85787,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;e17e18da-fc7c-4239-a361-1447d92df794&quot;,&quot;title&quot;:&quot;License Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;License Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions \&quot;before all\&quot; hook in \&quot;License Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:48,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nclientB = derivedClient.clientB;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e17d1ea5-28a1-4d41-9f92-89dd69c6e7c7&quot;,&quot;parentUUID&quot;:&quot;e17e18da-fc7c-4239-a361-1447d92df794&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;4e8d18fc-25d5-46fb-97ac-1f0349e661ef&quot;,&quot;title&quot;:&quot;register license with different types&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register license &quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license &quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:58,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerPILTerms({\n    defaultMintingFee: 0,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    transferable: false,\n    royaltyPolicy: viem_1.zeroAddress,\n    commercialUse: false,\n    commercialAttribution: false,\n    commercializerChecker: viem_1.zeroAddress,\n    commercializerCheckerData: \&quot;0x\&quot;,\n    commercialRevShare: 0,\n    derivativesAllowed: false,\n    derivativesAttribution: false,\n    derivativesApproval: false,\n    derivativesReciprocal: false,\n    uri: \&quot;\&quot;,\n    expiration: 0,\n    commercialRevCeiling: 0,\n    derivativeRevCeiling: 0,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d754b5f1-e1ef-41b1-a621-5fcd3a114816&quot;,&quot;parentUUID&quot;:&quot;4e8d18fc-25d5-46fb-97ac-1f0349e661ef&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with non commercial social remixing PIL&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with non commercial social remixing PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:43,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerNonComSocialRemixingPIL();\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fb671111-2970-45e0-a737-5f3decfa5b17&quot;,&quot;parentUUID&quot;:&quot;4e8d18fc-25d5-46fb-97ac-1f0349e661ef&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with commercial use&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with commercial use&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:40,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerCommercialUsePIL({\n    defaultMintingFee: \&quot;1\&quot;,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;94ab3fb8-b8d7-4c62-b746-3879bb8d011c&quot;,&quot;parentUUID&quot;:&quot;4e8d18fc-25d5-46fb-97ac-1f0349e661ef&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with commercial Remix use&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with commercial Remix use&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:40,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerCommercialRemixPIL({\n    defaultMintingFee: \&quot;1\&quot;,\n    commercialRevShare: 100,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b91fa7e7-fcdc-4b49-b54d-5b9b563562cc&quot;,&quot;parentUUID&quot;:&quot;4e8d18fc-25d5-46fb-97ac-1f0349e661ef&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register license with creative commons attribution PIL&quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license with creative commons attribution PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:41,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerCreativeCommonsAttributionPIL({\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicyAddress: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6ad425b8-54ec-465c-b9ae-c51c3869f23a&quot;,&quot;parentUUID&quot;:&quot;4e8d18fc-25d5-46fb-97ac-1f0349e661ef&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;d754b5f1-e1ef-41b1-a621-5fcd3a114816&quot;,&quot;fb671111-2970-45e0-a737-5f3decfa5b17&quot;,&quot;94ab3fb8-b8d7-4c62-b746-3879bb8d011c&quot;,&quot;b91fa7e7-fcdc-4b49-b54d-5b9b563562cc&quot;,&quot;6ad425b8-54ec-465c-b9ae-c51c3869f23a&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:222,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;974fb0b6-908b-4a07-8cd0-9f933b014066&quot;,&quot;title&quot;:&quot;attach License Terms and mint license tokens&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;attach License Terms and mint license tokens\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens \&quot;before all\&quot; hook in \&quot;attach License Terms and mint license tokens\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8882,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;tokenId = await (0, util_1.getTokenId)();\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nconst mockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\nawait mockERC20.approve(generated_1.licensingModuleAddress[util_1.aeneid], viem_1.maxUint256);\nipId = registerResult.ipId;\nconst registerLicenseResult = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 0n,\n    commercialRevShare: 100,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n}));\nlicenseId = registerLicenseResult.licenseTermsId;\nconst paidLicenseResult = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 100n,\n    commercialRevShare: 10,\n    currency: generated_1.erc20Address[util_1.aeneid],\n}));\npaidLicenseId = paidLicenseResult.licenseTermsId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;924d2cdd-fda2-457d-82d2-8cffd20703b7&quot;,&quot;parentUUID&quot;:&quot;974fb0b6-908b-4a07-8cd0-9f933b014066&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should attach License Terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should attach License Terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4416,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;13fe9304-833c-4ef5-9964-21a9e91cfed4&quot;,&quot;parentUUID&quot;:&quot;974fb0b6-908b-4a07-8cd0-9f933b014066&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should be able to attach another license terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should be able to attach another license terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4420,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: paidLicenseId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7b23a316-e5f3-483f-9fc6-660fc3b9daa1&quot;,&quot;parentUUID&quot;:&quot;974fb0b6-908b-4a07-8cd0-9f933b014066&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license tokens with ip owner&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license tokens with ip owner&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4505,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseId,\n    licensorIpId: ipId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3a30954d-a32e-44f8-9902-507c3e80e105&quot;,&quot;parentUUID&quot;:&quot;974fb0b6-908b-4a07-8cd0-9f933b014066&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license tokens with non ip owner&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license tokens with non ip owner&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17683,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// register ip with another wallet account\nconst tokenIdB = await (0, util_1.getTokenId)();\nconst registerResult = await clientB.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenIdB,\n});\nconst ipIdB = registerResult.ipId;\n// attach license terms to the ip\nawait client.license.attachLicenseTerms({\n    ipId: ipIdB,\n    licenseTermsId: licenseId,\n});\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseId,\n    licensorIpId: ipIdB,\n    maxMintingFee: 10000000,\n    maxRevenueShare: 100,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3eec469f-a9b8-4969-905f-2026a5a6c885&quot;,&quot;parentUUID&quot;:&quot;974fb0b6-908b-4a07-8cd0-9f933b014066&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license token with default license terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license token with default license terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4570,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// get default license terms id\nconst licenseRegistryReadOnlyClient = new generated_1.LicenseRegistryReadOnlyClient(util_1.publicClient);\nconst { licenseTermsId: defaultLicenseTermsId } = await licenseRegistryReadOnlyClient.getDefaultLicenseTerms();\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: defaultLicenseTermsId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 1,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;db859e35-61ed-4dc1-b6c1-0a63fda0f17a&quot;,&quot;parentUUID&quot;:&quot;974fb0b6-908b-4a07-8cd0-9f933b014066&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license tokens with fee and pay with IP&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license tokens with fee and pay with IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4648,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const balanceBefore = await client.getWalletBalance();\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: paidLicenseId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 50,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 100n));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c4942cf6-eb17-4a44-bfee-ce568bdbd80a&quot;,&quot;parentUUID&quot;:&quot;974fb0b6-908b-4a07-8cd0-9f933b014066&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should get license terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should get license terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:42,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.getLicenseTerms(licenseId);\n(0, chai_1.expect)(result).to.be.an(\&quot;object\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4dfff88e-ca5c-469d-b3d3-6d1d6f914834&quot;,&quot;parentUUID&quot;:&quot;974fb0b6-908b-4a07-8cd0-9f933b014066&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should predict minting license fee&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should predict minting license fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:124,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.predictMintingLicenseFee({\n    licenseTermsId: licenseId,\n    licensorIpId: ipId,\n    amount: 1,\n});\n(0, chai_1.expect)(result.currencyToken).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenAmount).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c547e167-50cb-4174-9f1b-c604ddbb9573&quot;,&quot;parentUUID&quot;:&quot;974fb0b6-908b-4a07-8cd0-9f933b014066&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;47d6715d-a3f0-4f65-a3ef-3cf713d11c8c&quot;,&quot;title&quot;:&quot;licensing config and max license tokens&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should set licensing config&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens licensing config and max license tokens should set licensing config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4383,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.setLicensingConfig({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n    licensingConfig,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;25becb20-1de2-4c05-b7a6-ef5fabaed6b1&quot;,&quot;parentUUID&quot;:&quot;47d6715d-a3f0-4f65-a3ef-3cf713d11c8c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should get licensing config&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens licensing config and max license tokens should get licensing config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:40,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.getLicensingConfig({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n});\n(0, chai_1.expect)(result).to.deep.equal({\n    ...licensingConfig,\n    expectMinimumGroupRewardShare: 1 * 10 ** 6,\n    commercialRevShare: 100 * 10 ** 6,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;da4094cf-fe59-469a-a991-47739cc24745&quot;,&quot;parentUUID&quot;:&quot;47d6715d-a3f0-4f65-a3ef-3cf713d11c8c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should set max license tokens&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens licensing config and max license tokens should set max license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8757,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.setMaxLicenseTokens({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n    maxLicenseTokens: 100,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3cc4e7df-814f-4a67-8abb-86a3f4b5c40e&quot;,&quot;parentUUID&quot;:&quot;47d6715d-a3f0-4f65-a3ef-3cf713d11c8c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;25becb20-1de2-4c05-b7a6-ef5fabaed6b1&quot;,&quot;da4094cf-fe59-469a-a991-47739cc24745&quot;,&quot;3cc4e7df-814f-4a67-8abb-86a3f4b5c40e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13180,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;13fe9304-833c-4ef5-9964-21a9e91cfed4&quot;,&quot;7b23a316-e5f3-483f-9fc6-660fc3b9daa1&quot;,&quot;3a30954d-a32e-44f8-9902-507c3e80e105&quot;,&quot;3eec469f-a9b8-4969-905f-2026a5a6c885&quot;,&quot;db859e35-61ed-4dc1-b6c1-0a63fda0f17a&quot;,&quot;c4942cf6-eb17-4a44-bfee-ce568bdbd80a&quot;,&quot;4dfff88e-ca5c-469d-b3d3-6d1d6f914834&quot;,&quot;c547e167-50cb-4174-9f1b-c604ddbb9573&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:40408,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;55123ed0-7123-4677-b9fc-b70f29b03ce8&quot;,&quot;title&quot;:&quot;register pil terms and attach&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;register pil terms and attach\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions register pil terms and attach \&quot;before all\&quot; hook in \&quot;register pil terms and attach\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8685,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;tokenId = (await (0, util_1.getTokenId)());\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId,\n});\nipId = registerResult.ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;59882a2b-5e84-44df-8d3b-a6610d4ab53e&quot;,&quot;parentUUID&quot;:&quot;55123ed0-7123-4677-b9fc-b70f29b03ce8&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register PIL terms and attach&quot;,&quot;fullTitle&quot;:&quot;License Functions register pil terms and attach should register PIL terms and attach&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4681,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerPilTermsAndAttach({\n    ipId: ipId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 0n,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.nonCommercialSocialRemixing(),\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cbb178f8-f925-4c24-a245-7f9aa97bcc18&quot;,&quot;parentUUID&quot;:&quot;55123ed0-7123-4677-b9fc-b70f29b03ce8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register PIL terms and attach with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;License Functions register pil terms and attach should register PIL terms and attach with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5112,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerPilTermsAndAttach({\n    ipId: ipId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 0n,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 1,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 0n,\n                commercialRevShare: 100,\n                royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cf5e29a2-2050-45ce-8379-ddbfdf8b3989&quot;,&quot;parentUUID&quot;:&quot;55123ed0-7123-4677-b9fc-b70f29b03ce8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;cbb178f8-f925-4c24-a245-7f9aa97bcc18&quot;,&quot;cf5e29a2-2050-45ce-8379-ddbfdf8b3989&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:9793,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;455cc809-cd80-49b0-94ff-771f11695e2e&quot;,&quot;title&quot;:&quot;Creative Commons Attribution License Tests&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Creative Commons Attribution License Tests\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests \&quot;before all\&quot; hook in \&quot;Creative Commons Attribution License Tests\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8731,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;tokenId = await (0, util_1.getTokenId)();\n// Register an IP asset\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = registerResult.ipId;\n// Create a Creative Commons Attribution license\nconst ccLicenseResult = await client.license.registerCreativeCommonsAttributionPIL({\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicyAddress: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n});\nccLicenseTermsId = ccLicenseResult.licenseTermsId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e16870b2-fc95-4ec2-ad24-df70c18d63ee&quot;,&quot;parentUUID&quot;:&quot;455cc809-cd80-49b0-94ff-771f11695e2e&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should verify the license terms match Creative Commons Attribution specifications&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests should verify the license terms match Creative Commons Attribution specifications&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:44,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const licenseTerms = await client.license.getLicenseTerms(ccLicenseTermsId);\n(0, chai_1.expect)(licenseTerms.terms.transferable).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.commercialUse).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesAllowed).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesAttribution).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesReciprocal).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.derivativesApproval).to.equal(false);\n(0, chai_1.expect)(licenseTerms.terms.commercialAttribution).to.equal(true);\n(0, chai_1.expect)(licenseTerms.terms.commercialRevShare).to.equal(0);\n(0, chai_1.expect)(licenseTerms.terms.defaultMintingFee).to.equal(0n);\n(0, chai_1.expect)(licenseTerms.terms.royaltyPolicy).to.equal(generated_1.royaltyPolicyLapAddress[util_1.aeneid]);\n(0, chai_1.expect)(licenseTerms.terms.expiration).to.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5253fbd8-29d4-4820-b573-2216c00eca53&quot;,&quot;parentUUID&quot;:&quot;455cc809-cd80-49b0-94ff-771f11695e2e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should attach Creative Commons Attribution license to an IP&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests should attach Creative Commons Attribution license to an IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4467,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const attachResult = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: ccLicenseTermsId,\n});\n(0, chai_1.expect)(attachResult.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(attachResult.success).to.equal(true);\nconst licenseRegistryReadOnlyClient = new generated_1.LicenseRegistryReadOnlyClient(util_1.publicClient);\nconst hasLicense = await licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({\n    ipId: ipId,\n    licenseTemplate: client.ipAsset.licenseTemplateClient.address,\n    licenseTermsId: ccLicenseTermsId,\n});\n(0, chai_1.expect)(hasLicense).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4b85096a-2852-46e0-869f-dd8f322a7fe0&quot;,&quot;parentUUID&quot;:&quot;455cc809-cd80-49b0-94ff-771f11695e2e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint CC-BY license tokens with no minting fee&quot;,&quot;fullTitle&quot;:&quot;License Functions Creative Commons Attribution License Tests should mint CC-BY license tokens with no minting fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4700,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Get wallet balance before minting\nconst balanceBefore = await client.getWalletBalance();\n// Predict the minting fee (should be zero for CC-BY)\nconst feePredict = await client.license.predictMintingLicenseFee({\n    licenseTermsId: ccLicenseTermsId,\n    licensorIpId: ipId,\n    amount: 1,\n});\n// CC-BY licenses should have zero minting fee\n(0, chai_1.expect)(feePredict.tokenAmount).to.equal(0n);\nconst mintResult = await client.license.mintLicenseTokens({\n    licenseTermsId: ccLicenseTermsId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 0,\n});\n(0, chai_1.expect)(mintResult.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(mintResult.licenseTokenIds).to.be.a(\&quot;array\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n// Verify no fee was charged just gas\n// This checks that any difference is very small (just gas costs)\nconst balanceDiff = balanceBefore - balanceAfter;\nconst gasUsed = mintResult.receipt.gasUsed;\nconst effectiveGasPrice = mintResult.receipt.effectiveGasPrice;\nconst totalGas = gasUsed * effectiveGasPrice;\n// Confirms the balance diff only reflects gas cost, since license fee is zero.\n(0, chai_1.expect)(balanceDiff).to.equal(totalGas); // Small amount for gas&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;87c87c33-0b8d-4a61-b3b7-5dfe964485d0&quot;,&quot;parentUUID&quot;:&quot;455cc809-cd80-49b0-94ff-771f11695e2e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;5253fbd8-29d4-4820-b573-2216c00eca53&quot;,&quot;4b85096a-2852-46e0-869f-dd8f322a7fe0&quot;,&quot;87c87c33-0b8d-4a61-b3b7-5dfe964485d0&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:9211,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;93e8ea8f-f507-4301-8d90-3f51197c0dcb&quot;,&quot;title&quot;:&quot;nftClient Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;nftClient Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions \&quot;before all\&quot; hook in \&quot;nftClient Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c976668a-049e-4a87-982f-85e582567a51&quot;,&quot;parentUUID&quot;:&quot;93e8ea8f-f507-4301-8d90-3f51197c0dcb&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;32710897-2d6d-4572-9d33-aebb4143b386&quot;,&quot;title&quot;:&quot;createNFTCollection&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully create public nft collection with minimal params&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create public nft collection with minimal params&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4298,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(txData.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6eb09fd2-49aa-4814-b4dd-ed4e2290f0dd&quot;,&quot;parentUUID&quot;:&quot;32710897-2d6d-4572-9d33-aebb4143b386&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create collection with custom mint fee&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create collection with custom mint fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4323,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;paid-collection\&quot;,\n    symbol: \&quot;PAID\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 10000000,\n    mintFeeToken: generated_1.erc20Address[mockData_1.aeneid],\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);\nspgNftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b49a66f2-6c6b-4906-ae05-9975d1faa511&quot;,&quot;parentUUID&quot;:&quot;32710897-2d6d-4572-9d33-aebb4143b386&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create private collection&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create private collection&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4318,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;private-collection\&quot;,\n    symbol: \&quot;PRIV\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false, // private minting\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: false, // starts closed\n    contractURI: \&quot;test-uri\&quot;,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;718f195b-4dd2-47cd-8a26-666f62da635a&quot;,&quot;parentUUID&quot;:&quot;32710897-2d6d-4572-9d33-aebb4143b386&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create collection with baseURI&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create collection with baseURI&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4309,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;uri-collection\&quot;,\n    symbol: \&quot;URI\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    baseURI: \&quot;ipfs://QmTest/\&quot;,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;70acd3ca-3aa1-4887-b8bb-abcfa760199e&quot;,&quot;parentUUID&quot;:&quot;32710897-2d6d-4572-9d33-aebb4143b386&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create collection with custom owner&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create collection with custom owner&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4304,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;owned-collection\&quot;,\n    symbol: \&quot;OWN\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    owner: util_1.TEST_WALLET_ADDRESS,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a19a8b1e-ee76-4f10-b3d7-c6be75c5c447&quot;,&quot;parentUUID&quot;:&quot;32710897-2d6d-4572-9d33-aebb4143b386&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;6eb09fd2-49aa-4814-b4dd-ed4e2290f0dd&quot;,&quot;b49a66f2-6c6b-4906-ae05-9975d1faa511&quot;,&quot;718f195b-4dd2-47cd-8a26-666f62da635a&quot;,&quot;70acd3ca-3aa1-4887-b8bb-abcfa760199e&quot;,&quot;a19a8b1e-ee76-4f10-b3d7-c6be75c5c447&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:21552,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;32cf69cc-8fcd-479e-9d18-b63c44fde971&quot;,&quot;title&quot;:&quot;Mint Fee&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully get mint fee token&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions Mint Fee should successfully get mint fee token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:41,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintFeeToken = await client.nftClient.getMintFeeToken(spgNftContract);\n(0, chai_1.expect)(mintFeeToken).to.equal(generated_1.erc20Address[mockData_1.aeneid]);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4fbb6895-fba2-4621-b4c6-06247201168c&quot;,&quot;parentUUID&quot;:&quot;32cf69cc-8fcd-479e-9d18-b63c44fde971&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully get mint fee&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions Mint Fee should successfully get mint fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:45,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintFee = await client.nftClient.getMintFee(spgNftContract);\n(0, chai_1.expect)(mintFee).to.equal(10000000n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;41d65356-eae6-4142-87d7-493e820fea9c&quot;,&quot;parentUUID&quot;:&quot;32cf69cc-8fcd-479e-9d18-b63c44fde971&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;4fbb6895-fba2-4621-b4c6-06247201168c&quot;,&quot;41d65356-eae6-4142-87d7-493e820fea9c&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:86,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;e4525fdb-da9e-4695-bbdd-1d838c712c09&quot;,&quot;title&quot;:&quot;set and get tokenURI&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully set token URI&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions set and get tokenURI should successfully set token URI&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12964,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Setup: Approve the contract for ERC20 transfers\nconst erc20Client = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[mockData_1.aeneid]);\nconst txHash = await erc20Client.approve(spgNftContract, viem_1.maxUint256);\nawait util_1.publicClient.waitForTransactionReceipt({ hash: txHash });\n// Mint a new token with initial metadata\nconst tokenId = await (0, util_1.mintBySpg)(spgNftContract, \&quot;ipfs://QmTest/\&quot;);\n(0, chai_1.expect)(tokenId).to.be.a(\&quot;bigint\&quot;);\n// Update the token URI\nconst updatedMetadata = \&quot;ipfs://QmUpdated/metadata.json\&quot;;\nconst result = await client.nftClient.setTokenURI({\n    tokenId: tokenId,\n    tokenURI: updatedMetadata,\n    spgNftContract,\n});\n// Verify the transaction\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n// Verification that the URI was updated\nconst tokenURI = await client.nftClient.getTokenURI({\n    tokenId,\n    spgNftContract,\n});\n(0, chai_1.expect)(tokenURI).to.equal(updatedMetadata);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;47b07719-798c-481b-a16b-0e2333c2532a&quot;,&quot;parentUUID&quot;:&quot;e4525fdb-da9e-4695-bbdd-1d838c712c09&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;47b07719-798c-481b-a16b-0e2333c2532a&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:12964,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;1093cff5-6b1e-41fc-8c04-afae0b7ff2cc&quot;,&quot;title&quot;:&quot;Permission Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Permission Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Permission Functions \&quot;before all\&quot; hook in \&quot;Permission Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8674,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = response.ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0c23ca19-e6d7-4ef4-bc53-4e0db54bb7bf&quot;,&quot;parentUUID&quot;:&quot;1093cff5-6b1e-41fc-8c04-afae0b7ff2cc&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;470dd357-f9cc-4ad4-ae8f-49348ee5ed29&quot;,&quot;title&quot;:&quot;Single Permission Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should set permission successfully&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Single Permission Operations should set permission successfully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4347,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.setPermission({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n    func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;848e84d7-cd9a-4e01-b68d-0b53f28832bb&quot;,&quot;parentUUID&quot;:&quot;470dd357-f9cc-4ad4-ae8f-49348ee5ed29&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should set all permissions successfully&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Single Permission Operations should set all permissions successfully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4351,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.setAllPermissions({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    permission: permission_1.AccessPermission.ALLOW,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8f43532b-3dc6-41d4-926f-75fc2aef66c7&quot;,&quot;parentUUID&quot;:&quot;470dd357-f9cc-4ad4-ae8f-49348ee5ed29&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;848e84d7-cd9a-4e01-b68d-0b53f28832bb&quot;,&quot;8f43532b-3dc6-41d4-926f-75fc2aef66c7&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:8698,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;c34014fc-9d6e-40b4-9223-38049ef5eb02&quot;,&quot;title&quot;:&quot;Permission Signatures&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should create set permission signature&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Permission Signatures should create set permission signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4450,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.createSetPermissionSignature({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n    permission: permission_1.AccessPermission.ALLOW,\n    deadline: 60000n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;63a74559-0a72-4e17-b503-a215fda20cb0&quot;,&quot;parentUUID&quot;:&quot;c34014fc-9d6e-40b4-9223-38049ef5eb02&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;63a74559-0a72-4e17-b503-a215fda20cb0&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4450,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;1ba17a66-f1fc-431f-b318-1511ef68676f&quot;,&quot;title&quot;:&quot;Batch Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should set batch permissions successfully&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Batch Operations should set batch permissions successfully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4370,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.setBatchPermissions({\n    permissions: [\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.ALLOW,\n            func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n        },\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.DENY,\n            func: \&quot;function freezeMetadata(address)\&quot;,\n        },\n    ],\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;31c2fd74-4a77-401a-bd98-48a1c764fa1d&quot;,&quot;parentUUID&quot;:&quot;1ba17a66-f1fc-431f-b318-1511ef68676f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should create batch permission signature&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Batch Operations should create batch permission signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4481,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.createBatchPermissionSignature({\n    ipId: ipId,\n    permissions: [\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.ALLOW,\n            func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n        },\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.DENY,\n            func: \&quot;function freezeMetadata(address)\&quot;,\n        },\n    ],\n    deadline: 60000n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e96591df-0ac0-4067-b2f2-384829fdd1ad&quot;,&quot;parentUUID&quot;:&quot;1ba17a66-f1fc-431f-b318-1511ef68676f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;31c2fd74-4a77-401a-bd98-48a1c764fa1d&quot;,&quot;e96591df-0ac0-4067-b2f2-384829fdd1ad&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:8851,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;1919317f-ebd6-44b6-a6c5-e3a7db5bb600&quot;,&quot;title&quot;:&quot;Royalty Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Royalty Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions \&quot;before all\&quot; hook in \&quot;Royalty Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:31135,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nmockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\n// Setup initial state\nparentIpId = await getIpId();\nchildIpId = await getIpId();\nlicenseTermsId = await getCommercialPolicyId();\n// Setup relationships and approvals\nawait attachLicenseTerms(parentIpId, licenseTermsId);\nawait mockERC20.mint(util_1.TEST_WALLET_ADDRESS, (0, viem_1.parseEther)(\&quot;10\&quot;));\nawait mockERC20.approve(generated_1.royaltyModuleAddress[util_1.aeneid], viem_1.maxUint256);\n// Register derivative\nawait client.ipAsset.registerDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [licenseTermsId],\n    maxMintingFee: 0,\n    maxRts: 0,\n    maxRevenueShare: 0,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;53e7f694-f2c3-4a07-886f-b5f2728daf68&quot;,&quot;parentUUID&quot;:&quot;1919317f-ebd6-44b6-a6c5-e3a7db5bb600&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should return claimable revenue amount&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions should return claimable revenue amount&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:138,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.royalty.claimableRevenue({\n    ipId: parentIpId,\n    claimer: util_1.TEST_WALLET_ADDRESS,\n    token: generated_1.erc20Address[util_1.aeneid],\n});\n(0, chai_1.expect)(response).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;10715b96-5643-493d-80c7-5c144772bd9d&quot;,&quot;parentUUID&quot;:&quot;1919317f-ebd6-44b6-a6c5-e3a7db5bb600&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;1fd75664-97d8-4925-aebd-932ab423a2b9&quot;,&quot;title&quot;:&quot;Royalty Payments&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully pay royalty on behalf&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should successfully pay royalty on behalf&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4491,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: parentIpId,\n    payerIpId: childIpId,\n    token: generated_1.erc20Address[util_1.aeneid],\n    amount: 1,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b516f587-7160-46d2-ae5f-ecfbd5760b6f&quot;,&quot;parentUUID&quot;:&quot;1fd75664-97d8-4925-aebd-932ab423a2b9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto convert IP to WIP when paying WIP on behalf&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should auto convert IP to WIP when paying WIP on behalf&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4678,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const balanceBefore = await client.getWalletBalance();\nconst response = await client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: parentIpId,\n    payerIpId: childIpId,\n    token: common_1.WIP_TOKEN_ADDRESS,\n    amount: 100n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 100n));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f5aa9ed9-eb9a-4bc4-b9d6-76a8c0e14aa4&quot;,&quot;parentUUID&quot;:&quot;1fd75664-97d8-4925-aebd-932ab423a2b9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow the royalty vault to transfer its native tokens to a wallet address&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should allow the royalty vault to transfer its native tokens to a wallet address&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4768,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const royaltyVaultAddress = await client.royalty.getRoyaltyVaultAddress(parentIpId);\nconst royaltyVaultToken = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, royaltyVaultAddress);\nconst transferAmount = BigInt(10 * 10 ** 6); // 10 million tokens\n// Check initial balances of the vault token\nconst initialTargetBalance = await royaltyVaultToken.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst initialParentBalance = await royaltyVaultToken.balanceOf(parentIpId);\n(0, chai_1.expect)(Number(initialParentBalance)).greaterThanOrEqual(Number(transferAmount));\nconst transferResult = await client.ipAccount.execute({\n    to: royaltyVaultAddress,\n    value: 0,\n    ipId: parentIpId,\n    data: (0, viem_1.encodeFunctionData)({\n        abi: viem_1.erc20Abi,\n        functionName: \&quot;transfer\&quot;,\n        args: [util_1.TEST_WALLET_ADDRESS, transferAmount],\n    }),\n});\n(0, chai_1.expect)(transferResult.txHash).to.be.a(\&quot;string\&quot;);\n// Check final balances to confirm the transfer worked\nconst finalTargetBalance = await royaltyVaultToken.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst finalParentBalance = await royaltyVaultToken.balanceOf(parentIpId);\n(0, chai_1.expect)(finalTargetBalance).to.equal(initialTargetBalance + transferAmount, \&quot;Target wallet balance should increase by the transfer amount\&quot;);\n(0, chai_1.expect)(Number(finalParentBalance)).equal(Number(initialParentBalance - transferAmount));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e4a6ee8d-014e-451c-aca5-32df70d7d4e9&quot;,&quot;parentUUID&quot;:&quot;1fd75664-97d8-4925-aebd-932ab423a2b9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;b516f587-7160-46d2-ae5f-ecfbd5760b6f&quot;,&quot;f5aa9ed9-eb9a-4bc4-b9d6-76a8c0e14aa4&quot;,&quot;e4a6ee8d-014e-451c-aca5-32df70d7d4e9&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13937,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;5a605f06-3d67-47df-b63c-f1b4ad11b9bb&quot;,&quot;title&quot;:&quot;ClaimAllRevenue With WIP&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;ClaimAllRevenue With WIP\&quot;&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions ClaimAllRevenue With WIP \&quot;before all\&quot; hook in \&quot;ClaimAllRevenue With WIP\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:24299,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// set up\n// minting Fee: 100, 10% LAP rev share, A expect to get 120 WIP\n// A -&gt; B -&gt; C -&gt; D\nconst txData = await client.nftClient.createNFTCollection({\n    name: \&quot;free-collection\&quot;,\n    symbol: \&quot;FREE\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: viem_1.zeroAddress,\n});\nspgNftContract = txData.spgNftContract;\nconst retA = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 100n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 100n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nipA = retA.ipId;\nlicenseId = retA.licenseTermsIds[0];\nconst retB = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipA],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\nipB = retB.ipId;\nconst retC = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipB],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\nipC = retC.ipId;\nawait client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipC],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;faa9236e-ddf5-4b1f-a348-0fb5bdb953c3&quot;,&quot;parentUUID&quot;:&quot;5a605f06-3d67-47df-b63c-f1b4ad11b9bb&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should claim all revenue&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions ClaimAllRevenue With WIP should claim all revenue&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12992,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const ret = await client.royalty.claimAllRevenue({\n    ancestorIpId: ipA,\n    claimer: ipA,\n    childIpIds: [ipB, ipC],\n    royaltyPolicies: [generated_1.royaltyPolicyLapAddress[util_1.aeneid], generated_1.royaltyPolicyLapAddress[util_1.aeneid]],\n    currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n});\n(0, chai_1.expect)(ret.txHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(ret.claimedTokens[0].amount).to.equal(120n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b36cb823-c1b8-42e8-9cdb-60cf733474d6&quot;,&quot;parentUUID&quot;:&quot;5a605f06-3d67-47df-b63c-f1b4ad11b9bb&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;b36cb823-c1b8-42e8-9cdb-60cf733474d6&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:12992,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;51ab3964-e3c4-453b-a5ee-75dd929b0111&quot;,&quot;title&quot;:&quot;BatchClaimAllRevenue With WIP&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;BatchClaimAllRevenue With WIP\&quot;&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions BatchClaimAllRevenue With WIP \&quot;before all\&quot; hook in \&quot;BatchClaimAllRevenue With WIP\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:42374,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nanotherAddress = derivedClient.address;\nawait client.wipClient.deposit({\n    amount: (0, viem_1.parseEther)(\&quot;5\&quot;),\n});\n/**\n * Asset Hierarchy Setup for Revenue Collection Tests\n *\n * Overview:\n * This test setup creates two distinct IP asset hierarchies (IpA and IpB) to demonstrate\n * different revenue collection scenarios using LAP (Licensing Agreement Policy) and LRP\n * (Licensing Revenue Policy) respectively.\n *\n * IpA Hierarchy (LAP - Licensing Agreement Policy):                           IpB Hierarchy (LRP - Licensing Revenue Policy):\n *           \n *  IpA (Parent) - Total Expected Revenue: 130 WIP                         IpB (Parent) - Total Expected Revenue: 330 WIP              \n *           \n *  Revenue Sources:                                                       Revenue Sources:                                            \n *   Minting Fee: 100 WIP                                                Minting Fee: 150 WIP                                    \n *   Revenue Share (ipA2-&gt;ipA1): 10 WIP (10% LAP)                        LRP Revenue Share: 10%                                  \n *   Revenue Share (ipA3-&gt;ipA2): 10 WIP (10% LAP)                        Total Revenue: 330 WIP                                  \n *   Direct Payment (ipA3): 10 WIP (10% LAP)                                From ipB1: 150 WIP + 10% revenue share               \n *                                                                             From ipB2: 150 WIP + 10% revenue share               \n *                                                                                                                                     \n * | Ownership Distribution:                                               |                                                             \n *   Wallet Address: 50%  65 WIP                                        Revenue Flow:                                               \n *   Another Address: 50% 65 WIP                                        ipB3                                                        \n *                                                                          ipB1                                                  \n *  Revenue Flow:                                                           ipB2 &gt; ipB (collects 330 WIP)                       \n *  ipA3                                                                                                                               \n *   &gt; ipA2 (20% LAP) &gt; ipA1 (10% LAP) &gt; ipA                                                                                    \n *        &gt; Direct Payment: 100 WIP                                                                                                 \n *           \n */\nconst txData = await client.nftClient.createNFTCollection({\n    name: \&quot;free-collection\&quot;,\n    symbol: \&quot;FREE\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: viem_1.zeroAddress,\n});\nspgNftContract = txData.spgNftContract;\n// 1. Register ipA\nconst ret1A = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 100n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 100n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 50,\n        },\n        {\n            recipient: anotherAddress,\n            percentage: 50,\n        },\n    ],\n});\nipA = ret1A.ipId;\nlicenseId = ret1A.licenseTermsIds[0];\n// 2. Register ipB\nconst ret1B = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n                defaultMintingFee: 150n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 150n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nipB = ret1B.ipId;\nlicenseId1 = ret1B.licenseTermsIds[0];\n// 3. Register ipA1 from ipA and ipB1 from ipB\nconst { results: ret2 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB],\n                licenseTermsIds: [licenseId1],\n            },\n        },\n    ],\n});\nipA1 = ret2[0].ipId;\nipB1 = ret2[1].ipId;\n// 4. Register ipA2 from ipA1 and ipB2 from ipB\nconst { results: ret3 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA1],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB],\n                licenseTermsIds: [licenseId1],\n            },\n        },\n    ],\n});\nipA2 = ret3[0].ipId;\nipB2 = ret3[1].ipId;\n// 5. Register ipA3 from ipA2 and ipB3 from ipB1 and ipB2\nconst { results: ret4 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA2],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB1, ipB2],\n                licenseTermsIds: [licenseId1, licenseId1],\n            },\n        },\n    ],\n});\nipA3 = ret4[0].ipId;\n// 6. Pay royalty on behalf of ipA2 to ipA3\nawait client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: ipA2,\n    payerIpId: ipA3,\n    token: common_1.WIP_TOKEN_ADDRESS,\n    amount: 100n,\n});\nconst balance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nawait client.wipClient.withdraw({\n    amount: balance,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;06190723-ff84-4a84-bdd6-942138522415&quot;,&quot;parentUUID&quot;:&quot;51ab3964-e3c4-453b-a5ee-75dd929b0111&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should batch claim all revenue&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions BatchClaimAllRevenue With WIP should batch claim all revenue&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13220,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const anotherAddressWipBalanceBefore = await client.wipClient.balanceOf(anotherAddress);\nconst result = await client.royalty.batchClaimAllRevenue({\n    ancestorIps: [\n        {\n            ipId: ipA,\n            claimer: util_1.TEST_WALLET_ADDRESS,\n            childIpIds: [ipA1, ipA2],\n            royaltyPolicies: [generated_1.royaltyPolicyLapAddress[util_1.aeneid], generated_1.royaltyPolicyLapAddress[util_1.aeneid]],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n        },\n        {\n            ipId: ipA,\n            claimer: anotherAddress,\n            childIpIds: [],\n            royaltyPolicies: [],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS],\n        },\n        {\n            ipId: ipB,\n            claimer: ipB,\n            childIpIds: [ipB1, ipB2],\n            royaltyPolicies: [generated_1.royaltyPolicyLrpAddress[util_1.aeneid], generated_1.royaltyPolicyLrpAddress[util_1.aeneid]],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n        },\n    ],\n});\nconst anotherAddressWipBalanceAfter = await client.wipClient.balanceOf(anotherAddress);\nconst walletWipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(result.txHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.claimedTokens[0].amount).to.equal(65n);\n(0, chai_1.expect)(result.claimedTokens[1].amount).to.equal(65n);\n(0, chai_1.expect)(result.claimedTokens[2].amount).to.equal(330n);\n(0, chai_1.expect)(walletWipBalanceAfter).to.equal(0n);\n(0, chai_1.expect)(anotherAddressWipBalanceAfter).to.equal(anotherAddressWipBalanceBefore + 65n);\n// Note: The final wallet balance cannot be precisely calculated because:\n// The test involves multiple transactions (claimAllRevenue, token transfers, etc.)\n// batchClaimAllRevenue only returns receipts for claimAllRevenue calls\n// Additional gas costs and token transfers occur outside the returned receipts&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;67bcce86-396f-46e1-bb21-46bc954f7e02&quot;,&quot;parentUUID&quot;:&quot;51ab3964-e3c4-453b-a5ee-75dd929b0111&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;67bcce86-396f-46e1-bb21-46bc954f7e02&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13220,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;10715b96-5643-493d-80c7-5c144772bd9d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:138,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;f7ce9353-4e1f-4b4a-8539-d9a4fb354575&quot;,&quot;title&quot;:&quot;WIP Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;WIP Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;WIP Functions \&quot;before all\&quot; hook in \&quot;WIP Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;511cc71f-6cf4-45bd-9141-b12e088594f0&quot;,&quot;parentUUID&quot;:&quot;f7ce9353-4e1f-4b4a-8539-d9a4fb354575&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;2d0f6ee5-9099-41f3-9c39-560b214e445d&quot;,&quot;title&quot;:&quot;deposit&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should deposit 0.01 WIP&quot;,&quot;fullTitle&quot;:&quot;WIP Functions deposit should deposit 0.01 WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4474,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const ipAmt = (0, viem_1.parseEther)(\&quot;0.01\&quot;);\nconst balanceBefore = await client.getWalletBalance();\nconst wipBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst rsp = await client.wipClient.deposit({\n    amount: ipAmt,\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.equal(wipBefore + ipAmt);\nconst gasCost = rsp.receipt.gasUsed * rsp.receipt.effectiveGasPrice;\n(0, chai_1.expect)(balanceAfter).to.equal(balanceBefore - ipAmt - gasCost);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;34d275c2-e59e-48fd-868c-d8555e5bf0dc&quot;,&quot;parentUUID&quot;:&quot;2d0f6ee5-9099-41f3-9c39-560b214e445d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;34d275c2-e59e-48fd-868c-d8555e5bf0dc&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4474,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;caacd2f5-447b-4462-8a0a-4351df55dde7&quot;,&quot;title&quot;:&quot;transfer&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should transfer WIP&quot;,&quot;fullTitle&quot;:&quot;WIP Functions transfer should transfer WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4294,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const rsp = await client.wipClient.transfer({\n    to: util_1.TEST_WALLET_ADDRESS,\n    amount: (0, viem_1.parseEther)(\&quot;0.01\&quot;),\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n//Due to approve cannot approve msy.sender, so skip transferFrom test&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7ea8115f-b914-4edb-bbc2-61b95e8c0cdd&quot;,&quot;parentUUID&quot;:&quot;caacd2f5-447b-4462-8a0a-4351df55dde7&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;7ea8115f-b914-4edb-bbc2-61b95e8c0cdd&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4294,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;ccd93d15-20f3-4677-8bad-ca6875b0ecc5&quot;,&quot;title&quot;:&quot;withdraw&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should withdrawal WIP&quot;,&quot;fullTitle&quot;:&quot;WIP Functions withdraw should withdrawal WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4451,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const balanceBefore = await client.getWalletBalance();\nconst wipBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst rsp = await client.wipClient.withdraw({\n    amount: wipBefore,\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.equal(0n);\nconst balanceAfter = await client.getWalletBalance();\nconst gasCost = rsp.receipt.gasUsed * rsp.receipt.effectiveGasPrice;\n(0, chai_1.expect)(balanceAfter).to.equal(balanceBefore + wipBefore - gasCost);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2398108c-5b3b-421b-af27-78cd558d5d10&quot;,&quot;parentUUID&quot;:&quot;ccd93d15-20f3-4677-8bad-ca6875b0ecc5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;2398108c-5b3b-421b-af27-78cd558d5d10&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4451,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:300000}],&quot;meta&quot;:{&quot;mocha&quot;:{&quot;version&quot;:&quot;10.8.2&quot;},&quot;mochawesome&quot;:{&quot;options&quot;:{&quot;quiet&quot;:false,&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;saveHtml&quot;:true,&quot;saveJson&quot;:true,&quot;consoleReporter&quot;:&quot;spec&quot;,&quot;useInlineDiffs&quot;:false,&quot;code&quot;:true},&quot;version&quot;:&quot;7.1.4&quot;},&quot;marge&quot;:{&quot;version&quot;:&quot;6.3.2&quot;}}}" data-config="{&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;reportDir&quot;:&quot;mochawesome-report&quot;,&quot;reportTitle&quot;:&quot;core-sdk&quot;,&quot;reportPageTitle&quot;:&quot;Mochawesome Report&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;cdn&quot;:false,&quot;charts&quot;:false,&quot;enableCharts&quot;:false,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;showPassed&quot;:true,&quot;showFailed&quot;:true,&quot;showPending&quot;:true,&quot;showSkipped&quot;:false,&quot;showHooks&quot;:&quot;failed&quot;,&quot;saveJson&quot;:true,&quot;saveHtml&quot;:true,&quot;dev&quot;:false,&quot;assetsDir&quot;:&quot;mochawesome-report/assets&quot;,&quot;jsonFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/mochawesome-report/mochawesome.json&quot;,&quot;htmlFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/mochawesome-report/mochawesome.html&quot;}"><div id="report"></div><script src="assets/app.js"></script></body></html>