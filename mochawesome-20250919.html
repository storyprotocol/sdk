<!doctype html>
<html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Mochawesome Report</title><link rel="stylesheet" href="assets/app.css"/></head><body data-raw="{&quot;stats&quot;:{&quot;suites&quot;:55,&quot;tests&quot;:159,&quot;passes&quot;:159,&quot;pending&quot;:0,&quot;failures&quot;:0,&quot;start&quot;:&quot;2025-09-19T07:06:50.315Z&quot;,&quot;end&quot;:&quot;2025-09-19T07:49:28.748Z&quot;,&quot;duration&quot;:2558433,&quot;testsRegistered&quot;:159,&quot;passPercent&quot;:100,&quot;pendingPercent&quot;:0,&quot;other&quot;:0,&quot;hasOther&quot;:false,&quot;skipped&quot;:0,&quot;hasSkipped&quot;:false},&quot;results&quot;:[{&quot;uuid&quot;:&quot;6e62a61e-95b0-494e-87c7-827c5aa3c6f4&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;5490c8ed-9813-426c-9b83-9b168fba5141&quot;,&quot;title&quot;:&quot;Dispute Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/dispute.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Dispute Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions \&quot;before all\&quot; hook in \&quot;Dispute Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10617,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;clientA = (0, util_1.getStoryClient)();\nconst derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nclientB = derivedClient.clientB;\nminimumBond = await (0, oov3_1.getMinimumBond)(util_1.publicClient, new generated_1.ArbitrationPolicyUmaClient(util_1.publicClient, util_1.walletClient), src_1.WIP_TOKEN_ADDRESS);\nconst txData = await clientA.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nconst nftContract = txData.spgNftContract;\nipIdB = (await clientB.ipAsset.mintAndRegisterIp({\n    spgNftContract: nftContract,\n})).ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;12b0f108-5582-4f10-a770-f19667fb0d7b&quot;,&quot;parentUUID&quot;:&quot;5490c8ed-9813-426c-9b83-9b168fba5141&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;it should not cancel a dispute (yet)&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions it should not cancel a dispute (yet)&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10855,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const raiseResponse = await clientA.dispute.raiseDispute({\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 2592000,\n    bond: minimumBond,\n});\nawait (0, chai_1.expect)(clientA.dispute.cancelDispute({\n    disputeId: raiseResponse.disputeId,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;53186009-eaec-451c-adc4-7f4a0e93866f&quot;,&quot;parentUUID&quot;:&quot;5490c8ed-9813-426c-9b83-9b168fba5141&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;a6c31b7a-78c7-4d02-bf3d-50ed57bf6ff7&quot;,&quot;title&quot;:&quot;raiseDispute and counter dispute&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/dispute.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should raise a dispute&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should raise a dispute&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11015,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const raiseDisputeRequest = {\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 2592000,\n    bond: minimumBond,\n};\nconst response = await clientA.dispute.raiseDispute(raiseDisputeRequest);\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.disputeId).to.be.a(\&quot;bigint\&quot;);\ndisputeId = response.disputeId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6ae0d8a9-dd85-41bc-9abf-d6a51c22f102&quot;,&quot;parentUUID&quot;:&quot;a6c31b7a-78c7-4d02-bf3d-50ed57bf6ff7&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should validate all enum values defined in DisputeTargetTag&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should validate all enum values defined in DisputeTargetTag&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:509,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const allTags = Object.values(src_1.DisputeTargetTag);\nfor (const tag of allTags) {\n    const tagHex = (0, viem_1.toHex)(tag, { size: 32 });\n    const { allowed } = await clientA.dispute.disputeModuleClient.isWhitelistedDisputeTag({\n        tag: tagHex,\n    });\n    if (tag === src_1.DisputeTargetTag.IN_DISPUTE) {\n        (0, chai_1.expect)(allowed).equal(false);\n    }\n    else {\n        (0, chai_1.expect)(allowed).equal(true);\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;63ae697d-fd60-4401-901c-607b790e7cb0&quot;,&quot;parentUUID&quot;:&quot;a6c31b7a-78c7-4d02-bf3d-50ed57bf6ff7&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should raise disputes with different DisputeTargetTag enum values&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should raise disputes with different DisputeTargetTag enum values&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:47638,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const allTags = Object.values(src_1.DisputeTargetTag);\nfor (const tag of allTags) {\n    const raiseDisputeRequest = {\n        targetIpId: ipIdB,\n        cid: await generateCID(),\n        targetTag: tag,\n        liveness: 2592000,\n        bond: minimumBond,\n    };\n    if (tag === src_1.DisputeTargetTag.IN_DISPUTE) {\n        await (0, chai_1.expect)(clientA.dispute.raiseDispute(raiseDisputeRequest)).to.be.rejectedWith(\&quot;The target tag IN_DISPUTE is not whitelisted\&quot;);\n    }\n    else {\n        const response = await clientA.dispute.raiseDispute(raiseDisputeRequest);\n        (0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n        (0, chai_1.expect)(response.disputeId).to.be.a(\&quot;bigint\&quot;);\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7a194873-c87b-437a-9c46-cc118159b651&quot;,&quot;parentUUID&quot;:&quot;a6c31b7a-78c7-4d02-bf3d-50ed57bf6ff7&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should reject a dispute with an invalid tag not defined in the enum&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should reject a dispute with an invalid tag not defined in the enum&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:395,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(clientA.dispute.raiseDispute({\n    targetIpId: ipIdB,\n    cid: await generateCID(),\n    targetTag: \&quot;INVALID_TAG\&quot;,\n    liveness: 2592000,\n    bond: minimumBond,\n})).to.be.rejectedWith(\&quot;The target tag INVALID_TAG is not whitelisted\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a5c5f92d-d3cc-4e71-875d-64812d42d4d5&quot;,&quot;parentUUID&quot;:&quot;a6c31b7a-78c7-4d02-bf3d-50ed57bf6ff7&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should be able to counter existing dispute once&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions raiseDispute and counter dispute should be able to counter existing dispute once&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:16009,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const assertionId = await clientB.dispute.disputeIdToAssertionId(disputeId);\nconst counterEvidenceCID = await generateCID();\nconst ret = await clientB.dispute.disputeAssertion({\n    ipId: ipIdB,\n    assertionId,\n    counterEvidenceCID,\n});\n(0, chai_1.expect)(ret.txHash).to.be.a(\&quot;string\&quot;);\n// should throw error if attempting to dispute assertion again\nawait (0, chai_1.expect)(clientB.dispute.disputeAssertion({\n    ipId: ipIdB,\n    assertionId,\n    counterEvidenceCID,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;464e1488-bc27-4631-87fd-f1722ce9392d&quot;,&quot;parentUUID&quot;:&quot;a6c31b7a-78c7-4d02-bf3d-50ed57bf6ff7&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;6ae0d8a9-dd85-41bc-9abf-d6a51c22f102&quot;,&quot;63ae697d-fd60-4401-901c-607b790e7cb0&quot;,&quot;7a194873-c87b-437a-9c46-cc118159b651&quot;,&quot;a5c5f92d-d3cc-4e71-875d-64812d42d4d5&quot;,&quot;464e1488-bc27-4631-87fd-f1722ce9392d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:75566,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;dd6df065-1ceb-4206-ac51-20ce589d43a0&quot;,&quot;title&quot;:&quot;Dispute resolution&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/dispute.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/dispute.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before each\&quot; hook in \&quot;Dispute resolution\&quot;&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution \&quot;before each\&quot; hook in \&quot;Dispute resolution\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:44138,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Setup NFT collection\nconst txData = await clientA.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\n// Get parent IP ID and license terms ID\nconst ipIdAndLicenseResponse = await clientA.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContract,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: src_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: generated_1.evenSplitGroupPoolAddress[util_1.aeneid],\n            },\n        },\n    ],\n});\nparentIpId = ipIdAndLicenseResponse.ipId;\nlicenseTermsId = ipIdAndLicenseResponse.licenseTermsIds[0];\n//Create a derivative ip\nconst derivativeIpIdResponse1 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\nchildIpId = derivativeIpIdResponse1.ipId;\n// Create a second derivative ip\nconst derivativeIpIdResponse2 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\nchildIpId2 = derivativeIpIdResponse2.ipId;\n// Raise a dispute\nconst response = await clientA.dispute.raiseDispute({\n    targetIpId: parentIpId,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 1,\n    bond: minimumBond,\n});\ndisputeId = response.disputeId;\n// This timeout guarantees that the assertion is expired\n// its intended to be longer than the current block time\n// so it won&#x27;t be included in the same block\nawait new Promise((resolve) =&gt; setTimeout(resolve, 3000));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;73a71252-71e0-43fa-a15b-b4abaaf241b1&quot;,&quot;parentUUID&quot;:&quot;dd6df065-1ceb-4206-ac51-20ce589d43a0&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should tag infringing ip&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag infringing ip&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10070,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Tag derivative IP as infringing\nconst results = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: childIpId2,\n            disputeId: disputeId,\n        },\n    ],\n});\n(0, chai_1.expect)(results[0].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;37c60248-bae4-4db5-8c68-5ea24654b1ea&quot;,&quot;parentUUID&quot;:&quot;dd6df065-1ceb-4206-ac51-20ce589d43a0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should tag a single IP as infringing without using multicall&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag a single IP as infringing without using multicall&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14365,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;/**\n * Test Flow:\n * 1. Set judgment on an existing dispute to mark it as valid (did in `before each` block)\n * 2. Verify the dispute state changed correctly after judgment\n * 3. Try to tag a derivative IP using the judged dispute\n */\n// Step 1: Set judgment on an existing dispute to mark it as valid\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Step 2: Verify dispute state\n// The disputes() function returns multiple values about the dispute:\n// - targetTag: the tag we wanted to apply when raising the dispute\n// - currentTag: the current state of the dispute after judgment\n// After a successful judgment, currentTag should equal targetTag\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag); // Verify judgment was recorded correctly\n// Step 3: Attempt to tag a derivative IP\n// This will fail if:\n// - The dispute is not in a valid state (still IN_DISPUTE or cleared)\n// - The IP we&#x27;re trying to tag is not actually a derivative of the disputed IP\n// - The dispute has already been used to tag this IP\nconst response = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId, // The derivative IP to tag\n            disputeId: disputeId, // Using the judged dispute as basis for tagging\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: false, // Force single transaction instead of batch\n    },\n});\n// Verify we got the expected response\n(0, chai_1.expect)(response).to.have.lengthOf(1);\n(0, chai_1.expect)(response[0].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2c2dc2c3-8a6d-47ef-85ad-7073ac0687d0&quot;,&quot;parentUUID&quot;:&quot;dd6df065-1ceb-4206-ac51-20ce589d43a0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should tag multiple IPs as infringing using multicall&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag multiple IPs as infringing using multicall&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:29654,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const disputeResponse = await clientA.dispute.raiseDispute({\n    targetIpId: parentIpId,\n    cid: await generateCID(),\n    targetTag: src_1.DisputeTargetTag.IMPROPER_REGISTRATION,\n    liveness: 1,\n    bond: minimumBond,\n});\nconst testDisputeId = disputeResponse.disputeId;\nconst derivativeResponse2 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nconst newChildIpId = derivativeResponse2.ipId;\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, testDisputeId);\n// This timeout guarantees that the assertion is expired\n// its intended to be longer than the current block time\n// so it won&#x27;t be included in the same block\nawait new Promise((resolve) =&gt; setTimeout(resolve, 3000));\nconst { currentTag, targetTag } = await getDisputeState(testDisputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst response = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: testDisputeId,\n        },\n        {\n            ipId: newChildIpId,\n            disputeId: testDisputeId,\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: true,\n    },\n});\n(0, chai_1.expect)(response).to.have.lengthOf(1);\n(0, chai_1.expect)(response[0].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f0ed87e5-43af-48ad-815d-5d1db68de7bf&quot;,&quot;parentUUID&quot;:&quot;dd6df065-1ceb-4206-ac51-20ce589d43a0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should tag multiple IPs without multicall when specified&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should tag multiple IPs without multicall when specified&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:26737,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create two new derivative IPs sequentially\nconst derivativeResponse3 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nconst derivativeResponse4 = await clientA.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n    allowDuplicates: true,\n});\nawait (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst responses = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: derivativeResponse3.ipId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: derivativeResponse4.ipId,\n            disputeId: disputeId,\n        },\n    ],\n    options: {\n        useMulticallWhenPossible: false,\n    },\n});\n(0, chai_1.expect)(responses).to.have.lengthOf(2);\n(0, chai_1.expect)(responses[0].txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(responses[1].txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ae57b4fa-378e-4219-9d71-b650ec79c228&quot;,&quot;parentUUID&quot;:&quot;dd6df065-1ceb-4206-ac51-20ce589d43a0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to tag with invalid dispute ID&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should fail when trying to tag with invalid dispute ID&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:95,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: 999999n,\n        },\n    ],\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5bdfada8-6758-4cba-860c-638b9df25b9a&quot;,&quot;parentUUID&quot;:&quot;dd6df065-1ceb-4206-ac51-20ce589d43a0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should resolve a dispute successfully when initiated by dispute initiator&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should resolve a dispute successfully when initiated by dispute initiator&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10129,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\nconst { currentTag, targetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(currentTag).to.equal(targetTag);\nconst response = await clientA.dispute.resolveDispute({\n    disputeId: disputeId,\n    data: \&quot;0x\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0b19fe78-e5d7-4c71-8989-ef815396565c&quot;,&quot;parentUUID&quot;:&quot;dd6df065-1ceb-4206-ac51-20ce589d43a0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when non-initiator tries to resolve the dispute&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should fail when non-initiator tries to resolve the dispute&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:109,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(clientB.dispute.resolveDispute({\n    disputeId: disputeId,\n    data: \&quot;0x\&quot;,\n})).to.be.rejectedWith(\&quot;NotDisputeInitiator\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0aaf1043-9825-41df-9640-f3015065461e&quot;,&quot;parentUUID&quot;:&quot;dd6df065-1ceb-4206-ac51-20ce589d43a0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should propagate IMPROPER_REGISTRATION tag to derivative IPs&quot;,&quot;fullTitle&quot;:&quot;Dispute Functions Dispute resolution should propagate IMPROPER_REGISTRATION tag to derivative IPs&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10399,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, oov3_1.settleAssertion)(util_1.TEST_PRIVATE_KEY, disputeId);\n// Verify the dispute state changed correctly\nconst { currentTag: parentCurrentTag, targetTag: parentTargetTag } = await getDisputeState(disputeId);\n(0, chai_1.expect)(parentCurrentTag).to.equal(parentTargetTag);\n// Propagate the tag to both derivative IPs\nconst results = await clientA.dispute.tagIfRelatedIpInfringed({\n    infringementTags: [\n        {\n            ipId: childIpId,\n            disputeId: disputeId,\n        },\n        {\n            ipId: childIpId2,\n            disputeId: disputeId,\n        },\n    ],\n});\nconst logData = results[0].receipt?.logs[0].data;\nconst firstWord = logData.slice(0, 66);\nconst childDisputeId = BigInt(firstWord);\n// Verify successful tagging\n(0, chai_1.expect)(results[0].txHash).to.be.a(\&quot;string\&quot;);\nconst { currentTag: childCurrentTag } = await getDisputeState(childDisputeId);\n// Convert the IMPROPER_USAGE tag to hex for comparison\nconst improperUsageTagHex = (0, viem_1.toHex)(src_1.DisputeTargetTag.IMPROPER_REGISTRATION, { size: 32 });\n// Verify both child IPs have the IMPROPER_USAGE tag by\n// fetching and comparing their dispute tags\n(0, chai_1.expect)(parentCurrentTag).to.equal(parentTargetTag);\n(0, chai_1.expect)(childCurrentTag).to.equal(improperUsageTagHex);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;57cda469-88e5-415b-a863-9e5b10da25c3&quot;,&quot;parentUUID&quot;:&quot;dd6df065-1ceb-4206-ac51-20ce589d43a0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;37c60248-bae4-4db5-8c68-5ea24654b1ea&quot;,&quot;2c2dc2c3-8a6d-47ef-85ad-7073ac0687d0&quot;,&quot;f0ed87e5-43af-48ad-815d-5d1db68de7bf&quot;,&quot;ae57b4fa-378e-4219-9d71-b650ec79c228&quot;,&quot;5bdfada8-6758-4cba-860c-638b9df25b9a&quot;,&quot;0b19fe78-e5d7-4c71-8989-ef815396565c&quot;,&quot;0aaf1043-9825-41df-9640-f3015065461e&quot;,&quot;57cda469-88e5-415b-a863-9e5b10da25c3&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:101558,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;53186009-eaec-451c-adc4-7f4a0e93866f&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:10855,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;d12e2dff-627f-431c-9749-d0b9f8681ae1&quot;,&quot;title&quot;:&quot;Group Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Group Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Group Functions \&quot;before all\&quot; hook in \&quot;Group Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4982,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\n// Create NFT Collection\nspgNftContract = (await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n})).spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;18420c8f-e556-4231-949b-cab50b6577e5&quot;,&quot;parentUUID&quot;:&quot;d12e2dff-627f-431c-9749-d0b9f8681ae1&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;ca12b9f1-7bbc-4786-b5fc-5695da498ac0&quot;,&quot;title&quot;:&quot;Group Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Group Operations\&quot;&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations \&quot;before all\&quot; hook in \&quot;Group Operations\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10914,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create initial IP with license terms\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    allowDuplicates: false,\n    licenseTermsData,\n});\nlicenseTermsId = result.licenseTermsIds[0];\nipId = result.ipId;\n// Set licensing config\nawait client.license.setLicensingConfig({\n    ipId,\n    licenseTermsId,\n    licenseTemplate: generated_1.piLicenseTemplateAddress[util_1.aeneid],\n    licensingConfig: {\n        isSet: true,\n        mintingFee: 0n,\n        licensingHook: viem_1.zeroAddress,\n        hookData: viem_1.zeroAddress,\n        commercialRevShare: 0,\n        disabled: false,\n        expectMinimumGroupRewardShare: 0,\n        expectGroupRewardPool: groupPoolAddress,\n    },\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;923e5ae7-9d41-493c-aca2-e9f838f5a980&quot;,&quot;parentUUID&quot;:&quot;ca12b9f1-7bbc-4786-b5fc-5695da498ac0&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully register group and attach license&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register group and attach license&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4967,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.registerGroupAndAttachLicense({\n    groupPool: groupPoolAddress,\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n});\ngroupId = result.groupId;\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.groupId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8a0e0ed3-3bc4-4886-825b-e0042f9847fa&quot;,&quot;parentUUID&quot;:&quot;ca12b9f1-7bbc-4786-b5fc-5695da498ac0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully mint, register IP, attach license and add to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully mint, register IP, attach license and add to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5290,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.mintAndRegisterIpAndAttachLicenseAndAddToGroup({\n    groupId,\n    spgNftContract,\n    licenseData: [\n        {\n            licenseTermsId,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: groupPoolAddress,\n            },\n        },\n    ],\n    maxAllowedRewardShare: 5,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9e52166f-2978-480d-934c-ad3367df00f6&quot;,&quot;parentUUID&quot;:&quot;ca12b9f1-7bbc-4786-b5fc-5695da498ac0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register a basic group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register a basic group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4926,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.registerGroup({\n    groupPool: groupPoolAddress,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.groupId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6b72e0c2-3b42-4e45-8abf-63ba666503a0&quot;,&quot;parentUUID&quot;:&quot;ca12b9f1-7bbc-4786-b5fc-5695da498ac0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register existing IP with license and add to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register existing IP with license and add to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10399,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(spgNftContract, \&quot;test-metadata\&quot;);\nconst result = await client.groupClient.registerIpAndAttachLicenseAndAddToGroup({\n    groupId,\n    nftContract: spgNftContract,\n    tokenId,\n    maxAllowedRewardShare: 5,\n    licenseData: [\n        {\n            licenseTermsId,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: groupPoolAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;599f394d-d2a0-4ff5-9f81-79541999c981&quot;,&quot;parentUUID&quot;:&quot;ca12b9f1-7bbc-4786-b5fc-5695da498ac0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register group with license and add multiple IPs&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should successfully register group with license and add multiple IPs&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5185,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.registerGroupAndAttachLicenseAndAddIps({\n    groupPool: groupPoolAddress,\n    maxAllowedRewardShare: 5,\n    ipIds: [ipId],\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.groupId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a43de9d4-d484-46ba-9fab-45a60366b580&quot;,&quot;parentUUID&quot;:&quot;ca12b9f1-7bbc-4786-b5fc-5695da498ac0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to add unregistered IP to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations should fail when trying to add unregistered IP to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:96,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.groupClient.registerGroupAndAttachLicenseAndAddIps({\n    groupPool: groupPoolAddress,\n    maxAllowedRewardShare: 5,\n    ipIds: [viem_1.zeroAddress], // Invalid IP address\n    licenseData: {\n        licenseTermsId,\n        licensingConfig: {\n            isSet: true,\n            mintingFee: 0n,\n            licensingHook: viem_1.zeroAddress,\n            hookData: viem_1.zeroAddress,\n            commercialRevShare: 0,\n            disabled: false,\n            expectMinimumGroupRewardShare: 0,\n            expectGroupRewardPool: viem_1.zeroAddress,\n        },\n    },\n})).to.be.rejectedWith(\&quot;Failed to register group and attach license and add ips\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;860ddea4-ceca-47c1-9666-4ede2d4687d6&quot;,&quot;parentUUID&quot;:&quot;ca12b9f1-7bbc-4786-b5fc-5695da498ac0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;9fb871d4-7cf6-49f1-ab51-00d76670825e&quot;,&quot;title&quot;:&quot;Add IPs to Group and Remove IPs from Group&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully add multiple IPs to group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should successfully add multiple IPs to group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15548,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const registerResult = await client.ipAsset.batchMintAndRegisterIpAssetWithPilTerms({\n    args: [\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n        {\n            spgNftContract,\n            licenseTermsData,\n        },\n    ],\n});\nipIds = registerResult.results?.map((result) =&gt; result.ipId) ?? [];\nconst result = await client.groupClient.addIpsToGroup({\n    groupIpId: groupId,\n    ipIds: ipIds,\n    maxAllowedRewardSharePercentage: 5,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;22fe1d08-ab65-4357-95cd-c6144d3d01c6&quot;,&quot;parentUUID&quot;:&quot;9fb871d4-7cf6-49f1-ab51-00d76670825e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully remove IPs from group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should successfully remove IPs from group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5003,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.removeIpsFromGroup({\n    groupIpId: groupId,\n    ipIds: ipIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;807dcd62-7fc4-4d57-9cd8-0663770e7f6e&quot;,&quot;parentUUID&quot;:&quot;9fb871d4-7cf6-49f1-ab51-00d76670825e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to remove IPs from a non-existent group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should fail when trying to remove IPs from a non-existent group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5743,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const registerResult = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData,\n});\nconst testIpId = registerResult.ipId;\nconst nonExistentGroupId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.removeIpsFromGroup({\n    groupIpId: nonExistentGroupId,\n    ipIds: [testIpId],\n})).to.be.rejectedWith(\&quot;Failed to remove IPs from group\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2add67c5-3c74-4f9c-98ee-2f1b47c82259&quot;,&quot;parentUUID&quot;:&quot;9fb871d4-7cf6-49f1-ab51-00d76670825e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to remove non-existent IPs from a group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Group Operations Add IPs to Group and Remove IPs from Group should fail when trying to remove non-existent IPs from a group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5086,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const groupResult = await client.groupClient.registerGroup({\n    groupPool: groupPoolAddress,\n});\nconst testGroupId = groupResult.groupId;\nconst nonExistentIpId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.removeIpsFromGroup({\n    groupIpId: testGroupId,\n    ipIds: [nonExistentIpId],\n})).to.be.rejectedWith(\&quot;Failed to remove IPs from group\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d6353cb1-7614-42bb-9397-2aac1af2c382&quot;,&quot;parentUUID&quot;:&quot;9fb871d4-7cf6-49f1-ab51-00d76670825e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;22fe1d08-ab65-4357-95cd-c6144d3d01c6&quot;,&quot;807dcd62-7fc4-4d57-9cd8-0663770e7f6e&quot;,&quot;2add67c5-3c74-4f9c-98ee-2f1b47c82259&quot;,&quot;d6353cb1-7614-42bb-9397-2aac1af2c382&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:31380,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;8a0e0ed3-3bc4-4886-825b-e0042f9847fa&quot;,&quot;9e52166f-2978-480d-934c-ad3367df00f6&quot;,&quot;6b72e0c2-3b42-4e45-8abf-63ba666503a0&quot;,&quot;599f394d-d2a0-4ff5-9f81-79541999c981&quot;,&quot;a43de9d4-d484-46ba-9fab-45a60366b580&quot;,&quot;860ddea4-ceca-47c1-9666-4ede2d4687d6&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:30863,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;809447e0-4ac1-4e4c-bcea-ef1e39104412&quot;,&quot;title&quot;:&quot;Collect Royalty and Claim Reward&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/group.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/group.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Collect Royalty and Claim Reward\&quot;&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward \&quot;before all\&quot; hook in \&quot;Collect Royalty and Claim Reward\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10835,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Register IP id\nconst result1 = await mintAndRegisterIpAssetWithPilTermsHelper();\nipId = result1.ipId;\nlicenseTermsId = result1.licenseTermsIds[0];\n// Register group id\ngroupIpId = await registerGroupAndAttachLicenseHelper(licenseTermsId, [ipId]);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;04ac10ab-5e2e-40a2-bc1f-0e20bd5165ce&quot;,&quot;parentUUID&quot;:&quot;809447e0-4ac1-4e4c-bcea-ef1e39104412&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully collect royalties&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully collect royalties&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:25409,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Mint and register child IP id\nconst childIpId = await mintAndRegisterIpAndMakeDerivativeHelper(groupIpId, licenseTermsId);\n// Pay royalties from child IP id to group IP id and transfer to vault\nawait payRoyaltyAndTransferToVaultHelper(childIpId, groupIpId, src_1.WIP_TOKEN_ADDRESS, 100n);\n// Collect royalties\nconst result = await client.groupClient.collectRoyalties({\n    groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.collectedRoyalties).to.equal(10n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3b14e88c-9b1c-4d71-9ab7-9599cccc71df&quot;,&quot;parentUUID&quot;:&quot;809447e0-4ac1-4e4c-bcea-ef1e39104412&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully get claimable reward&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully get claimable reward&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:91,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.groupClient.getClaimableReward({\n    groupIpId: groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n});\n(0, chai_1.expect)(result).to.deep.equal([10n]);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;aef315fb-3805-4243-95ec-9ec8bbd7d4ac&quot;,&quot;parentUUID&quot;:&quot;809447e0-4ac1-4e4c-bcea-ef1e39104412&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully claim reward&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully claim reward&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10415,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Mint license tokens to the IP id which doesn&#x27;t have a royalty vault\nawait client.license.mintLicenseTokens({\n    licensorIpId: ipId,\n    licenseTermsId,\n    amount: 100,\n    maxMintingFee: 1,\n    maxRevenueShare: 100,\n});\n// Claim reward\nconst result = await client.groupClient.claimReward({\n    groupIpId: groupIpId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.claimedReward?.[0].amount[0]).to.equal(10n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;08f4fb2d-7a43-4b35-b399-54a2fae98b94&quot;,&quot;parentUUID&quot;:&quot;809447e0-4ac1-4e4c-bcea-ef1e39104412&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to claim reward for a non-existent group&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should fail when trying to claim reward for a non-existent group&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:113,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const nonExistentGroupId = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.claimReward({\n    groupIpId: nonExistentGroupId,\n    currencyToken: src_1.WIP_TOKEN_ADDRESS,\n    memberIpIds: [ipId],\n})).to.be.rejectedWith(\&quot;Failed to claim reward\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;cbed4ab6-6822-4680-9b64-ee773fdffb72&quot;,&quot;parentUUID&quot;:&quot;809447e0-4ac1-4e4c-bcea-ef1e39104412&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to claim reward with invalid token address&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should fail when trying to claim reward with invalid token address&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:90,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const invalidTokenAddress = viem_1.zeroAddress;\nawait (0, chai_1.expect)(client.groupClient.claimReward({\n    groupIpId: groupIpId,\n    currencyToken: invalidTokenAddress,\n    memberIpIds: [ipId],\n})).to.be.rejectedWith(\&quot;Failed to claim reward\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;593fc6f9-fc55-461a-815d-2a0fe2268eaf&quot;,&quot;parentUUID&quot;:&quot;809447e0-4ac1-4e4c-bcea-ef1e39104412&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully collect royalties and claim reward in one transaction&quot;,&quot;fullTitle&quot;:&quot;Group Functions Collect Royalty and Claim Reward should successfully collect royalties and claim reward in one transaction&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:62775,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const ipIds = [];\nconst result1 = await mintAndRegisterIpAssetWithPilTermsHelper();\nconst result2 = await mintAndRegisterIpAssetWithPilTermsHelper();\nipIds.push(result1.ipId);\nipIds.push(result2.ipId);\nlicenseTermsId = result1.licenseTermsIds[0];\nconst groupId = await registerGroupAndAttachLicenseHelper(licenseTermsId, ipIds);\nconst childIpId1 = await mintAndRegisterIpAndMakeDerivativeHelper(groupId, licenseTermsId);\nconst childIpId2 = await mintAndRegisterIpAndMakeDerivativeHelper(groupId, licenseTermsId);\nawait payRoyaltyAndTransferToVaultHelper(childIpId1, groupId, src_1.WIP_TOKEN_ADDRESS, 100n);\nawait payRoyaltyAndTransferToVaultHelper(childIpId2, groupId, src_1.WIP_TOKEN_ADDRESS, 100n);\nconst result = await client.groupClient.collectAndDistributeGroupRoyalties({\n    groupIpId: groupId,\n    currencyTokens: [src_1.WIP_TOKEN_ADDRESS],\n    memberIpIds: ipIds,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.collectedRoyalties?.[0].amount).to.equal(20n);\n(0, chai_1.expect)(result.royaltiesDistributed?.[0].amount).to.equal(10n);\n(0, chai_1.expect)(result.royaltiesDistributed?.[1].amount).to.equal(10n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;03abbf89-8533-483c-bdc5-3cdeff6b635c&quot;,&quot;parentUUID&quot;:&quot;809447e0-4ac1-4e4c-bcea-ef1e39104412&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;3b14e88c-9b1c-4d71-9ab7-9599cccc71df&quot;,&quot;aef315fb-3805-4243-95ec-9ec8bbd7d4ac&quot;,&quot;08f4fb2d-7a43-4b35-b399-54a2fae98b94&quot;,&quot;cbed4ab6-6822-4680-9b64-ee773fdffb72&quot;,&quot;593fc6f9-fc55-461a-815d-2a0fe2268eaf&quot;,&quot;03abbf89-8533-483c-bdc5-3cdeff6b635c&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:98893,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;5a959d8a-dfb1-472a-936c-a0a4037630dc&quot;,&quot;title&quot;:&quot;IPAccount Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;IPAccount Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions \&quot;before all\&quot; hook in \&quot;IPAccount Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14226,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = registerResult.ipId;\ndata = (0, viem_1.encodeFunctionData)({\n    abi: generated_1.accessControllerAbi,\n    functionName: \&quot;setTransientPermission\&quot;,\n    args: [\n        (0, viem_1.getAddress)(ipId),\n        (0, viem_1.getAddress)(util_1.TEST_WALLET_ADDRESS),\n        (0, viem_1.getAddress)(coreMetadataModule),\n        (0, viem_1.toFunctionSelector)(\&quot;function setAll(address,string,bytes32,bytes32)\&quot;),\n        src_1.AccessPermission.ALLOW,\n    ],\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;02dccdf3-c8b2-4296-aa3d-4f67553c164f&quot;,&quot;parentUUID&quot;:&quot;5a959d8a-dfb1-472a-936c-a0a4037630dc&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully set ip metadata&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions should successfully set ip metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4959,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txHash = await client.ipAccount.setIpMetadata({\n    ipId: ipId,\n    metadataURI: \&quot;https://example.com\&quot;,\n    metadataHash: (0, viem_1.toHex)(\&quot;test\&quot;, { size: 32 }),\n});\n(0, chai_1.expect)(txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;67456ac5-bc52-4a52-a405-c275faa59290&quot;,&quot;parentUUID&quot;:&quot;5a959d8a-dfb1-472a-936c-a0a4037630dc&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully transfer ERC20 tokens&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions should successfully transfer ERC20 tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:20570,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const erc20 = new generated_1.Erc20Client(util_1.publicClient, util_1.walletClient);\n// 1. Query token balance of ipId and wallet before\nconst initialErc20BalanceOfIpId = await erc20.balanceOf({\n    account: ipId,\n});\nconst initialErc20BalanceOfWallet = await erc20.balanceOf({\n    account: util_1.TEST_WALLET_ADDRESS,\n});\nconst initialWipBalanceOfIpId = await client.wipClient.balanceOf(ipId);\nconst initialWipBalanceOfWallet = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n// 2. transfer erc20 token to the ip account\nconst txHash = await erc20.mint({\n    to: ipId,\n    amount: (0, viem_1.parseEther)(\&quot;0.002\&quot;),\n});\nawait util_1.publicClient.waitForTransactionReceipt({\n    hash: txHash,\n});\n// 3. transfer wip to the ip account\nawait client.wipClient.deposit({\n    amount: 1n,\n});\nawait client.wipClient.transfer({\n    to: ipId,\n    amount: 1n,\n});\n// 4. transfer token of ip account to wallet address\nconst ret = await client.ipAccount.transferErc20({\n    ipId,\n    tokens: [\n        {\n            address: src_1.WIP_TOKEN_ADDRESS,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: 1n,\n        },\n        {\n            address: erc20.address,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: (0, viem_1.parseEther)(\&quot;0.001\&quot;),\n        },\n        {\n            address: erc20.address,\n            target: util_1.TEST_WALLET_ADDRESS,\n            amount: (0, viem_1.parseEther)(\&quot;0.001\&quot;),\n        },\n    ],\n});\n// 5. query token balance of ipId and wallet address after\nconst finalErc20BalanceOfIpId = await erc20.balanceOf({\n    account: ipId,\n});\nconst finalWipBalanceOfIpId = await client.wipClient.balanceOf(ipId);\nconst finalErc20BalanceOfWallet = await erc20.balanceOf({\n    account: util_1.TEST_WALLET_ADDRESS,\n});\nconst finalWipBalanceOfWallet = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(ret.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(finalErc20BalanceOfIpId).to.equal(initialErc20BalanceOfIpId);\n(0, chai_1.expect)(finalWipBalanceOfIpId).to.equal(initialWipBalanceOfIpId);\n(0, chai_1.expect)(finalErc20BalanceOfWallet).to.equal(initialErc20BalanceOfWallet + (0, viem_1.parseEther)(\&quot;0.002\&quot;));\n(0, chai_1.expect)(finalWipBalanceOfWallet).to.equal(initialWipBalanceOfWallet + 1n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f40c71bc-66ee-4e88-b68f-ea2a4a433d15&quot;,&quot;parentUUID&quot;:&quot;5a959d8a-dfb1-472a-936c-a0a4037630dc&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;5babf9fb-576e-4a5d-80e9-de569cd63516&quot;,&quot;title&quot;:&quot;execute&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully execute a transaction&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions execute should successfully execute a transaction&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4966,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.ipAccount.execute({\n    to: permissionAddress,\n    value: 0,\n    data: data,\n    ipId: ipId,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0781c4f7-07be-4806-b418-7851b77103e3&quot;,&quot;parentUUID&quot;:&quot;5babf9fb-576e-4a5d-80e9-de569cd63516&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid ipId&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions execute should fail with invalid ipId&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:106,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.execute({\n    to: permissionAddress,\n    value: 0,\n    data: data,\n    ipId: \&quot;0x0000000000000000000000000000000000000000\&quot;,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;33036766-1829-4853-b04f-5bda29c98311&quot;,&quot;parentUUID&quot;:&quot;5babf9fb-576e-4a5d-80e9-de569cd63516&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;0781c4f7-07be-4806-b418-7851b77103e3&quot;,&quot;33036766-1829-4853-b04f-5bda29c98311&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:5072,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;8372e43e-8ee6-4a86-9381-27477ca5c9be&quot;,&quot;title&quot;:&quot;executeWithSig&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully execute with valid signature&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should successfully execute with valid signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5065,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Get the IP Account nonce (state)\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\n// Generate signature for the execute operation itself\n// We need to sign the data that will be executed, not the permission data\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\n// Execute with signature\nconst response = await client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f5535ae2-d9a6-4f37-aace-bb3d865ad37b&quot;,&quot;parentUUID&quot;:&quot;8372e43e-8ee6-4a86-9381-27477ca5c9be&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with expired deadline&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with expired deadline&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:94,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: EXPIRED_DEADLINE,\n    signature: \&quot;0x\&quot;,\n})).to.be.rejectedWith(\&quot;IPAccount__ExpiredSignature\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1d415d69-ebef-4e05-9a3e-e5ae2d3a28b4&quot;,&quot;parentUUID&quot;:&quot;8372e43e-8ee6-4a86-9381-27477ca5c9be&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid signature format&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with invalid signature format&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:95,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: \&quot;0x1234567890abcdef\&quot;, // Invalid signature format\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2ad4e83d-f3e6-4523-b080-ae8405417662&quot;,&quot;parentUUID&quot;:&quot;8372e43e-8ee6-4a86-9381-27477ca5c9be&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with signature from wrong signer&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with signature from wrong signer&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:179,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Generate signature with wrong signer\nconst wrongSigner = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: wrongSigner,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;88ea9c6f-0af0-4c00-bdb0-19a3dc6b9c86&quot;,&quot;parentUUID&quot;:&quot;8372e43e-8ee6-4a86-9381-27477ca5c9be&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid ipId format&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with invalid ipId format&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:92,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: \&quot;0x123\&quot;, // Invalid address format\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;Invalid address: 0x123.\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6f86cc62-961b-43ea-9dfe-93505590c84e&quot;,&quot;parentUUID&quot;:&quot;8372e43e-8ee6-4a86-9381-27477ca5c9be&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when IP account does not exist&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail when IP account does not exist&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:96,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create a real non-existent IP address (but with correct format)\nconst nonExistentIpId = \&quot;0x1111111111111111111111111111111111111111\&quot;;\n// Generate signature for this non-existent IP\n// Note: We need to try to get nonce first, if IP doesn&#x27;t exist, this step should fail\ntry {\n    const nonceResult = await client.ipAccount.getIpAccountNonce(nonExistentIpId);\n    const { signature } = await (0, src_1.getSignature)({\n        state: nonceResult,\n        to: permissionAddress,\n        encodeData: data,\n        wallet: util_1.walletClient,\n        verifyingContract: nonExistentIpId, // Use non-existent IP as verifying contract\n        deadline: VALID_DEADLINE,\n        chainId: util_1.aeneid,\n    });\n    await (0, chai_1.expect)(client.ipAccount.executeWithSig({\n        to: permissionAddress,\n        data: data,\n        ipId: nonExistentIpId,\n        signer: util_1.TEST_WALLET_ADDRESS,\n        deadline: VALID_DEADLINE,\n        signature: signature,\n    })).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;); // Should fail because IP doesn&#x27;t exist\n}\ncatch (error) {\n    // If getting nonce fails, it means IP indeed doesn&#x27;t exist, which is also our expected result\n    (0, chai_1.expect)(error.message).to.include(\&quot;Failed to get the IP Account nonce\&quot;);\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6f466e74-ca62-4f42-895d-884362729a9c&quot;,&quot;parentUUID&quot;:&quot;8372e43e-8ee6-4a86-9381-27477ca5c9be&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with unauthorized signer&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with unauthorized signer&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:177,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Test various unauthorized signer scenarios\nconst unauthorizedSigner = \&quot;0x2222222222222222222222222222222222222222\&quot;;\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: unauthorizedSigner, // Unauthorized signer\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;); // Contract returns InvalidSignature for permission issues&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;218c9a60-5edf-4674-8f88-3e88caef4fe4&quot;,&quot;parentUUID&quot;:&quot;8372e43e-8ee6-4a86-9381-27477ca5c9be&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with signature for wrong data&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with signature for wrong data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:203,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Generate signature for different data than what we execute\nconst wrongData = (0, viem_1.encodeFunctionData)({\n    abi: generated_1.accessControllerAbi,\n    functionName: \&quot;setTransientPermission\&quot;,\n    args: [\n        (0, viem_1.getAddress)(\&quot;0x1234567890123456789012345678901234567890\&quot;),\n        (0, viem_1.getAddress)(util_1.TEST_WALLET_ADDRESS),\n        (0, viem_1.getAddress)(coreMetadataModule),\n        (0, viem_1.toFunctionSelector)(\&quot;function setAll(address,string,bytes32,bytes32)\&quot;),\n        src_1.AccessPermission.DENY,\n    ],\n});\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: wrongData, // Sign wrong data\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data, // Execute with original data, not the signed data\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;); // Should fail because data doesn&#x27;t match signature&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;100c81b9-258b-4fe4-81cc-9a33cbb76893&quot;,&quot;parentUUID&quot;:&quot;8372e43e-8ee6-4a86-9381-27477ca5c9be&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with signature for wrong target address&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should fail with signature for wrong target address&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:182,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Generate signature for different target address than what we execute\nconst wrongTarget = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: wrongTarget, // Sign for wrong target\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nawait (0, chai_1.expect)(client.ipAccount.executeWithSig({\n    to: permissionAddress, // Execute with original target, not the signed target\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n})).to.be.rejectedWith(\&quot;IPAccount__InvalidSignature\&quot;); // Should fail because target doesn&#x27;t match signature&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2d42d13e-1b47-4224-8949-5df333e98ab4&quot;,&quot;parentUUID&quot;:&quot;8372e43e-8ee6-4a86-9381-27477ca5c9be&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should execute with zero value transaction&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions executeWithSig should execute with zero value transaction&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5073,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Test successful execution with zero value\nconst nonceResult = await client.ipAccount.getIpAccountNonce(ipId);\nconst { signature } = await (0, src_1.getSignature)({\n    state: nonceResult,\n    to: permissionAddress,\n    encodeData: data,\n    wallet: util_1.walletClient,\n    verifyingContract: ipId,\n    deadline: VALID_DEADLINE,\n    chainId: util_1.aeneid,\n});\nconst response = await client.ipAccount.executeWithSig({\n    to: permissionAddress,\n    data: data,\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    deadline: VALID_DEADLINE,\n    signature: signature,\n    value: 0, // Explicitly set zero value\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;edf39949-c50d-4418-b940-ad5449a1b78e&quot;,&quot;parentUUID&quot;:&quot;8372e43e-8ee6-4a86-9381-27477ca5c9be&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;f5535ae2-d9a6-4f37-aace-bb3d865ad37b&quot;,&quot;1d415d69-ebef-4e05-9a3e-e5ae2d3a28b4&quot;,&quot;2ad4e83d-f3e6-4523-b080-ae8405417662&quot;,&quot;88ea9c6f-0af0-4c00-bdb0-19a3dc6b9c86&quot;,&quot;6f86cc62-961b-43ea-9dfe-93505590c84e&quot;,&quot;6f466e74-ca62-4f42-895d-884362729a9c&quot;,&quot;218c9a60-5edf-4674-8f88-3e88caef4fe4&quot;,&quot;100c81b9-258b-4fe4-81cc-9a33cbb76893&quot;,&quot;2d42d13e-1b47-4224-8949-5df333e98ab4&quot;,&quot;edf39949-c50d-4418-b940-ad5449a1b78e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:11256,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;a731c048-b7fe-47d9-b6d3-f4b48a1e1b90&quot;,&quot;title&quot;:&quot;getIpAccountNonce&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully return account nonce&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getIpAccountNonce should successfully return account nonce&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:125,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.ipAccount.getIpAccountNonce(ipId);\n(0, chai_1.expect)(response).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3db5fac9-3ff7-4bcd-89eb-f4950b157684&quot;,&quot;parentUUID&quot;:&quot;a731c048-b7fe-47d9-b6d3-f4b48a1e1b90&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid ipId&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getIpAccountNonce should fail with invalid ipId&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:95,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.getIpAccountNonce(\&quot;0x0000000000000000000000000000000000000000\&quot;))\n    .to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;163c1902-76f8-44bc-84ae-4287c5655d8c&quot;,&quot;parentUUID&quot;:&quot;a731c048-b7fe-47d9-b6d3-f4b48a1e1b90&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;3db5fac9-3ff7-4bcd-89eb-f4950b157684&quot;,&quot;163c1902-76f8-44bc-84ae-4287c5655d8c&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:220,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;b94db483-e420-4747-9c45-eac77a9241c7&quot;,&quot;title&quot;:&quot;getToken&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAccount.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAccount.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully return token information&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getToken should successfully return token information&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:102,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.ipAccount.getToken(ipId);\n(0, chai_1.expect)(response.chainId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(response.tokenContract).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.tokenId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(response.tokenContract).to.equal(util_1.mockERC721);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c69ce95d-d271-4865-8dd0-34473c94fca6&quot;,&quot;parentUUID&quot;:&quot;b94db483-e420-4747-9c45-eac77a9241c7&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid ipId&quot;,&quot;fullTitle&quot;:&quot;IPAccount Functions getToken should fail with invalid ipId&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:94,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAccount.getToken(\&quot;0x0000000000000000000000000000000000000000\&quot;)).to.be\n    .rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b8639df1-834a-4a70-b28a-c93c57b074af&quot;,&quot;parentUUID&quot;:&quot;b94db483-e420-4747-9c45-eac77a9241c7&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;c69ce95d-d271-4865-8dd0-34473c94fca6&quot;,&quot;b8639df1-834a-4a70-b28a-c93c57b074af&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:196,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;67456ac5-bc52-4a52-a405-c275faa59290&quot;,&quot;f40c71bc-66ee-4e88-b68f-ea2a4a433d15&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:25529,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;382efa84-48fb-4564-82c7-e60618a15ecc&quot;,&quot;title&quot;:&quot;IP Asset Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;IP Asset Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions \&quot;before all\&quot; hook in \&quot;IP Asset Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:97,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst res = await client.license.registerPILTerms(src_1.PILFlavor.nonCommercialSocialRemixing());\nnoCommercialLicenseTermsId = res.licenseTermsId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1144666a-fc0d-457f-be3f-7ecf2933619d&quot;,&quot;parentUUID&quot;:&quot;382efa84-48fb-4564-82c7-e60618a15ecc&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;608e1cb0-a9da-4448-97db-0de727afda87&quot;,&quot;title&quot;:&quot;Basic IP Asset Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register an IP Asset&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register an IP Asset&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14181,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nchildIpId = response.ipId;\n(0, chai_1.expect)(childIpId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3b17041e-b370-44b7-b0f7-f152331b4794&quot;,&quot;parentUUID&quot;:&quot;608e1cb0-a9da-4448-97db-0de727afda87&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register an IP Asset with multiple metadata fields&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register an IP Asset with multiple metadata fields&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14326,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    ipMetadata: {\n        ipMetadataURI: \&quot;ipfs://test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataURI: \&quot;ipfs://test-nft-uri\&quot;,\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\nchildIpId2 = response.ipId;\n(0, chai_1.expect)(response.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;258f99c3-53be-4402-9ff7-8606381ef54a&quot;,&quot;parentUUID&quot;:&quot;608e1cb0-a9da-4448-97db-0de727afda87&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should not register with invalid metadata hash length&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should not register with invalid metadata hash length&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5206,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    ipMetadata: {\n        ipMetadataHash: \&quot;0x123\&quot;, // Invalid length hash\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;valid-hash\&quot;, { size: 32 }),\n    },\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9929ec4e-19e1-4111-8193-54293b80c182&quot;,&quot;parentUUID&quot;:&quot;608e1cb0-a9da-4448-97db-0de727afda87&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should not register with non-existent token ID&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should not register with non-existent token ID&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:265,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: BigInt(Number.MAX_SAFE_INTEGER),\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;aa1c7e1c-66fc-4859-b8c7-42cbaa2466c1&quot;,&quot;parentUUID&quot;:&quot;608e1cb0-a9da-4448-97db-0de727afda87&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with Non-Commercial Remix PIL&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with Non-Commercial Remix PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:28992,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nparentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [noCommercialLicenseTermsId],\n    maxMintingFee: \&quot;0\&quot;,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: \&quot;0\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d95a45dc-e237-46f2-8dff-948dab1c638a&quot;,&quot;parentUUID&quot;:&quot;608e1cb0-a9da-4448-97db-0de727afda87&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with Commercial Remix PIL&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with Commercial Remix PIL&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:25228,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Register commercial remix PIL\nconst licenseResponse = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 10n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n}));\n// Register parent IP\nconst tokenId = await (0, util_1.getTokenId)();\nconst commercialParentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\n// Attach license terms to parent IP\nawait client.license.attachLicenseTerms({\n    ipId: commercialParentIpId,\n    licenseTermsId: licenseResponse.licenseTermsId,\n});\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: childIpId2,\n    parentIpIds: [commercialParentIpId],\n    licenseTermsIds: [licenseResponse.licenseTermsId],\n    maxMintingFee: \&quot;100\&quot;,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: \&quot;100\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6b2c3342-f880-4ddb-a503-19f352b080eb&quot;,&quot;parentUUID&quot;:&quot;608e1cb0-a9da-4448-97db-0de727afda87&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with multiple parent IPs&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with multiple parent IPs&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:54722,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create first parent IP\nconst tokenId1 = await (0, util_1.getTokenId)();\nconst parentIpId1 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n})).ipId;\n// Create second parent IP\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst parentIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId2,\n})).ipId;\n// Attach license terms to both parents\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId1,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId2,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\n// Create child IP\nconst childTokenId = await (0, util_1.getTokenId)();\nconst newChildIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId,\n})).ipId;\n// Register derivative with multiple parents\nconst response = await client.ipAsset.registerDerivative({\n    childIpId: newChildIpId,\n    parentIpIds: [parentIpId1, parentIpId2],\n    licenseTermsIds: [noCommercialLicenseTermsId, noCommercialLicenseTermsId],\n    maxMintingFee: \&quot;0\&quot;,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: \&quot;0\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f5aaf764-0374-4eb3-a856-9ab5f988b858&quot;,&quot;parentUUID&quot;:&quot;608e1cb0-a9da-4448-97db-0de727afda87&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should register derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:24677,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst ipId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: noCommercialLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \&quot;0\&quot;,\n    maxRevenueShare: 1,\n});\nconst response = await client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;db35e897-037c-493e-a965-8d39b6d6c7d0&quot;,&quot;parentUUID&quot;:&quot;608e1cb0-a9da-4448-97db-0de727afda87&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should return true if IP asset is registered&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should return true if IP asset is registered&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:104,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const isRegistered = await client.ipAsset.isRegistered(parentIpId);\n(0, chai_1.expect)(isRegistered).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a776e12f-9815-4310-b596-8fe2c5f4a4c6&quot;,&quot;parentUUID&quot;:&quot;608e1cb0-a9da-4448-97db-0de727afda87&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should return false if IP asset is not registered&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Basic IP Asset Operations should return false if IP asset is not registered&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:97,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const isRegistered = await client.ipAsset.isRegistered(\&quot;0x1234567890123456789012345678901234567890\&quot;);\n(0, chai_1.expect)(isRegistered).to.equal(false);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6a87b4ff-bc8b-4d97-b365-4c3ba79a2388&quot;,&quot;parentUUID&quot;:&quot;608e1cb0-a9da-4448-97db-0de727afda87&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;3b17041e-b370-44b7-b0f7-f152331b4794&quot;,&quot;258f99c3-53be-4402-9ff7-8606381ef54a&quot;,&quot;9929ec4e-19e1-4111-8193-54293b80c182&quot;,&quot;aa1c7e1c-66fc-4859-b8c7-42cbaa2466c1&quot;,&quot;d95a45dc-e237-46f2-8dff-948dab1c638a&quot;,&quot;6b2c3342-f880-4ddb-a503-19f352b080eb&quot;,&quot;f5aaf764-0374-4eb3-a856-9ab5f988b858&quot;,&quot;db35e897-037c-493e-a965-8d39b6d6c7d0&quot;,&quot;a776e12f-9815-4310-b596-8fe2c5f4a4c6&quot;,&quot;6a87b4ff-bc8b-4d97-b365-4c3ba79a2388&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:167798,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;title&quot;:&quot;SPG NFT Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;SPG NFT Operations\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations \&quot;before all\&quot; hook in \&quot;SPG NFT Operations\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:16510,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Setup NFT collection\nconst txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\n// Setup license terms\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContract,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];\n// Setup ERC20\nconst mockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\nawait mockERC20.approve(generated_1.derivativeWorkflowsAddress[util_1.aeneid], viem_1.maxUint256);\nawait mockERC20.approve(generated_1.royaltyTokenDistributionWorkflowsAddress[util_1.aeneid], viem_1.maxUint256);\nawait mockERC20.mint(util_1.TEST_WALLET_ADDRESS, 100000n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9b47c9a5-159c-447d-8d4a-7d9571d273a7&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register IP Asset with metadata&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP Asset with metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10173,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst response = await client.ipAsset.register({\n    nftContract,\n    tokenId,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(response.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1a47920b-4e53-46d0-892a-7076810c279c&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative IP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register derivative IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10805,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenChildId = await (0, util_1.mintBySpg)(nftContract);\nconst result = await client.ipAsset.registerDerivativeIp({\n    nftContract: nftContract,\n    tokenId: tokenChildId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: \&quot;0\&quot;,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: \&quot;0\&quot;,\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;604be945-ecc1-4d6b-be3a-74a72485d852&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach PIL terms&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach PIL terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11061,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: nftContract,\n    tokenId,\n    deadline: 1000n,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.commercialUse({\n                defaultMintingFee: 10000n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 10000n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c287974a-ff03-43ba-acd9-8cf2025c6583&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach PIL terms with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach PIL terms with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11643,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 10000n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;71130017-b970-49d5-af52-e42b975d435a&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and make derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and make derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5752,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContract,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 1n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;78647692-1af1-495e-a2df-562e369a1741&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5124,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: nftContract,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    allowDuplicates: false,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4a741dc1-19aa-4115-8a04-c8cadd8b4929&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register PIL terms and attach&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register PIL terms and attach&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5610,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerPilTermsAndAttach({\n    ipId: parentIpId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.nonCommercialSocialRemixing(),\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;46765d5a-f278-4a82-adbb-2c9e76f76d95&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register PIL terms and attach with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register PIL terms and attach with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7092,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerPilTermsAndAttach({\n    ipId: parentIpId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: viem_1.zeroAddress,\n                defaultMintingFee: 0n,\n                expiration: 0n,\n                commercialUse: false,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f6e42f7a-1606-4ba5-b5c8-28b0b668d73c&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and make derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and make derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15482,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \&quot;0\&quot;,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], mintLicenseTokensResult.licenseTokenIds[0]);\nconst result = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: nftContract,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5c419d0e-4dda-49b2-bc04-19cc79848021&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and make derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and make derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:20562,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \&quot;0\&quot;,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], mintLicenseTokensResult.licenseTokenIds[0]);\nconst result = await client.ipAsset.registerIpAndMakeDerivativeWithLicenseTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4e872204-ef9f-4b53-bad0-40e770c23231&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach license terms and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17402,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 10,\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 1,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e40d13de-f5c8-4349-8a39-4e785c71f403&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach license terms and distribute royalty tokens with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18346,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 1,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ce721c9a-3237-47d2-978f-27a566429663&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register IP and attach license terms and distribute royalty tokens with complex royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register IP and attach license terms and distribute royalty tokens with complex royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:16286,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: nftContract,\n    tokenId,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: generated_1.erc20Address[util_1.aeneid],\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 1n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 43,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 17,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 2,\n        },\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 38,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;undefined\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;93bb0dfa-b62f-4340-8ba8-e798e7e52502&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should register derivative and attach license terms and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should register derivative and attach license terms and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:20423,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: \&quot;0\&quot;,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: \&quot;0\&quot;,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5b650e7b-6281-4b92-bdee-125ddce65e1c&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and attach PIL terms and distribute royalty tokens without licensing config&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and attach PIL terms and distribute royalty tokens without licensing config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5850,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: nftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c553ad6f-daad-4203-9f11-bd1ee3fa8071&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint and register IP and attach PIL terms and distribute royalty tokens with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG NFT Operations should mint and register IP and attach PIL terms and distribute royalty tokens with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7411,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: nftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            maxLicenseTokens: 100,\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 11n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 0n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(3);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ce06b577-aae4-4d35-9a16-01509f23b64c&quot;,&quot;parentUUID&quot;:&quot;e0bc46bf-3715-4e8d-bad4-c444dbc90e64&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1a47920b-4e53-46d0-892a-7076810c279c&quot;,&quot;604be945-ecc1-4d6b-be3a-74a72485d852&quot;,&quot;c287974a-ff03-43ba-acd9-8cf2025c6583&quot;,&quot;71130017-b970-49d5-af52-e42b975d435a&quot;,&quot;78647692-1af1-495e-a2df-562e369a1741&quot;,&quot;4a741dc1-19aa-4115-8a04-c8cadd8b4929&quot;,&quot;46765d5a-f278-4a82-adbb-2c9e76f76d95&quot;,&quot;f6e42f7a-1606-4ba5-b5c8-28b0b668d73c&quot;,&quot;5c419d0e-4dda-49b2-bc04-19cc79848021&quot;,&quot;4e872204-ef9f-4b53-bad0-40e770c23231&quot;,&quot;e40d13de-f5c8-4349-8a39-4e785c71f403&quot;,&quot;ce721c9a-3237-47d2-978f-27a566429663&quot;,&quot;93bb0dfa-b62f-4340-8ba8-e798e7e52502&quot;,&quot;5b650e7b-6281-4b92-bdee-125ddce65e1c&quot;,&quot;c553ad6f-daad-4203-9f11-bd1ee3fa8071&quot;,&quot;ce06b577-aae4-4d35-9a16-01509f23b64c&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:189022,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;680921c1-9883-488b-ba3c-2a85eb20bc35&quot;,&quot;title&quot;:&quot;SPG With Minting Fees with Public Minting SPG NFT Contract&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;SPG With Minting Fees with Public Minting SPG NFT Contract\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract \&quot;before all\&quot; hook in \&quot;SPG With Minting Fees with Public Minting SPG NFT Contract\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:16237,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// ensure we start with no wip since we will be wrapping them\nconst wipBalance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nif (wipBalance &gt; 0n) {\n    await client.wipClient.withdraw({\n        amount: wipBalance,\n    });\n}\n// create a nft collection that requires minting fee\nconst rsp = await client.nftClient.createNFTCollection({\n    name: \&quot;Premium Collection\&quot;,\n    symbol: \&quot;PC\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 100n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nnftContractWithMintingFee = rsp.spgNftContract;\n// create parent ip with minting fee\nconst result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: nftContractWithMintingFee,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 150n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: true,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: BigInt(0),\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: BigInt(0),\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 150n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0f0cab7a-6876-4255-9f99-18029220035f&quot;,&quot;parentUUID&quot;:&quot;680921c1-9883-488b-ba3c-2a85eb20bc35&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should auto wrap ip when mint and register derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6779,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const userBalanceBefore = await client.getWalletBalance();\nconst rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: nftContractWithMintingFee, // pay 100 here\n    derivData: {\n        parentIpIds: [parentIpId], // pay 150 here\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test\&quot;,\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \&quot;test\&quot;,\n        nftMetadataHash: viem_1.zeroHash,\n    },\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);\nconst userBalanceAfter = await client.getWalletBalance();\nconst cost = 150n + 100n;\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - cost));\n// user should not have any WIP tokens since we swap the exact amount\nconst wipBalance = await client.ipAsset.wipClient.balanceOf({\n    owner: util_1.TEST_WALLET_ADDRESS,\n});\n(0, chai_1.expect)(wipBalance.result).to.be.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;62de0c35-9db5-4110-a99c-6c436822eb12&quot;,&quot;parentUUID&quot;:&quot;680921c1-9883-488b-ba3c-2a85eb20bc35&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto wrap ip when mint and register derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:34492,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenIds[0]);\n(0, chai_1.expect)(licenseTokenIds).to.be.an(\&quot;array\&quot;);\nconst { txHash, ipId } = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: nftContractWithMintingFee,\n    licenseTokenIds: licenseTokenIds,\n    maxRts: common_1.MAX_ROYALTY_TOKEN,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test\&quot;,\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \&quot;test\&quot;,\n        nftMetadataHash: viem_1.zeroHash,\n    },\n});\n(0, chai_1.expect)(txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(ipId).to.be.a(\&quot;string\&quot;);\nconst isRegistered = await client.ipAsset.isRegistered(ipId);\n(0, chai_1.expect)(isRegistered).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;964ebe8b-811a-4730-bb6c-ac218165ddb3&quot;,&quot;parentUUID&quot;:&quot;680921c1-9883-488b-ba3c-2a85eb20bc35&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto wrap ip when registering derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when registering derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:16443,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst balanceBefore = await client.getWalletBalance();\nconst rsp = await client.ipAsset.registerDerivativeIp({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 150n));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2d0f980a-cab4-42ce-946c-3dbda41ffc96&quot;,&quot;parentUUID&quot;:&quot;680921c1-9883-488b-ba3c-2a85eb20bc35&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should spend existing wip when register derivative and distribute loyalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should spend existing wip when register derivative and distribute loyalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:21348,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nawait client.wipClient.deposit({\n    amount: 150n,\n});\nconst rsp = await client.ipAsset.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.be.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e3c430dc-974a-4764-a0e9-b46b45775eb6&quot;,&quot;parentUUID&quot;:&quot;680921c1-9883-488b-ba3c-2a85eb20bc35&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto wrap ip when mint and register derivative and distribute loyalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions SPG With Minting Fees with Public Minting SPG NFT Contract should auto wrap ip when mint and register derivative and distribute loyalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6405,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens({\n    spgNftContract: nftContractWithMintingFee,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test\&quot;,\n        ipMetadataHash: viem_1.zeroHash,\n        nftMetadataURI: \&quot;test\&quot;,\n        nftMetadataHash: viem_1.zeroHash,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b0e24d29-aa47-4f95-a893-7f2b9d3f7191&quot;,&quot;parentUUID&quot;:&quot;680921c1-9883-488b-ba3c-2a85eb20bc35&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;62de0c35-9db5-4110-a99c-6c436822eb12&quot;,&quot;964ebe8b-811a-4730-bb6c-ac218165ddb3&quot;,&quot;2d0f980a-cab4-42ce-946c-3dbda41ffc96&quot;,&quot;e3c430dc-974a-4764-a0e9-b46b45775eb6&quot;,&quot;b0e24d29-aa47-4f95-a893-7f2b9d3f7191&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:85467,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;eee159cc-e656-4853-86e4-f8fe6d4fa299&quot;,&quot;title&quot;:&quot;IP Asset Registration with Private Minting SPG NFT Contracts&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;IP Asset Registration with Private Minting SPG NFT Contracts\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts \&quot;before all\&quot; hook in \&quot;IP Asset Registration with Private Minting SPG NFT Contracts\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4959,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;Private Minting Collection\&quot;,\n    symbol: \&quot;PMC\&quot;,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 3n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \&quot;\&quot;,\n});\nspgNftContractWithPrivateMinting = privateMintingCollectionResult.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9aa40f6b-e77a-4634-a82a-10a7fc278c42&quot;,&quot;parentUUID&quot;:&quot;eee159cc-e656-4853-86e4-f8fe6d4fa299&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when call mint and register ip asset with pil terms&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip asset with pil terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:21147,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 6n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                commercialRevShare: 90,\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\nparentIpId = result.ipId;\nlicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4c8e04f3-501e-47f0-be13-2bec34520f3a&quot;,&quot;parentUUID&quot;:&quot;eee159cc-e656-4853-86e4-f8fe6d4fa299&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip asset with pil terms with license terms max limit&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip asset with pil terms with license terms max limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12801,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: false,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 5n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 5n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n    ipMetadata: {\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b5a9a559-681f-4a9d-8994-f71ff58108ee&quot;,&quot;parentUUID&quot;:&quot;eee159cc-e656-4853-86e4-f8fe6d4fa299&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip and make derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and make derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15354,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [licenseTermsId],\n        maxMintingFee: 100n,\n        maxRts: 5 * 10 ** 6,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ea3d8a81-9cc6-4335-925f-e605c8d9ee30&quot;,&quot;parentUUID&quot;:&quot;eee159cc-e656-4853-86e4-f8fe6d4fa299&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10479,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n    allowDuplicates: false,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ed96e49d-7d63-4f33-86aa-387064788d36&quot;,&quot;parentUUID&quot;:&quot;eee159cc-e656-4853-86e4-f8fe6d4fa299&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip and make derivative with license tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and make derivative with license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:21235,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \&quot;0\&quot;,\n    maxRevenueShare: 100,\n});\nconst licenseTokenId = mintLicenseTokensResult.licenseTokenIds[0];\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenId);\nconst result = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    licenseTokenIds: [licenseTokenId],\n    maxRts: 5 * 10 ** 6,\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;76a1572f-28b9-4edc-9c92-b9246a926ba2&quot;,&quot;parentUUID&quot;:&quot;eee159cc-e656-4853-86e4-f8fe6d4fa299&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when call mint and register ip and attach pil terms and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should successfully when call mint and register ip and attach pil terms and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11255,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 10000n,\n                expiration: 1000n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;test case\&quot;,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a354ac01-7919-40b2-9c5c-d695a1dc9941&quot;,&quot;parentUUID&quot;:&quot;eee159cc-e656-4853-86e4-f8fe6d4fa299&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should succeed when call mint and register ip and make derivative and distribute royalty tokens&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions IP Asset Registration with Private Minting SPG NFT Contracts should succeed when call mint and register ip and make derivative and distribute royalty tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30666,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    allowDuplicates: true,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 6n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 90,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 6n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: pool,\n            },\n        },\n    ],\n});\nconst newParentIpId = result.ipId;\nconst licenseId = result.licenseTermsIds[0];\nconst rsp = await client.ipAsset.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens({\n    spgNftContract: spgNftContractWithPrivateMinting,\n    derivData: {\n        parentIpIds: [newParentIpId],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(rsp.ipId).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;30e5be6c-7332-4433-8ad6-8a29cd06c565&quot;,&quot;parentUUID&quot;:&quot;eee159cc-e656-4853-86e4-f8fe6d4fa299&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;4c8e04f3-501e-47f0-be13-2bec34520f3a&quot;,&quot;b5a9a559-681f-4a9d-8994-f71ff58108ee&quot;,&quot;ea3d8a81-9cc6-4335-925f-e605c8d9ee30&quot;,&quot;ed96e49d-7d63-4f33-86aa-387064788d36&quot;,&quot;76a1572f-28b9-4edc-9c92-b9246a926ba2&quot;,&quot;a354ac01-7919-40b2-9c5c-d695a1dc9941&quot;,&quot;30e5be6c-7332-4433-8ad6-8a29cd06c565&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:122937,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;a61e01e2-3d82-4e84-94be-855aa6638a1f&quot;,&quot;title&quot;:&quot;Batch Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Batch Operations\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations \&quot;before all\&quot; hook in \&quot;Batch Operations\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15109,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;\nconst tokenId = await (0, util_1.getTokenId)();\nparentIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;30113e6b-7033-46b1-832e-371f5fb3c9f3&quot;,&quot;parentUUID&quot;:&quot;a61e01e2-3d82-4e84-94be-855aa6638a1f&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should batch register derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch register derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:35657,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const childTokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId,\n})).ipId;\nconst childTokenId2 = await (0, util_1.getTokenId)();\nconst childIpId2 = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: childTokenId2,\n})).ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});\nconst result = await client.ipAsset.batchRegisterDerivative({\n    args: [\n        {\n            childIpId: childIpId,\n            parentIpIds: [parentIpId],\n            licenseTermsIds: [noCommercialLicenseTermsId],\n            maxMintingFee: \&quot;0\&quot;,\n            maxRts: 5 * 10 ** 6,\n            maxRevenueShare: \&quot;0\&quot;,\n        },\n        {\n            childIpId: childIpId2,\n            parentIpIds: [parentIpId],\n            licenseTermsIds: [noCommercialLicenseTermsId],\n            maxMintingFee: \&quot;0\&quot;,\n            maxRts: 5 * 10 ** 6,\n            maxRevenueShare: \&quot;0\&quot;,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d12a293e-cfb4-4810-8157-99465dca2067&quot;,&quot;parentUUID&quot;:&quot;a61e01e2-3d82-4e84-94be-855aa6638a1f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should batch mint and register IP asset with PIL terms&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch mint and register IP asset with PIL terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7425,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.batchMintAndRegisterIpAssetWithPilTerms({\n    args: [\n        {\n            spgNftContract: nftContract,\n            licenseTermsData: [\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 8n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \&quot;\&quot;,\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 8n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                    maxLicenseTokens: 100,\n                },\n                {\n                    terms: src_1.PILFlavor.commercialRemix({\n                        defaultMintingFee: 100n,\n                        commercialRevShare: 10,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                    }),\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 100n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                },\n            ],\n        },\n        {\n            spgNftContract: nftContract,\n            licenseTermsData: [\n                {\n                    terms: {\n                        transferable: true,\n                        royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                        defaultMintingFee: 8n,\n                        expiration: 0n,\n                        commercialUse: true,\n                        commercialAttribution: false,\n                        commercializerChecker: viem_1.zeroAddress,\n                        commercializerCheckerData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        commercialRevCeiling: 0n,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesApproval: false,\n                        derivativesReciprocal: true,\n                        derivativeRevCeiling: 0n,\n                        currency: common_1.WIP_TOKEN_ADDRESS,\n                        uri: \&quot;\&quot;,\n                    },\n                    licensingConfig: {\n                        isSet: true,\n                        mintingFee: 8n,\n                        licensingHook: viem_1.zeroAddress,\n                        hookData: viem_1.zeroAddress,\n                        commercialRevShare: 0,\n                        disabled: false,\n                        expectMinimumGroupRewardShare: 0,\n                        expectGroupRewardPool: viem_1.zeroAddress,\n                    },\n                    maxLicenseTokens: 100,\n                },\n            ],\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.results).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.results[0].licenseTermsIds).to.be.an(\&quot;array\&quot;).and.length(2);\n(0, chai_1.expect)(result.results[0].maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;).and.length(1);\n(0, chai_1.expect)(result.results[1].licenseTermsIds).to.be.an(\&quot;array\&quot;).and.length(1);\n(0, chai_1.expect)(result.results[1].maxLicenseTokensTxHashes).to.be.an(\&quot;array\&quot;).and.length(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;32065c39-9332-43d0-8716-cdb26f911cd5&quot;,&quot;parentUUID&quot;:&quot;a61e01e2-3d82-4e84-94be-855aa6638a1f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should batch mint and register IP asset and make derivative&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch mint and register IP asset and make derivative&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10316,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract: nftContract,\n            derivData: {\n                parentIpIds: [parentIpId],\n                licenseTermsIds: [noCommercialLicenseTermsId],\n                maxMintingFee: \&quot;0\&quot;,\n                maxRts: 5 * 10 ** 6,\n                maxRevenueShare: \&quot;0\&quot;,\n            },\n        },\n        {\n            spgNftContract: nftContract,\n            derivData: {\n                parentIpIds: [parentIpId],\n                licenseTermsIds: [noCommercialLicenseTermsId],\n                maxMintingFee: \&quot;0\&quot;,\n                maxRts: 5 * 10 ** 6,\n                maxRevenueShare: \&quot;0\&quot;,\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.results).to.be.an(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fe9aa379-72ba-4764-8b05-2337bcfe688e&quot;,&quot;parentUUID&quot;:&quot;a61e01e2-3d82-4e84-94be-855aa6638a1f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should batch register giving parameters&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Operations should batch register giving parameters&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:26346,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst spgTokenId1 = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst spgTokenId2 = await (0, util_1.mintBySpg)(nftContract, \&quot;test-metadata\&quot;);\nconst result = await client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId,\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2,\n        },\n        {\n            nftContract,\n            tokenId: spgTokenId1,\n            ipMetadata: {\n                ipMetadataURI: \&quot;test-uri2\&quot;,\n                ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash2\&quot;, { size: 32 }),\n                nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash2\&quot;, { size: 32 }),\n            },\n        },\n        {\n            nftContract,\n            tokenId: spgTokenId2,\n            ipMetadata: {\n                ipMetadataURI: \&quot;test-uri\&quot;,\n                ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n                nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n            },\n        },\n    ],\n});\n(0, chai_1.expect)(result.results).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;333a14ff-e9f9-402c-834b-51f371331199&quot;,&quot;parentUUID&quot;:&quot;a61e01e2-3d82-4e84-94be-855aa6638a1f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;d12a293e-cfb4-4810-8157-99465dca2067&quot;,&quot;32065c39-9332-43d0-8716-cdb26f911cd5&quot;,&quot;fe9aa379-72ba-4764-8b05-2337bcfe688e&quot;,&quot;333a14ff-e9f9-402c-834b-51f371331199&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:79744,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;65587b8e-c4fa-49c5-977b-1202f38e8b3b&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Error Cases\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Error Cases \&quot;before all\&quot; hook in \&quot;Error Cases\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4935,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n});\nnftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8bff2f90-77ab-4a3b-8dc7-f25af9f36ffd&quot;,&quot;parentUUID&quot;:&quot;65587b8e-c4fa-49c5-977b-1202f38e8b3b&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should fail to register unowned NFT&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Error Cases should fail to register unowned NFT&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:270,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.ipAsset.register({\n    nftContract: nftContract,\n    tokenId: 999999n, // Non-existent token\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7b32327b-8cca-4084-b428-eacf5393535b&quot;,&quot;parentUUID&quot;:&quot;65587b8e-c4fa-49c5-977b-1202f38e8b3b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;7b32327b-8cca-4084-b428-eacf5393535b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:270,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;5113bc5d-dbc0-4dcd-8b06-73959d049aa8&quot;,&quot;title&quot;:&quot;Other Edge Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Other Edge Cases\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases \&quot;before all\&quot; hook in \&quot;Other Edge Cases\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15210,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst parentIpResponse = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nparentIpId = parentIpResponse.ipId;\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId,\n    licenseTermsId: noCommercialLicenseTermsId,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a9a01721-54fc-4f5a-b243-8e1f2f39048e&quot;,&quot;parentUUID&quot;:&quot;5113bc5d-dbc0-4dcd-8b06-73959d049aa8&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;1ae6c5b6-a1bf-40b0-a40e-c601052d5934&quot;,&quot;title&quot;:&quot;License Token Edge Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should fail when trying to use non-existent license token&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases License Token Edge Cases should fail when trying to use non-existent license token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10391,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId,\n    })).ipId,\n    licenseTokenIds: [BigInt(999999)], // Non-existent token\n    maxRts: 5 * 10 ** 6,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a3fac7d4-98e6-462a-a957-b0dcbd80abe8&quot;,&quot;parentUUID&quot;:&quot;1ae6c5b6-a1bf-40b0-a40e-c601052d5934&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when trying to use same license token twice&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases License Token Edge Cases should fail when trying to use same license token twice&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:30886,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: noCommercialLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \&quot;0\&quot;,\n    maxRevenueShare: 1,\n});\nconst tokenId1 = await (0, util_1.getTokenId)();\nawait client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n    })).ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n});\nconst tokenId2 = await (0, util_1.getTokenId)();\nawait (0, chai_1.expect)(client.ipAsset.registerDerivativeWithLicenseTokens({\n    childIpId: (await client.ipAsset.register({\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n    })).ipId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n})).to.be.rejected; // Should fail as token already used&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;44bcbce1-cc4b-4164-890d-9f431a191a7c&quot;,&quot;parentUUID&quot;:&quot;1ae6c5b6-a1bf-40b0-a40e-c601052d5934&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a3fac7d4-98e6-462a-a957-b0dcbd80abe8&quot;,&quot;44bcbce1-cc4b-4164-890d-9f431a191a7c&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:41277,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;a0b2ec16-783d-4646-9a0e-3cd2f8713a2b&quot;,&quot;title&quot;:&quot;Batch Operation Edge Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should handle partial failures in batch registration&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Other Edge Cases Batch Operation Edge Cases should handle partial failures in batch registration&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:19312,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nawait client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId1,\n});\nawait (0, chai_1.expect)(client.ipAsset.batchRegister({\n    args: [\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId1, // Already registered\n        },\n        {\n            nftContract: util_1.mockERC721,\n            tokenId: tokenId2, // New registration\n        },\n    ],\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;76268ce0-5078-48dd-98d0-e5967970ebbc&quot;,&quot;parentUUID&quot;:&quot;a0b2ec16-783d-4646-9a0e-3cd2f8713a2b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;76268ce0-5078-48dd-98d0-e5967970ebbc&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:19312,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;a870bd58-88f8-42a0-b50a-e3883929d2ed&quot;,&quot;title&quot;:&quot;Batch Register IP Assets With Optimized Workflows&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Batch Register IP Assets With Optimized Workflows\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows \&quot;before all\&quot; hook in \&quot;Batch Register IP Assets With Optimized Workflows\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:41072,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create a public minting NFT collection\nconst publicMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;Public Minting Collection\&quot;,\n    symbol: \&quot;PMC\&quot;,\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n    contractURI: \&quot;\&quot;,\n});\nspgNftContractWithPublicMinting = publicMintingCollectionResult.spgNftContract;\n// Create a private minting NFT collection\nconst privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;Private Minting Collection\&quot;,\n    symbol: \&quot;PRC\&quot;,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;\&quot;,\n});\nspgNftContractWithPrivateMinting = privateMintingCollectionResult.spgNftContract;\n// Register a commercial remix PIL license\nconst commercialRemixPILResult = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 10n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n}));\nlicenseTermsId1 = commercialRemixPILResult.licenseTermsId;\n// Register a commercial use PIL license\nconst commercialUsePILResult = await client.license.registerPILTerms({\n    transferable: true,\n    royaltyPolicy: \&quot;0xBe54FB168b3c982b7AaE60dB6CF75Bd8447b390E\&quot;,\n    defaultMintingFee: 5n,\n    expiration: 0n,\n    commercialUse: true,\n    commercialAttribution: true,\n    commercializerChecker: viem_1.zeroAddress,\n    commercializerCheckerData: viem_1.zeroAddress,\n    commercialRevShare: 10,\n    commercialRevCeiling: 0n,\n    derivativesAllowed: true,\n    derivativesAttribution: true,\n    derivativesApproval: false,\n    derivativesReciprocal: true,\n    derivativeRevCeiling: 0n,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    uri: \&quot;https://github.com/piplabs/pil-document/blob/ad67bb632a310d2557f8abcccd428e4c9c798db1/off-chain-terms/CommercialRemix.json\&quot;,\n});\nlicenseTermsId2 = commercialUsePILResult.licenseTermsId;\n// Mint and register IP with public minting contract\nconst publicMintingIpResult = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPublicMinting,\n});\nparentIpId1 = publicMintingIpResult.ipId;\n// Attach license terms to the first IP\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId1,\n    licenseTermsId: licenseTermsId1,\n});\n// Mint and register IP with private minting contract\nconst privateMintingIpResult = await client.ipAsset.mintAndRegisterIp({\n    spgNftContract: spgNftContractWithPrivateMinting,\n});\nparentIpId2 = privateMintingIpResult.ipId;\n// Attach license terms to the second IP\nawait client.license.attachLicenseTerms({\n    ipId: parentIpId2,\n    licenseTermsId: licenseTermsId2,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;59e97f66-6e35-47ba-a1e2-5d3c4ce14e8b&quot;,&quot;parentUUID&quot;:&quot;a870bd58-88f8-42a0-b50a-e3883929d2ed&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully batch register multiple IP assets with SPG NFT contracts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully batch register multiple IP assets with SPG NFT contracts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:47708,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15(10+5) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall due to the private minting\n     * - `maxLicenseTokens` is set to 1000n for first license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 1000n,\n            },\n            {\n                terms: src_1.PILFlavor.commercialUse({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 3n,\n                    override: {\n                        commercialRevShare: 90,\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesReciprocal: true,\n                        commercialAttribution: false,\n                    },\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 3n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     * - `maxLicenseTokens` is set to 100n for license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 0n,\n                    commercialRevShare: 90,\n                    override: {\n                        derivativesAllowed: true,\n                        derivativesAttribution: true,\n                        derivativesReciprocal: true,\n                        commercialAttribution: false,\n                    },\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 100n,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 20(10+10) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5(0+5) WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the mint tokens is given `msg.sender` as the recipient\n     * - `maxLicenseTokens` is set to 80n and 10n for license terms\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                maxLicenseTokens: 80n,\n            },\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 100n,\n                    commercialRevShare: 0,\n                    override: {\n                        derivativesReciprocal: true,\n                        commercialAttribution: false,\n                        expiration: 1000n,\n                    },\n                }),\n                maxLicenseTokens: 10n,\n            },\n        ],\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the mint tokens is given `msg.sender` as the recipient\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.creativeCommonsAttribution({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    override: {\n                        defaultMintingFee: 10000n,\n                    },\n                }),\n            },\n        ],\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10,\n            },\n        ],\n    },\n];\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\nconst totalFees = 10 + 15 + 0 + 10 + 20 + 5 + 10 + 0;\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n/**\n * Transaction breakdown:\n *\n * 1. derivativeWorkflowsClient: 1 transaction\n *    - No license terms attached\n *\n * 2. multicall3Client: 3 transactions\n *    - Second transaction includes license terms with maxLicenseTokens: 1000n\n *\n * 3. licenseAttachmentWorkflowsClient: 1 transaction\n *    - Two license terms attached\n *    - First license terms: maxLicenseTokens: 1000n\n *\n * 4. royaltyTokenDistributionWorkflowsClient: 3 transactions\n *    - Second transaction includes two license terms:\n *    -  First license terms: maxLicenseTokens: 80n\n *    - Second license terms: maxLicenseTokens: 10n\n *   - Third transaction includes a license terms\n *\n * Summary:\n * - Total transactions: 4 (4 unique transaction hashes)\n * - Total IP assets registered: 8\n */\n(0, chai_1.expect)(result.registrationResults.length).equal(4);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes?.length).equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;25b9b2b1-1d1e-4c8a-abad-f0f9a4e68d62&quot;,&quot;parentUUID&quot;:&quot;a870bd58-88f8-42a0-b50a-e3883929d2ed&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully batch register multiple IP assets with NFT contracts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully batch register multiple IP assets with NFT contracts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:81541,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst tokenId4 = await (0, util_1.getTokenId)();\nconst tokenId5 = await (0, util_1.getTokenId)();\nconst tokenId6 = await (0, util_1.getTokenId)();\nconst tokenId7 = await (0, util_1.getTokenId)();\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst requests = [\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerIpAndAttachPilTerms  workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall\n     * - `maxLicenseTokens` is set to 100n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId3,\n        deadline: 1000n,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 0n,\n                    commercialRevShare: 100,\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 10000n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 100n,\n            },\n        ],\n    },\n    /**\n     * registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     * - `maxLicenseTokens` is set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId4,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 1n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n            {\n                terms: src_1.PILFlavor.creativeCommonsAttribution({\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 6n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n        ],\n        ipMetadata: {\n            ipMetadataURI: \&quot;test-uri\&quot;,\n            ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n            nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 43,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 17,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 2,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 38,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId5,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId6,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId7,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10,\n            },\n        ],\n    },\n];\nconst totalFees = 10 + 5 + 0 + 0 + 5 + 10 + 5;\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n/**\n * Transaction breakdown:\n * 1. royaltyTokenDistributionWorkflowsClient: 4 args\n *  - The third request has two license terms, first one has `maxLicenseTokens` set to 10n\n *\n * 2.licenseAttachmentWorkflowsClient: 1 arg\n *  - The first request have two license terms, second one has `maxLicenseTokens` set to 100n\n *\n * 3.derivativeWorkflowsClient: 2 args\n *  - None license terms and no `maxLicenseTokens` set\n *\n * Summary:\n * - Total transactions: 3 (3 unique transaction hashes)\n * - Total IP assets registered: 7\n */\n(0, chai_1.expect)(result.registrationResults.length).equal(3);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).greaterThan(0);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(4);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].licenseTermsIds?.length).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes).equal(undefined);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2afdf550-c126-4ce8-83af-20695fc30ac0&quot;,&quot;parentUUID&quot;:&quot;a870bd58-88f8-42a0-b50a-e3883929d2ed&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register IP assets using a combination of NFT contracts and SPG NFT contracts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully register IP assets using a combination of NFT contracts and SPG NFT contracts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:80132,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst tokenId3 = await (0, util_1.getTokenId)();\nconst tokenId4 = await (0, util_1.getTokenId)();\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15(10+5) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5(0+5) WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens workflow\n     * - Total fees: 20(10+10) WIP tokens\n     * - Uses `multicall3Client` multicall3 due to the public minting\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall due to the private minting\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 10,\n            },\n        ],\n    },\n    /**\n     * registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient` multicall\n     * - Need to distribute royalty tokens\n     * - `maxLicenseTokens` is set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: generated_1.erc20Address[util_1.aeneid],\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 1n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n        ipMetadata: {\n            ipMetadataURI: \&quot;test-uri\&quot;,\n            ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n            nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 43,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 17,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 2,\n            },\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 38,\n            },\n        ],\n    },\n    /**\n     * registerIpAndAttachPilTerms  workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` multicall\n     * - the second request has `maxLicenseTokens` set to 10n\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId3,\n        deadline: 1000n,\n        licenseTermsData: [\n            {\n                terms: src_1.PILFlavor.commercialRemix({\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    royaltyPolicy: src_1.NativeRoyaltyPolicy.LAP,\n                    defaultMintingFee: 0n,\n                    commercialRevShare: 100,\n                }),\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 10000n,\n                    expiration: 1000n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;test case\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 10000n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: viem_1.zeroAddress,\n                },\n                maxLicenseTokens: 10n,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIp workflow\n     * - Total fees: 10 WIP tokens\n     * - Uses `derivativeWorkflowsClient` multicall\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId4,\n        derivData: {\n            parentIpIds: [parentIpId1],\n            licenseTermsIds: [licenseTermsId1],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n];\nconst totalFees = 15 + 5 + 20 + 10 + 5 + 0 + 0 + 10;\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n});\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n/**\n * Transaction breakdown:\n * 1. multicall3Client: 2 args\n *  - No license terms and no `maxLicenseTokens` set\n *\n * 2. royaltyTokenDistributionWorkflowsClient: 3 args\n *  - The third request has a license terms and `maxLicenseTokens` set to 10n\n *\n * 3. derivativeWorkflowsClient: 2 args\n *  - None license terms and no `maxLicenseTokens` set\n *\n * 4. licenseAttachmentWorkflowsClient: 1 arg\n *  - The first request have two license terms, second one has `maxLicenseTokens` set to 10n\n *\n * Summary:\n * - Total transactions: 4 (4 unique transaction hashes)\n * - Total IP assets registered: 8\n */\n(0, chai_1.expect)(result.registrationResults.length).equal(4);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).greaterThan(0);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[1].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(3);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[2].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[2].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[1].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;15f3cc6e-c1f8-45a8-81d1-3ad223dd2935&quot;,&quot;parentUUID&quot;:&quot;a870bd58-88f8-42a0-b50a-e3883929d2ed&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully register IP assets with multicall disabled&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Register IP Assets With Optimized Workflows should successfully register IP assets with multicall disabled&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:52454,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId1 = await (0, util_1.getTokenId)();\nconst tokenId2 = await (0, util_1.getTokenId)();\nconst requests = [\n    /**\n     * mintAndRegisterIpAndMakeDerivative workflow\n     * - Total fees: 15(10+5) WIP tokens\n     * - Uses `derivativeWorkflowsClient` to call the this method\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 0 WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` to call the this method\n     */\n    {\n        spgNftContract: spgNftContractWithPrivateMinting,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * mintAndRegisterIpAssetWithPilTerms workflow\n     * - Total fees: 10(10+0) WIP tokens\n     * - Uses `licenseAttachmentWorkflowsClient` to call the this method\n     * - the first request has `maxLicenseTokens` set to 10n\n     */\n    {\n        spgNftContract: spgNftContractWithPublicMinting,\n        allowDuplicates: true,\n        licenseTermsData: [\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n                maxLicenseTokens: 10n,\n            },\n            {\n                terms: {\n                    transferable: true,\n                    royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                    defaultMintingFee: 0n,\n                    expiration: 0n,\n                    commercialUse: true,\n                    commercialAttribution: false,\n                    commercializerChecker: viem_1.zeroAddress,\n                    commercializerCheckerData: viem_1.zeroAddress,\n                    commercialRevShare: 90,\n                    commercialRevCeiling: 0n,\n                    derivativesAllowed: true,\n                    derivativesAttribution: true,\n                    derivativesApproval: false,\n                    derivativesReciprocal: true,\n                    derivativeRevCeiling: 0n,\n                    currency: common_1.WIP_TOKEN_ADDRESS,\n                    uri: \&quot;\&quot;,\n                },\n                licensingConfig: {\n                    isSet: true,\n                    mintingFee: 0n,\n                    licensingHook: viem_1.zeroAddress,\n                    hookData: viem_1.zeroAddress,\n                    commercialRevShare: 0,\n                    disabled: false,\n                    expectMinimumGroupRewardShare: 0,\n                    expectGroupRewardPool: pool,\n                },\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient`to call the this method\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId1,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n    /**\n     * registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens workflow\n     * - Total fees: 5 WIP tokens\n     * - Uses `royaltyTokenDistributionWorkflowsClient`to call the this method\n     * - Need to distribute royalty tokens\n     */\n    {\n        nftContract: util_1.mockERC721,\n        tokenId: tokenId2,\n        derivData: {\n            parentIpIds: [parentIpId2],\n            licenseTermsIds: [licenseTermsId2],\n            maxMintingFee: 0,\n            maxRts: common_1.MAX_ROYALTY_TOKEN,\n            maxRevenueShare: 100,\n        },\n        royaltyShares: [\n            {\n                recipient: util_1.TEST_WALLET_ADDRESS,\n                percentage: 100,\n            },\n        ],\n    },\n];\nconst userBalanceBefore = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst totalFees = 15 + 0 + 10 + 5 + 5;\nconst result = await client.ipAsset.batchRegisterIpAssetsWithOptimizedWorkflows({\n    requests: requests,\n    options: {\n        wipOptions: {\n            useMulticallWhenPossible: false,\n        },\n    },\n});\nconst userBalanceAfter = await client.getBalance(util_1.TEST_WALLET_ADDRESS);\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(Number(userBalanceAfter)).lessThan(Number(userBalanceBefore - BigInt(totalFees)));\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n/**\n * Transaction breakdown:\n * 1. None license terms and no `maxLicenseTokens` set\n * 2. The request have one license terms and no `maxLicenseTokens` set\n * 3. The request have two license terms, first one has `maxLicenseTokens` set to 10n\n * 4. The requests have no license terms and no `maxLicenseTokens` set\n * 5. The requests have no license terms and no `maxLicenseTokens` set\n * Summary:\n * - Total transactions: 5 (5 unique transaction hashes)\n * - Total IP assets registered: 5\n */\n(0, chai_1.expect)(result.registrationResults.length).equal(requests.length);\n(0, chai_1.expect)(result.registrationResults.reduce((a, b) =&gt; a + b.ipAssetsWithLicenseTerms.length, 0)).equal(requests.length);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHashes?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[0].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[1].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].licenseTermsIds?.length).equal(2);\n(0, chai_1.expect)(result.registrationResults[2].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes?.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[3].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[4].ipAssetsWithLicenseTerms.length).equal(1);\n(0, chai_1.expect)(result.registrationResults[4].ipAssetsWithLicenseTerms[0].licenseTermsIds).equal(undefined);\n(0, chai_1.expect)(result.registrationResults[4].ipAssetsWithLicenseTerms[0].maxLicenseTokensTxHashes).equal(undefined);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;eeee7eef-a19f-41a2-b63f-8ad55d0986f7&quot;,&quot;parentUUID&quot;:&quot;a870bd58-88f8-42a0-b50a-e3883929d2ed&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;25b9b2b1-1d1e-4c8a-abad-f0f9a4e68d62&quot;,&quot;2afdf550-c126-4ce8-83af-20695fc30ac0&quot;,&quot;15f3cc6e-c1f8-45a8-81d1-3ad223dd2935&quot;,&quot;eeee7eef-a19f-41a2-b63f-8ad55d0986f7&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:261835,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;bcfd44fa-69cc-4d9f-a8fb-86164508fc27&quot;,&quot;title&quot;:&quot;Batch Mint and Register IP Asset&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Batch Mint and Register IP Asset\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset \&quot;before all\&quot; hook in \&quot;Batch Mint and Register IP Asset\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18228,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const publicMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContractWithPublicMinting = publicMintingCollectionResult.spgNftContract;\nconst privateMintingCollectionResult = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintFee: 20n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContractWithPrivateMinting = privateMintingCollectionResult.spgNftContract;\nconst { address } = await (0, BIP32_1.getDerivedStoryClient)();\nanotherWalletAddress = address;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;189f4d13-fd3e-4812-8202-53624bc635c2&quot;,&quot;parentUUID&quot;:&quot;bcfd44fa-69cc-4d9f-a8fb-86164508fc27&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when public minting of spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should successfully when public minting of spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6443,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst { registrationResults } = await client.ipAsset.batchMintAndRegisterIp({\n    requests: [\n        { spgNftContract: spgNftContractWithPublicMinting },\n        { spgNftContract: spgNftContractWithPublicMinting, recipient: anotherWalletAddress },\n        { spgNftContract: spgNftContractWithPublicMinting, allowDuplicates: false },\n    ],\n});\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(registrationResults.length).equal(1);\n(0, chai_1.expect)(registrationResults[0].ipIdsAndTokenIds.length).equal(3);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a0fc0e4a-1205-4bab-ac8c-70763389bd5a&quot;,&quot;parentUUID&quot;:&quot;bcfd44fa-69cc-4d9f-a8fb-86164508fc27&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when private minting of spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should successfully when private minting of spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:16426,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst { registrationResults } = await client.ipAsset.batchMintAndRegisterIp({\n    requests: [\n        { spgNftContract: spgNftContractWithPrivateMinting },\n        { spgNftContract: spgNftContractWithPrivateMinting, recipient: anotherWalletAddress },\n        {\n            spgNftContract: spgNftContractWithPrivateMinting,\n            allowDuplicates: false,\n            recipient: anotherWalletAddress,\n        },\n    ],\n});\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(registrationResults.length).equal(1);\n(0, chai_1.expect)(registrationResults[0].ipIdsAndTokenIds.length).equal(3);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7c9fa2a1-7e4f-448e-a4b1-c587ccc38c4f&quot;,&quot;parentUUID&quot;:&quot;bcfd44fa-69cc-4d9f-a8fb-86164508fc27&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when hybrid private minting and public minting of spgNftContract&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should successfully when hybrid private minting and public minting of spgNftContract&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:21096,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const wipBalanceBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst { registrationResults } = await client.ipAsset.batchMintAndRegisterIp({\n    requests: [\n        { spgNftContract: spgNftContractWithPublicMinting },\n        { spgNftContract: spgNftContractWithPrivateMinting, recipient: anotherWalletAddress },\n        { spgNftContract: spgNftContractWithPrivateMinting, allowDuplicates: false },\n        { spgNftContract: spgNftContractWithPublicMinting, recipient: anotherWalletAddress },\n    ],\n});\nconst wipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipBalanceAfter).equal(wipBalanceBefore);\n(0, chai_1.expect)(registrationResults.length).equal(2);\n(0, chai_1.expect)(registrationResults[0].ipIdsAndTokenIds.length).equal(2);\n(0, chai_1.expect)(registrationResults[1].ipIdsAndTokenIds.length).equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8129b41d-a621-4e1d-ae5c-1f4d39d9ae1c&quot;,&quot;parentUUID&quot;:&quot;bcfd44fa-69cc-4d9f-a8fb-86164508fc27&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail when private minting of spgNftContract but caller does not have the minter role&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Batch Mint and Register IP Asset should fail when private minting of spgNftContract but caller does not have the minter role&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5282,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Register a new SPG NFT contract with private minting with clientB\nconst { address, clientB } = await (0, BIP32_1.getDerivedStoryClient)();\nconst { spgNftContract: privateMintingContractOfClientB } = await clientB.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: address,\n    contractURI: \&quot;test-uri\&quot;,\n});\nawait (0, chai_1.expect)(client.ipAsset.batchMintAndRegisterIp({\n    requests: [{ spgNftContract: privateMintingContractOfClientB }],\n})).to.be.rejectedWith(\&quot;does not have the minter role\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1629175f-7a92-4e3e-8d0f-4d4929fdd2e0&quot;,&quot;parentUUID&quot;:&quot;bcfd44fa-69cc-4d9f-a8fb-86164508fc27&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a0fc0e4a-1205-4bab-ac8c-70763389bd5a&quot;,&quot;7c9fa2a1-7e4f-448e-a4b1-c587ccc38c4f&quot;,&quot;8129b41d-a621-4e1d-ae5c-1f4d39d9ae1c&quot;,&quot;1629175f-7a92-4e3e-8d0f-4d4929fdd2e0&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:49247,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;0a7e76a3-095d-49be-b000-b2820a9a0efe&quot;,&quot;title&quot;:&quot;Register ip asset with minted and mint nft&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;ccc8aabc-4964-46e4-982b-ba1094f5475a&quot;,&quot;title&quot;:&quot;Register IP Asset with Minted NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give license terms data and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when give license terms data and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17034,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            licensingConfig: {\n                isSet: true,\n                mintingFee: 0n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n            maxLicenseTokens: 100,\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 100,\n        },\n    ],\n    deadline: 1000n,\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds.length).to.be.equal(1);\n(0, chai_1.expect)(result.registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1b6de318-87a0-42a9-b88b-935303109065&quot;,&quot;parentUUID&quot;:&quot;ccc8aabc-4964-46e4-982b-ba1094f5475a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give license terms data without royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when give license terms data without royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11415,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5b09b655-189a-42cf-a253-9b013b7fe791&quot;,&quot;parentUUID&quot;:&quot;ccc8aabc-4964-46e4-982b-ba1094f5475a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when without license terms data, royalty shares, ip metadata&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when without license terms data, royalty shares, ip metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10039,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;eb6251e6-3b1d-499c-9fd7-452fcdcbe055&quot;,&quot;parentUUID&quot;:&quot;ccc8aabc-4964-46e4-982b-ba1094f5475a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when without license terms data and royalty shares, with ip metadata&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset with Minted NFT should successfully when without license terms data and royalty shares, with ip metadata&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10155,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataURI: \&quot;test-nft-uri\&quot;,\n    },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4a7a019b-be78-48e4-bb47-081714255b49&quot;,&quot;parentUUID&quot;:&quot;ccc8aabc-4964-46e4-982b-ba1094f5475a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1b6de318-87a0-42a9-b88b-935303109065&quot;,&quot;5b09b655-189a-42cf-a253-9b013b7fe791&quot;,&quot;eb6251e6-3b1d-499c-9fd7-452fcdcbe055&quot;,&quot;4a7a019b-be78-48e4-bb47-081714255b49&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:48643,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;ee0b1768-44c7-4a9e-b22c-51b4605b7584&quot;,&quot;title&quot;:&quot;Register IP Asset by minting a new NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Register IP Asset by minting a new NFT\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT \&quot;before all\&quot; hook in \&quot;Register IP Asset by minting a new NFT\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5012,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST_FOR_MINT\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e650d092-b36e-4f7b-8770-f6330887fad1&quot;,&quot;parentUUID&quot;:&quot;ee0b1768-44c7-4a9e-b22c-51b4605b7584&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give license terms data and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT should successfully when give license terms data and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:17150,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgNftContract },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 10,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(1);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ede09639-27bf-4b02-89c9-c55ee0f55cd0&quot;,&quot;parentUUID&quot;:&quot;ee0b1768-44c7-4a9e-b22c-51b4605b7584&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give license terms data without royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT should successfully when give license terms data without royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:12497,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgNftContract },\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.creativeCommonsAttribution({\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n            }),\n            maxLicenseTokens: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);\n(0, chai_1.expect)(result.licenseTermsIds?.length).to.be.equal(2);\n(0, chai_1.expect)(result.maxLicenseTokensTxHashes?.length).to.be.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5e290058-5afd-4bbf-8a1f-e53cc20fea5b&quot;,&quot;parentUUID&quot;:&quot;ee0b1768-44c7-4a9e-b22c-51b4605b7584&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when without license terms data and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register ip asset with minted and mint nft Register IP Asset by minting a new NFT should successfully when without license terms data and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18698,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract: spgNftContract },\n    ipMetadata: {\n        ipMetadataURI: \&quot;test-uri\&quot;,\n        ipMetadataHash: (0, viem_1.toHex)(\&quot;test-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataHash: (0, viem_1.toHex)(\&quot;test-nft-metadata-hash\&quot;, { size: 32 }),\n        nftMetadataURI: \&quot;test-nft-uri\&quot;,\n    },\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0bb3ab33-5c65-43de-a449-734c3284465e&quot;,&quot;parentUUID&quot;:&quot;ee0b1768-44c7-4a9e-b22c-51b4605b7584&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;ede09639-27bf-4b02-89c9-c55ee0f55cd0&quot;,&quot;5e290058-5afd-4bbf-8a1f-e53cc20fea5b&quot;,&quot;0bb3ab33-5c65-43de-a449-734c3284465e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:48345,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;42197c6c-bd2b-4233-824a-977c578d7f55&quot;,&quot;title&quot;:&quot;Register derivative IP Asset&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Register derivative IP Asset\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset \&quot;before all\&quot; hook in \&quot;Register derivative IP Asset\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10917,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\nparentIpId = result.ipId;\ncommercialRemixLicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1e38335c-472b-4fd8-adbe-1d24fbf24985&quot;,&quot;parentUUID&quot;:&quot;42197c6c-bd2b-4233-824a-977c578d7f55&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;217928dd-fd76-4050-b651-ece8a775a68b&quot;,&quot;title&quot;:&quot;Register derivative IP Asset with Minted NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give derivData and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset with Minted NFT should successfully when give derivData and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:25474,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.distributeRoyaltyTokensTxHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipRoyaltyVault).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.equal(BigInt(tokenId));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;28193aae-a97e-4180-aafd-41fcc8991553&quot;,&quot;parentUUID&quot;:&quot;217928dd-fd76-4050-b651-ece8a775a68b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully given derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset with Minted NFT should successfully given derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15904,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.equal(BigInt(tokenId));\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d02bbc28-da73-4202-9d87-a9de65378ff8&quot;,&quot;parentUUID&quot;:&quot;217928dd-fd76-4050-b651-ece8a775a68b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully given licenseTokenIds and maxRts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset with Minted NFT should successfully given licenseTokenIds and maxRts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:21024,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: commercialRemixLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenIds[0]);\nconst tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;minted\&quot;, nftContract: util_1.mockERC721, tokenId: tokenId },\n    licenseTokenIds: licenseTokenIds,\n    maxRts: 100,\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.equal(BigInt(tokenId));\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;eb9d702b-801f-4f65-968a-82755e8523e1&quot;,&quot;parentUUID&quot;:&quot;217928dd-fd76-4050-b651-ece8a775a68b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;28193aae-a97e-4180-aafd-41fcc8991553&quot;,&quot;d02bbc28-da73-4202-9d87-a9de65378ff8&quot;,&quot;eb9d702b-801f-4f65-968a-82755e8523e1&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:62402,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;7e780258-cd73-48cd-b9d0-167afed128e8&quot;,&quot;title&quot;:&quot;Register derivative IP Asset by minting a new NFT&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Register derivative IP Asset by minting a new NFT\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT \&quot;before all\&quot; hook in \&quot;Register derivative IP Asset by minting a new NFT\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9001,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST_FOR_MINT\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false,\n    mintOpen: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 10n,\n    mintFeeToken: common_1.WIP_TOKEN_ADDRESS,\n});\nspgNftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;04555d54-e53e-4394-a426-86d3f6ffdf04&quot;,&quot;parentUUID&quot;:&quot;7e780258-cd73-48cd-b9d0-167afed128e8&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give derivData and royalty shares&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT should successfully when give derivData and royalty shares&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:20487,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 100,\n        },\n    ],\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2104be9b-3ce2-49a2-aa49-1d1f0e39b746&quot;,&quot;parentUUID&quot;:&quot;7e780258-cd73-48cd-b9d0-167afed128e8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give licenseTokenIds and maxRts&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT should successfully when give licenseTokenIds and maxRts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:21121,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const { licenseTokenIds } = await client.license.mintLicenseTokens({\n    licenseTermsId: commercialRemixLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 100,\n});\nawait (0, util_1.approveForLicenseToken)(generated_1.derivativeWorkflowsAddress[util_1.aeneid], licenseTokenIds[0]);\nconst result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract },\n    licenseTokenIds: licenseTokenIds,\n    maxRts: 100,\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;023ea37b-7ed8-4de2-a220-d5a0f96ccaec&quot;,&quot;parentUUID&quot;:&quot;7e780258-cd73-48cd-b9d0-167afed128e8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give derivData&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Register derivative IP Asset Register derivative IP Asset by minting a new NFT should successfully when give derivData&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11305,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.ipAsset.registerDerivativeIpAsset({\n    nft: { type: \&quot;mint\&quot;, spgNftContract },\n    derivData: {\n        parentIpIds: [parentIpId],\n        licenseTermsIds: [commercialRemixLicenseTermsId],\n        maxMintingFee: 10000n,\n        maxRts: 100,\n        maxRevenueShare: 100,\n    },\n});\n(0, chai_1.expect)(result.ipId).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3806f767-aec9-4eb9-82a9-9af95c69d185&quot;,&quot;parentUUID&quot;:&quot;7e780258-cd73-48cd-b9d0-167afed128e8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;2104be9b-3ce2-49a2-aa49-1d1f0e39b746&quot;,&quot;023ea37b-7ed8-4de2-a220-d5a0f96ccaec&quot;,&quot;3806f767-aec9-4eb9-82a9-9af95c69d185&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:52913,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;b1dbd90d-4d54-4f6d-a0e2-5d0ffcec110b&quot;,&quot;title&quot;:&quot;Link Derivative&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/ipAsset.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/ipAsset.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Link Derivative\&quot;&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative \&quot;before all\&quot; hook in \&quot;Link Derivative\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10760,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst result = await client.ipAsset.registerIpAndAttachPilTerms({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n    licenseTermsData: [\n        {\n            terms: src_1.PILFlavor.commercialRemix({\n                defaultMintingFee: 10000n,\n                commercialRevShare: 100,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n            }),\n        },\n    ],\n});\nparentIpId = result.ipId;\ncommercialRemixLicenseTermsId = result.licenseTermsIds[0];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8f1e2409-5606-4a83-aa18-2271c0eb0ae6&quot;,&quot;parentUUID&quot;:&quot;b1dbd90d-4d54-4f6d-a0e2-5d0ffcec110b&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully when give childIpId and licenseTokenIds&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative should successfully when give childIpId and licenseTokenIds&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:25183,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// register a child ip\nconst tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst mintLicenseTokensResult = await client.license.mintLicenseTokens({\n    licenseTermsId: commercialRemixLicenseTermsId,\n    licensorIpId: parentIpId,\n    maxMintingFee: \&quot;0\&quot;,\n    maxRevenueShare: 100,\n});\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    licenseTokenIds: [mintLicenseTokensResult.licenseTokenIds[0]],\n    maxRts: 5 * 10 ** 6,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;70810161-1c5f-47bb-a89e-8d2a5ccae013&quot;,&quot;parentUUID&quot;:&quot;b1dbd90d-4d54-4f6d-a0e2-5d0ffcec110b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully when give parentIpId and licenseTokenIds&quot;,&quot;fullTitle&quot;:&quot;IP Asset Functions Link Derivative should successfully when give parentIpId and licenseTokenIds&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:24800,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const tokenId = await (0, util_1.getTokenId)();\nconst childIpId = (await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n})).ipId;\nconst result = await client.ipAsset.linkDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [commercialRemixLicenseTermsId],\n    maxMintingFee: \&quot;0\&quot;,\n    maxRts: 5 * 10 ** 6,\n    maxRevenueShare: \&quot;0\&quot;,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ee874050-9956-4c35-a7f5-8ac0ef228bdd&quot;,&quot;parentUUID&quot;:&quot;b1dbd90d-4d54-4f6d-a0e2-5d0ffcec110b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;70810161-1c5f-47bb-a89e-8d2a5ccae013&quot;,&quot;ee874050-9956-4c35-a7f5-8ac0ef228bdd&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:49983,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;d2b02e50-5b94-4890-a13d-90e3b979ddba&quot;,&quot;title&quot;:&quot;License Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;License Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions \&quot;before all\&quot; hook in \&quot;License Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:95,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nclientB = derivedClient.clientB;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;74edb977-eb90-4dd7-8aad-28cdc5aba987&quot;,&quot;parentUUID&quot;:&quot;d2b02e50-5b94-4890-a13d-90e3b979ddba&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;e1114335-954b-44d0-827c-8aaa4c955b56&quot;,&quot;title&quot;:&quot;register license with different types&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should register license &quot;,&quot;fullTitle&quot;:&quot;License Functions register license with different types should register license &quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:96,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.registerPILTerms({\n    defaultMintingFee: 0,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n    transferable: false,\n    royaltyPolicy: viem_1.zeroAddress,\n    commercialUse: false,\n    commercialAttribution: false,\n    commercializerChecker: viem_1.zeroAddress,\n    commercializerCheckerData: \&quot;0x\&quot;,\n    commercialRevShare: 0,\n    derivativesAllowed: false,\n    derivativesAttribution: false,\n    derivativesApproval: false,\n    derivativesReciprocal: false,\n    uri: \&quot;\&quot;,\n    expiration: \&quot;\&quot;,\n    commercialRevCeiling: \&quot;\&quot;,\n    derivativeRevCeiling: \&quot;\&quot;,\n});\n(0, chai_1.expect)(result.licenseTermsId).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f95803f4-b82b-47c1-b33f-283438d67fb3&quot;,&quot;parentUUID&quot;:&quot;e1114335-954b-44d0-827c-8aaa4c955b56&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;f95803f4-b82b-47c1-b33f-283438d67fb3&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:96,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;1ec09571-917b-4382-8c99-4cc15f8ddb0a&quot;,&quot;title&quot;:&quot;attach License Terms and mint license tokens&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;attach License Terms and mint license tokens\&quot;&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens \&quot;before all\&quot; hook in \&quot;attach License Terms and mint license tokens\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10798,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;tokenId = await (0, util_1.getTokenId)();\nconst registerResult = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nconst mockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\nawait mockERC20.approve(generated_1.licensingModuleAddress[util_1.aeneid], viem_1.maxUint256);\nipId = registerResult.ipId;\nconst registerLicenseResult = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 0n,\n    commercialRevShare: 100,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n}));\nlicenseId = registerLicenseResult.licenseTermsId;\nconst paidLicenseResult = await client.license.registerPILTerms(src_1.PILFlavor.commercialRemix({\n    defaultMintingFee: 100n,\n    commercialRevShare: 10,\n    currency: common_1.WIP_TOKEN_ADDRESS,\n}));\npaidLicenseId = paidLicenseResult.licenseTermsId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f1ef1a2b-1c85-4029-86fb-39abd2dcbb54&quot;,&quot;parentUUID&quot;:&quot;1ec09571-917b-4382-8c99-4cc15f8ddb0a&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should attach License Terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should attach License Terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9289,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8769c95a-75f7-4cd1-a84d-67c31e250f79&quot;,&quot;parentUUID&quot;:&quot;1ec09571-917b-4382-8c99-4cc15f8ddb0a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should be able to attach another license terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should be able to attach another license terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5271,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.attachLicenseTerms({\n    ipId: ipId,\n    licenseTermsId: paidLicenseId,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ce7bbb44-781a-4eef-803a-06a42f75cffb&quot;,&quot;parentUUID&quot;:&quot;1ec09571-917b-4382-8c99-4cc15f8ddb0a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license tokens with ip owner&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license tokens with ip owner&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5388,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseId,\n    licensorIpId: ipId,\n    maxMintingFee: \&quot;1\&quot;,\n    maxRevenueShare: \&quot;100\&quot;,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;51925d3c-c9f7-4b74-904c-569c8582dadb&quot;,&quot;parentUUID&quot;:&quot;1ec09571-917b-4382-8c99-4cc15f8ddb0a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license tokens with non ip owner&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license tokens with non ip owner&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:24709,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// register ip with another wallet account\nconst tokenIdB = await (0, util_1.getTokenId)();\nconst registerResult = await clientB.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenIdB,\n});\nconst ipIdB = registerResult.ipId;\n// attach license terms to the ip\nawait client.license.attachLicenseTerms({\n    ipId: ipIdB,\n    licenseTermsId: licenseId,\n});\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: licenseId,\n    licensorIpId: ipIdB,\n    maxMintingFee: \&quot;1\&quot;,\n    maxRevenueShare: \&quot;100\&quot;,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;29a66924-ad7e-4087-a8c3-a367bda942cd&quot;,&quot;parentUUID&quot;:&quot;1ec09571-917b-4382-8c99-4cc15f8ddb0a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license token with default license terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license token with default license terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5440,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// get default license terms id\nconst licenseRegistryReadOnlyClient = new generated_1.LicenseRegistryReadOnlyClient(util_1.publicClient);\nconst { licenseTermsId: defaultLicenseTermsId } = await licenseRegistryReadOnlyClient.getDefaultLicenseTerms();\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: defaultLicenseTermsId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 1,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.licenseTokenIds).to.be.a(\&quot;array\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;44af0263-d54d-47d9-9957-19a5f43a0abb&quot;,&quot;parentUUID&quot;:&quot;1ec09571-917b-4382-8c99-4cc15f8ddb0a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should mint license tokens with fee and pay with IP&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should mint license tokens with fee and pay with IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10151,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const balanceBefore = await client.getWalletBalance();\nconst result = await client.license.mintLicenseTokens({\n    licenseTermsId: paidLicenseId,\n    licensorIpId: ipId,\n    maxMintingFee: 0n,\n    maxRevenueShare: 50,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 100n));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f8e340c4-35af-47bf-b439-7ce28b2a92ae&quot;,&quot;parentUUID&quot;:&quot;1ec09571-917b-4382-8c99-4cc15f8ddb0a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should get license terms&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should get license terms&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:91,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.getLicenseTerms(licenseId);\n(0, chai_1.expect)(result).to.be.an(\&quot;object\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;65b4c577-0866-4ad2-8466-bc94389f17ec&quot;,&quot;parentUUID&quot;:&quot;1ec09571-917b-4382-8c99-4cc15f8ddb0a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should predict minting license fee&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens should predict minting license fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:272,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.predictMintingLicenseFee({\n    licenseTermsId: licenseId,\n    licensorIpId: ipId,\n    amount: 1,\n});\n(0, chai_1.expect)(result.currencyToken).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.tokenAmount).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b513d580-b068-4298-8916-60c933353f5a&quot;,&quot;parentUUID&quot;:&quot;1ec09571-917b-4382-8c99-4cc15f8ddb0a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;cd188509-32c3-44d2-bec8-c5d22fe300a3&quot;,&quot;title&quot;:&quot;licensing config and max license tokens&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/license.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/license.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should set licensing config&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens licensing config and max license tokens should set licensing config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5107,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.setLicensingConfig({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n    licensingConfig,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(result.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1390c8cf-fa3d-4d2b-b47c-e441a9f87dfe&quot;,&quot;parentUUID&quot;:&quot;cd188509-32c3-44d2-bec8-c5d22fe300a3&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should get licensing config&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens licensing config and max license tokens should get licensing config&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:87,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.getLicensingConfig({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n});\n(0, chai_1.expect)(result).to.deep.equal({\n    ...licensingConfig,\n    expectMinimumGroupRewardShare: 1 * 10 ** 6,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f9f81e88-c579-4f0a-9fcd-a13a46afaf11&quot;,&quot;parentUUID&quot;:&quot;cd188509-32c3-44d2-bec8-c5d22fe300a3&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should set max license tokens&quot;,&quot;fullTitle&quot;:&quot;License Functions attach License Terms and mint license tokens licensing config and max license tokens should set max license tokens&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14452,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const result = await client.license.setMaxLicenseTokens({\n    ipId: ipId,\n    licenseTermsId: licenseId,\n    maxLicenseTokens: 100,\n});\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6b5c952c-193d-4c5b-951d-84a6656fa5bc&quot;,&quot;parentUUID&quot;:&quot;cd188509-32c3-44d2-bec8-c5d22fe300a3&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1390c8cf-fa3d-4d2b-b47c-e441a9f87dfe&quot;,&quot;f9f81e88-c579-4f0a-9fcd-a13a46afaf11&quot;,&quot;6b5c952c-193d-4c5b-951d-84a6656fa5bc&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:19646,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[&quot;8769c95a-75f7-4cd1-a84d-67c31e250f79&quot;,&quot;ce7bbb44-781a-4eef-803a-06a42f75cffb&quot;,&quot;51925d3c-c9f7-4b74-904c-569c8582dadb&quot;,&quot;29a66924-ad7e-4087-a8c3-a367bda942cd&quot;,&quot;44af0263-d54d-47d9-9957-19a5f43a0abb&quot;,&quot;f8e340c4-35af-47bf-b439-7ce28b2a92ae&quot;,&quot;65b4c577-0866-4ad2-8466-bc94389f17ec&quot;,&quot;b513d580-b068-4298-8916-60c933353f5a&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:60611,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;f8dc581a-dfe1-4c4d-8ead-1dbf68465edf&quot;,&quot;title&quot;:&quot;nftClient Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;nftClient Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions \&quot;before all\&quot; hook in \&quot;nftClient Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d52a5876-530d-497b-b690-92a5e3ee8b0f&quot;,&quot;parentUUID&quot;:&quot;f8dc581a-dfe1-4c4d-8ead-1dbf68465edf&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;9df8d475-17de-4b6c-bf6a-383a52552dd4&quot;,&quot;title&quot;:&quot;createNFTCollection&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully create public nft collection with minimal params&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create public nft collection with minimal params&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9042,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;test-collection\&quot;,\n    symbol: \&quot;TEST\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(txData.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4594dac8-e612-495f-a5b6-5b7b92d3b2c2&quot;,&quot;parentUUID&quot;:&quot;9df8d475-17de-4b6c-bf6a-383a52552dd4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create collection with custom mint fee&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create collection with custom mint fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4928,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;paid-collection\&quot;,\n    symbol: \&quot;PAID\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 10000000n,\n    mintFeeToken: generated_1.erc20Address[mockData_1.aeneid],\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);\nspgNftContract = txData.spgNftContract;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d73015fc-34b8-4027-a0ff-a24d938a1eca&quot;,&quot;parentUUID&quot;:&quot;9df8d475-17de-4b6c-bf6a-383a52552dd4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create private collection&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create private collection&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4934,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;private-collection\&quot;,\n    symbol: \&quot;PRIV\&quot;,\n    maxSupply: 100,\n    isPublicMinting: false, // private minting\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: false, // starts closed\n    contractURI: \&quot;test-uri\&quot;,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1087d032-e3f5-4b51-b70b-08d4bcad5eda&quot;,&quot;parentUUID&quot;:&quot;9df8d475-17de-4b6c-bf6a-383a52552dd4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create collection with baseURI&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create collection with baseURI&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4937,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;uri-collection\&quot;,\n    symbol: \&quot;URI\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    baseURI: \&quot;ipfs://QmTest/\&quot;,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7e37a26e-26e4-4de9-b58e-b0f24bc138ca&quot;,&quot;parentUUID&quot;:&quot;9df8d475-17de-4b6c-bf6a-383a52552dd4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully create collection with custom owner&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully create collection with custom owner&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4917,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;owned-collection\&quot;,\n    symbol: \&quot;OWN\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    owner: util_1.TEST_WALLET_ADDRESS,\n});\n(0, chai_1.expect)(txData.spgNftContract).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bd31a7ec-7171-4b6c-af37-dee20f4484dd&quot;,&quot;parentUUID&quot;:&quot;9df8d475-17de-4b6c-bf6a-383a52552dd4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully get encoded transaction data&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should successfully get encoded transaction data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const txData = await client.nftClient.createNFTCollection({\n    name: \&quot;encoded-collection\&quot;,\n    symbol: \&quot;ENC\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    txOptions: {\n        encodedTxDataOnly: true,\n    },\n});\n(0, chai_1.expect)(txData.encodedTxData).to.be.an(\&quot;object\&quot;);\n(0, chai_1.expect)(txData.encodedTxData?.data).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(txData.encodedTxData?.to).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;bd7c5252-7664-41fb-83ba-fa2734417632&quot;,&quot;parentUUID&quot;:&quot;9df8d475-17de-4b6c-bf6a-383a52552dd4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid mint fee token&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions createNFTCollection should fail with invalid mint fee token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.nftClient.createNFTCollection({\n    name: \&quot;invalid-fee-collection\&quot;,\n    symbol: \&quot;INV\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintFeeRecipient: util_1.TEST_WALLET_ADDRESS,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFee: 1000000000000000000n,\n    mintFeeToken: \&quot;0x0000000000000000000000000000000000000000\&quot;,\n})).to.be.rejectedWith(\&quot;Invalid mint fee token address\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;14eddeb7-d274-4d91-8e73-c77754d571f2&quot;,&quot;parentUUID&quot;:&quot;9df8d475-17de-4b6c-bf6a-383a52552dd4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;4594dac8-e612-495f-a5b6-5b7b92d3b2c2&quot;,&quot;d73015fc-34b8-4027-a0ff-a24d938a1eca&quot;,&quot;1087d032-e3f5-4b51-b70b-08d4bcad5eda&quot;,&quot;7e37a26e-26e4-4de9-b58e-b0f24bc138ca&quot;,&quot;bd31a7ec-7171-4b6c-af37-dee20f4484dd&quot;,&quot;bd7c5252-7664-41fb-83ba-fa2734417632&quot;,&quot;14eddeb7-d274-4d91-8e73-c77754d571f2&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:28761,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;528c661e-39fc-4625-9272-f740590122de&quot;,&quot;title&quot;:&quot;Mint Fee&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully get mint fee token&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions Mint Fee should successfully get mint fee token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:94,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintFeeToken = await client.nftClient.getMintFeeToken(spgNftContract);\n(0, chai_1.expect)(mintFeeToken).to.equal(generated_1.erc20Address[mockData_1.aeneid]);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1066d0d5-cf5e-479d-9f7f-8403987a5ce4&quot;,&quot;parentUUID&quot;:&quot;528c661e-39fc-4625-9272-f740590122de&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should successfully get mint fee&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions Mint Fee should successfully get mint fee&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:105,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const mintFee = await client.nftClient.getMintFee(spgNftContract);\n(0, chai_1.expect)(mintFee).to.equal(10000000n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ae741c97-a352-4d8e-b4e2-a750ee495ba9&quot;,&quot;parentUUID&quot;:&quot;528c661e-39fc-4625-9272-f740590122de&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1066d0d5-cf5e-479d-9f7f-8403987a5ce4&quot;,&quot;ae741c97-a352-4d8e-b4e2-a750ee495ba9&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:199,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;472c9318-c084-4ae5-be3c-4497f3846579&quot;,&quot;title&quot;:&quot;set and get tokenURI&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully set token URI&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions set and get tokenURI should successfully set token URI&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14951,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Setup: Approve the contract for ERC20 transfers\nconst erc20Client = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[mockData_1.aeneid]);\nconst txHash = await erc20Client.approve(spgNftContract, viem_1.maxUint256);\nawait util_1.publicClient.waitForTransactionReceipt({ hash: txHash });\n// Mint a new token with initial metadata\nconst tokenId = await (0, util_1.mintBySpg)(spgNftContract, \&quot;ipfs://QmTest/\&quot;);\n(0, chai_1.expect)(tokenId).to.be.a(\&quot;bigint\&quot;);\n// Update the token URI\nconst updatedMetadata = \&quot;ipfs://QmUpdated/metadata.json\&quot;;\nconst result = await client.nftClient.setTokenURI({\n    tokenId: tokenId,\n    tokenURI: updatedMetadata,\n    spgNftContract,\n});\n// Verify the transaction\n(0, chai_1.expect)(result.txHash).to.be.a(\&quot;string\&quot;);\n// Verification that the URI was updated\nconst tokenURI = await client.nftClient.getTokenURI({\n    tokenId,\n    spgNftContract,\n});\n(0, chai_1.expect)(tokenURI).to.equal(updatedMetadata);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e1174ca1-3c0e-4359-bdc5-d258db94508c&quot;,&quot;parentUUID&quot;:&quot;472c9318-c084-4ae5-be3c-4497f3846579&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;e1174ca1-3c0e-4359-bdc5-d258db94508c&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:14951,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;8b03cdc2-2938-4f96-8c26-ebb776c1e179&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/nftClient.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/nftClient.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;fails with invalid token ID&quot;,&quot;fullTitle&quot;:&quot;nftClient Functions Error Cases fails with invalid token ID&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9130,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const erc20Client = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[mockData_1.aeneid]);\nconst txHash = await erc20Client.approve(spgNftContract, viem_1.maxUint256);\nawait util_1.publicClient.waitForTransactionReceipt({ hash: txHash });\nconst invalidTokenId = 999999999999999n;\nconst updatedMetadata = \&quot;ipfs://QmUpdated/metadata.json\&quot;;\nawait (0, chai_1.expect)(client.nftClient.setTokenURI({\n    tokenId: invalidTokenId,\n    tokenURI: updatedMetadata,\n    spgNftContract,\n})).to.be.rejectedWith(\&quot;Failed to set token URI\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;abf5f270-0c9a-469d-9c5c-9419e2349e1b&quot;,&quot;parentUUID&quot;:&quot;8b03cdc2-2938-4f96-8c26-ebb776c1e179&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;abf5f270-0c9a-469d-9c5c-9419e2349e1b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:9130,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;5409bc71-974b-44e4-84b5-4870cbd74bc8&quot;,&quot;title&quot;:&quot;Permission Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Permission Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Permission Functions \&quot;before all\&quot; hook in \&quot;Permission Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14144,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nconst tokenId = await (0, util_1.getTokenId)();\nconst response = await client.ipAsset.register({\n    nftContract: util_1.mockERC721,\n    tokenId: tokenId,\n});\nipId = response.ipId;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5e4f1b1b-26f0-4b82-a6e6-db1145b525c8&quot;,&quot;parentUUID&quot;:&quot;5409bc71-974b-44e4-84b5-4870cbd74bc8&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;18986f80-8319-4fc6-8e9a-4dde71192d89&quot;,&quot;title&quot;:&quot;Single Permission Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should set permission successfully&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Single Permission Operations should set permission successfully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5194,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.setPermission({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n    func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1883f1e6-02d3-4d14-8a33-2c00a5759654&quot;,&quot;parentUUID&quot;:&quot;18986f80-8319-4fc6-8e9a-4dde71192d89&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should set all permissions successfully&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Single Permission Operations should set all permissions successfully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5060,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.setAllPermissions({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    permission: permission_1.AccessPermission.ALLOW,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a9e2847a-682b-477f-a94d-9b136f8c2276&quot;,&quot;parentUUID&quot;:&quot;18986f80-8319-4fc6-8e9a-4dde71192d89&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1883f1e6-02d3-4d14-8a33-2c00a5759654&quot;,&quot;a9e2847a-682b-477f-a94d-9b136f8c2276&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:10254,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;6fc10a44-d195-440f-a670-f4a9be17e006&quot;,&quot;title&quot;:&quot;Permission Signatures&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should create set permission signature&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Permission Signatures should create set permission signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5222,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.createSetPermissionSignature({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n    permission: permission_1.AccessPermission.ALLOW,\n    deadline: 60000n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e2264e0d-222e-4849-9ae3-c018323cd765&quot;,&quot;parentUUID&quot;:&quot;6fc10a44-d195-440f-a670-f4a9be17e006&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;e2264e0d-222e-4849-9ae3-c018323cd765&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:5222,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;9619b76b-fe22-42d0-af6a-a806da0ec31f&quot;,&quot;title&quot;:&quot;Batch Operations&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should set batch permissions successfully&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Batch Operations should set batch permissions successfully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5068,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.setBatchPermissions({\n    permissions: [\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.ALLOW,\n            func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n        },\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.DENY,\n            func: \&quot;function freezeMetadata(address)\&quot;,\n        },\n    ],\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;705729aa-2d38-4527-a972-c4ab8d4946ee&quot;,&quot;parentUUID&quot;:&quot;9619b76b-fe22-42d0-af6a-a806da0ec31f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should create batch permission signature&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Batch Operations should create batch permission signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5321,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.permission.createBatchPermissionSignature({\n    ipId: ipId,\n    permissions: [\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.ALLOW,\n            func: \&quot;function setAll(address,string,bytes32,bytes32)\&quot;,\n        },\n        {\n            ipId: ipId,\n            signer: util_1.TEST_WALLET_ADDRESS,\n            to: coreMetadataModule,\n            permission: permission_1.AccessPermission.DENY,\n            func: \&quot;function freezeMetadata(address)\&quot;,\n        },\n    ],\n    deadline: 60000n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\n(0, chai_1.expect)(response.success).to.equal(true);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7c69c2e2-9db1-4f5b-b8be-f0397bf1c7ef&quot;,&quot;parentUUID&quot;:&quot;9619b76b-fe22-42d0-af6a-a806da0ec31f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;705729aa-2d38-4527-a972-c4ab8d4946ee&quot;,&quot;7c69c2e2-9db1-4f5b-b8be-f0397bf1c7ef&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:10389,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;0a0748da-94a3-4f2d-8fef-a22298989f96&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/permission.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/permission.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should fail when setting permission for unregistered IP&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Error Cases should fail when setting permission for unregistered IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:111,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const unregisteredIpId = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nawait (0, chai_1.expect)(client.permission.setPermission({\n    ipId: unregisteredIpId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n})).to.be.rejectedWith(`IP id with ${unregisteredIpId} is not registered.`);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;dc1d2334-3301-421e-a21e-b92d2e5bbf39&quot;,&quot;parentUUID&quot;:&quot;0a0748da-94a3-4f2d-8fef-a22298989f96&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail with invalid function signature&quot;,&quot;fullTitle&quot;:&quot;Permission Functions Error Cases should fail with invalid function signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:114,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await (0, chai_1.expect)(client.permission.setPermission({\n    ipId: ipId,\n    signer: util_1.TEST_WALLET_ADDRESS,\n    to: coreMetadataModule,\n    permission: permission_1.AccessPermission.ALLOW,\n    func: \&quot;invalid_function_signature\&quot;,\n})).to.be.rejected;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ae2b3088-ac0b-4155-aab1-363594446fbb&quot;,&quot;parentUUID&quot;:&quot;0a0748da-94a3-4f2d-8fef-a22298989f96&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;dc1d2334-3301-421e-a21e-b92d2e5bbf39&quot;,&quot;ae2b3088-ac0b-4155-aab1-363594446fbb&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:225,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;62c7cb47-4b60-46ee-ae64-01698a9ee2c6&quot;,&quot;title&quot;:&quot;Royalty Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Royalty Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions \&quot;before all\&quot; hook in \&quot;Royalty Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:32103,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();\nmockERC20 = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, generated_1.erc20Address[util_1.aeneid]);\n// Setup initial state\nparentIpId = await getIpId();\nchildIpId = await getIpId();\nlicenseTermsId = await getCommercialPolicyId();\n// Setup relationships and approvals\nawait attachLicenseTerms(parentIpId, licenseTermsId);\nawait mockERC20.mint(util_1.TEST_WALLET_ADDRESS, (0, viem_1.parseEther)(\&quot;10\&quot;));\nawait mockERC20.approve(generated_1.royaltyModuleAddress[util_1.aeneid], viem_1.maxUint256);\n// Register derivative\nawait client.ipAsset.registerDerivative({\n    childIpId: childIpId,\n    parentIpIds: [parentIpId],\n    licenseTermsIds: [licenseTermsId],\n    maxMintingFee: \&quot;0\&quot;,\n    maxRts: \&quot;0\&quot;,\n    maxRevenueShare: \&quot;0\&quot;,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3f15cec8-b69e-4c16-bd82-96a359c1faa8&quot;,&quot;parentUUID&quot;:&quot;62c7cb47-4b60-46ee-ae64-01698a9ee2c6&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;47952a91-3a81-4590-ae19-7a48d6d4b0e9&quot;,&quot;title&quot;:&quot;Royalty Payments&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should successfully pay royalty on behalf&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should successfully pay royalty on behalf&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5269,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: parentIpId,\n    payerIpId: childIpId,\n    token: generated_1.erc20Address[util_1.aeneid],\n    amount: 1,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;05e132c1-cc9a-4bbf-9705-cfde62fce063&quot;,&quot;parentUUID&quot;:&quot;47952a91-3a81-4590-ae19-7a48d6d4b0e9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should auto convert IP to WIP when paying WIP on behalf&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should auto convert IP to WIP when paying WIP on behalf&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5689,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const balanceBefore = await client.getWalletBalance();\nconst response = await client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: parentIpId,\n    payerIpId: childIpId,\n    token: common_1.WIP_TOKEN_ADDRESS,\n    amount: 100n,\n});\n(0, chai_1.expect)(response.txHash).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\n(0, chai_1.expect)(Number(balanceAfter)).lessThan(Number(balanceBefore - 100n));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;666baa3b-9351-41a6-b47e-31a4c69aa231&quot;,&quot;parentUUID&quot;:&quot;47952a91-3a81-4590-ae19-7a48d6d4b0e9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail to pay royalty with unregistered receiver&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should fail to pay royalty with unregistered receiver&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:100,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const unregisteredIpId = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nawait (0, chai_1.expect)(client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: unregisteredIpId,\n    payerIpId: childIpId,\n    token: generated_1.erc20Address[util_1.aeneid],\n    amount: 10 * 10 ** 2,\n})).to.be.rejectedWith(`The receiver IP with id ${unregisteredIpId} is not registered.`);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a46e6648-d43b-4326-93c0-de68b397fb50&quot;,&quot;parentUUID&quot;:&quot;47952a91-3a81-4590-ae19-7a48d6d4b0e9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow the royalty vault to transfer its native tokens to a wallet address&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Royalty Payments should allow the royalty vault to transfer its native tokens to a wallet address&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5449,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const royaltyVaultAddress = await client.royalty.getRoyaltyVaultAddress(parentIpId);\nconst royaltyVaultToken = new token_1.ERC20Client(util_1.publicClient, util_1.walletClient, royaltyVaultAddress);\nconst transferAmount = BigInt(10 * 10 ** 6); // 10 million tokens\n// Check initial balances of the vault token\nconst initialTargetBalance = await royaltyVaultToken.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst initialParentBalance = await royaltyVaultToken.balanceOf(parentIpId);\n(0, chai_1.expect)(Number(initialParentBalance)).greaterThanOrEqual(Number(transferAmount));\nconst transferResult = await client.ipAccount.execute({\n    to: royaltyVaultAddress,\n    value: 0,\n    ipId: parentIpId,\n    data: (0, viem_1.encodeFunctionData)({\n        abi: viem_1.erc20Abi,\n        functionName: \&quot;transfer\&quot;,\n        args: [util_1.TEST_WALLET_ADDRESS, transferAmount],\n    }),\n});\n(0, chai_1.expect)(transferResult.txHash).to.be.a(\&quot;string\&quot;);\n// Check final balances to confirm the transfer worked\nconst finalTargetBalance = await royaltyVaultToken.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst finalParentBalance = await royaltyVaultToken.balanceOf(parentIpId);\n(0, chai_1.expect)(finalTargetBalance).to.equal(initialTargetBalance + transferAmount, \&quot;Target wallet balance should increase by the transfer amount\&quot;);\n(0, chai_1.expect)(Number(finalParentBalance)).equal(Number(initialParentBalance - transferAmount));&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6a70e59b-3519-4fed-8599-f4299133b9eb&quot;,&quot;parentUUID&quot;:&quot;47952a91-3a81-4590-ae19-7a48d6d4b0e9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;05e132c1-cc9a-4bbf-9705-cfde62fce063&quot;,&quot;666baa3b-9351-41a6-b47e-31a4c69aa231&quot;,&quot;a46e6648-d43b-4326-93c0-de68b397fb50&quot;,&quot;6a70e59b-3519-4fed-8599-f4299133b9eb&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:16507,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;50d08852-9d3a-49af-863c-2be6165ca7e4&quot;,&quot;title&quot;:&quot;Revenue Queries&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should return claimable revenue amount&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Revenue Queries should return claimable revenue amount&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:292,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.royalty.claimableRevenue({\n    ipId: parentIpId,\n    claimer: util_1.TEST_WALLET_ADDRESS,\n    token: generated_1.erc20Address[util_1.aeneid],\n});\n(0, chai_1.expect)(response).to.be.a(\&quot;bigint\&quot;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c97ec4be-060f-48ba-bc17-250331f0be13&quot;,&quot;parentUUID&quot;:&quot;50d08852-9d3a-49af-863c-2be6165ca7e4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail to get royalty vault address for unregistered IP&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Revenue Queries should fail to get royalty vault address for unregistered IP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:96,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const unregisteredIpId = \&quot;0x1234567890123456789012345678901234567890\&quot;;\nawait (0, chai_1.expect)(client.royalty.getRoyaltyVaultAddress(unregisteredIpId)).to.be.rejectedWith(`The royalty vault IP with id ${unregisteredIpId} is not registered.`);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c53b72f5-a843-45b1-9079-458d4006ddab&quot;,&quot;parentUUID&quot;:&quot;50d08852-9d3a-49af-863c-2be6165ca7e4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;c97ec4be-060f-48ba-bc17-250331f0be13&quot;,&quot;c53b72f5-a843-45b1-9079-458d4006ddab&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:388,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;de2c6cd7-e0a2-4e49-a034-e28828f77334&quot;,&quot;title&quot;:&quot;Error Cases&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should return zero for claimable revenue with invalid token&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions Error Cases should return zero for claimable revenue with invalid token&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:278,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const response = await client.royalty.claimableRevenue({\n    ipId: parentIpId,\n    claimer: util_1.TEST_WALLET_ADDRESS,\n    token: \&quot;0x0000000000000000000000000000000000000000\&quot;,\n});\n(0, chai_1.expect)(response).to.equal(0n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b6d86098-06c1-4191-a046-c3144b682005&quot;,&quot;parentUUID&quot;:&quot;de2c6cd7-e0a2-4e49-a034-e28828f77334&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;b6d86098-06c1-4191-a046-c3144b682005&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:278,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;4ecaac11-6912-4aaa-9012-cbaad9879b83&quot;,&quot;title&quot;:&quot;ClaimAllRevenue With WIP&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;ClaimAllRevenue With WIP\&quot;&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions ClaimAllRevenue With WIP \&quot;before all\&quot; hook in \&quot;ClaimAllRevenue With WIP\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:29254,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// set up\n// minting Fee: 100, 10% LAP rev share, A expect to get 120 WIP\n// A -&gt; B -&gt; C -&gt; D\nconst txData = await client.nftClient.createNFTCollection({\n    name: \&quot;free-collection\&quot;,\n    symbol: \&quot;FREE\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: viem_1.zeroAddress,\n});\nspgNftContract = txData.spgNftContract;\nconst retA = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 100n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 100n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nipA = retA.ipId;\nlicenseId = retA.licenseTermsIds[0];\nconst retB = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipA],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\nipB = retB.ipId;\nconst retC = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipB],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});\nipC = retC.ipId;\nawait client.ipAsset.mintAndRegisterIpAndMakeDerivative({\n    spgNftContract,\n    derivData: {\n        parentIpIds: [ipC],\n        licenseTermsIds: [licenseId],\n        maxMintingFee: 0n,\n        maxRts: common_1.MAX_ROYALTY_TOKEN,\n        maxRevenueShare: 100,\n    },\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;76b20d8c-2e05-4590-aeac-479660b3946d&quot;,&quot;parentUUID&quot;:&quot;4ecaac11-6912-4aaa-9012-cbaad9879b83&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should claim all revenue&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions ClaimAllRevenue With WIP should claim all revenue&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14934,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const ret = await client.royalty.claimAllRevenue({\n    ancestorIpId: ipA,\n    claimer: ipA,\n    childIpIds: [ipB, ipC],\n    royaltyPolicies: [generated_1.royaltyPolicyLapAddress[util_1.aeneid], generated_1.royaltyPolicyLapAddress[util_1.aeneid]],\n    currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n});\n(0, chai_1.expect)(ret.txHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(ret.claimedTokens[0].amount).to.equal(120n);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;88d44d0a-32fb-42a1-b680-06fefd869011&quot;,&quot;parentUUID&quot;:&quot;4ecaac11-6912-4aaa-9012-cbaad9879b83&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;88d44d0a-32fb-42a1-b680-06fefd869011&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:14934,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;c1341aa7-ddbb-41de-bfd8-3513006997e8&quot;,&quot;title&quot;:&quot;BatchClaimAllRevenue With WIP&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/royalty.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/royalty.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;BatchClaimAllRevenue With WIP\&quot;&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions BatchClaimAllRevenue With WIP \&quot;before all\&quot; hook in \&quot;BatchClaimAllRevenue With WIP\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:58556,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const derivedClient = await (0, BIP32_1.getDerivedStoryClient)();\nanotherAddress = derivedClient.address;\nawait client.wipClient.deposit({\n    amount: (0, viem_1.parseEther)(\&quot;5\&quot;),\n});\n/**\n * Asset Hierarchy Setup for Revenue Collection Tests\n *\n * Overview:\n * This test setup creates two distinct IP asset hierarchies (IpA and IpB) to demonstrate\n * different revenue collection scenarios using LAP (Licensing Agreement Policy) and LRP\n * (Licensing Revenue Policy) respectively.\n *\n * IpA Hierarchy (LAP - Licensing Agreement Policy):                           IpB Hierarchy (LRP - Licensing Revenue Policy):\n * ┌─────────────────────────────────────────────────────────────┐          ┌─────────────────────────────────────────────────────────────┐\n * │ IpA (Parent) - Total Expected Revenue: 130 WIP              │          │ IpB (Parent) - Total Expected Revenue: 330 WIP              │\n * ├─────────────────────────────────────────────────────────────┤          ├─────────────────────────────────────────────────────────────┤\n * │ Revenue Sources:                                            │          │ Revenue Sources:                                            │\n * │ ├── Minting Fee: 100 WIP                                    │          │ ├── Minting Fee: 150 WIP                                    │\n * │ ├── Revenue Share (ipA2-&gt;ipA1): 10 WIP (10% LAP)            │          │ ├── LRP Revenue Share: 10%                                  │\n * │ ├── Revenue Share (ipA3-&gt;ipA2): 10 WIP (10% LAP)            │          │ ├── Total Revenue: 330 WIP                                  │\n * │ └── Direct Payment (ipA3): 10 WIP (10% LAP)                 │          │    └── From ipB1: 150 WIP + 10% revenue share               │\n * │                                                             │          │    └── From ipB2: 150 WIP + 10% revenue share               │\n * │                                                             │          │                                                             │\n * | Ownership Distribution:                                     │          |                                                             │\n * │ ├── Wallet Address: 50%  65 WIP                             │          │ Revenue Flow:                                               │\n * │ └── Another Address: 50% 65 WIP                             │          │ ipB3                                                        │\n * │                                                             │          │ ├── ipB1 ─┐                                                 │\n * │ Revenue Flow:                                               │          │ └── ipB2 ─┴──&gt; ipB (collects 330 WIP)                       │\n * │ ipA3                                                        │          │                                                             │\n * │  └──&gt; ipA2 (20% LAP) ──&gt; ipA1 (10% LAP) ──&gt; ipA             │          │                                                             │\n * │       └──&gt; Direct Payment: 100 WIP                          │          │                                                             │\n * └─────────────────────────────────────────────────────────────┘          └─────────────────────────────────────────────────────────────┘\n */\nconst txData = await client.nftClient.createNFTCollection({\n    name: \&quot;free-collection\&quot;,\n    symbol: \&quot;FREE\&quot;,\n    maxSupply: 100,\n    isPublicMinting: true,\n    mintOpen: true,\n    contractURI: \&quot;test-uri\&quot;,\n    mintFeeRecipient: viem_1.zeroAddress,\n});\nspgNftContract = txData.spgNftContract;\n// 1. Register ipA\nconst ret1A = await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLapAddress[util_1.aeneid],\n                defaultMintingFee: 100n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 100n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n    royaltyShares: [\n        {\n            recipient: util_1.TEST_WALLET_ADDRESS,\n            percentage: 50,\n        },\n        {\n            recipient: anotherAddress,\n            percentage: 50,\n        },\n    ],\n});\nipA = ret1A.ipId;\nlicenseId = ret1A.licenseTermsIds[0];\n// 2. Register ipB\nconst ret1B = await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({\n    spgNftContract,\n    licenseTermsData: [\n        {\n            terms: {\n                transferable: true,\n                royaltyPolicy: generated_1.royaltyPolicyLrpAddress[util_1.aeneid],\n                defaultMintingFee: 150n,\n                expiration: 0n,\n                commercialUse: true,\n                commercialAttribution: false,\n                commercializerChecker: viem_1.zeroAddress,\n                commercializerCheckerData: viem_1.zeroAddress,\n                commercialRevShare: 10,\n                commercialRevCeiling: 0n,\n                derivativesAllowed: true,\n                derivativesAttribution: true,\n                derivativesApproval: false,\n                derivativesReciprocal: true,\n                derivativeRevCeiling: 0n,\n                currency: common_1.WIP_TOKEN_ADDRESS,\n                uri: \&quot;\&quot;,\n            },\n            licensingConfig: {\n                isSet: false,\n                mintingFee: 150n,\n                licensingHook: viem_1.zeroAddress,\n                hookData: viem_1.zeroAddress,\n                commercialRevShare: 0,\n                disabled: false,\n                expectMinimumGroupRewardShare: 0,\n                expectGroupRewardPool: viem_1.zeroAddress,\n            },\n        },\n    ],\n});\nipB = ret1B.ipId;\nlicenseId1 = ret1B.licenseTermsIds[0];\n// 3. Register ipA1 from ipA and ipB1 from ipB\nconst { results: ret2 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB],\n                licenseTermsIds: [licenseId1],\n            },\n        },\n    ],\n});\nipA1 = ret2[0].ipId;\nipB1 = ret2[1].ipId;\n// 4. Register ipA2 from ipA1 and ipB2 from ipB\nconst { results: ret3 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA1],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB],\n                licenseTermsIds: [licenseId1],\n            },\n        },\n    ],\n});\nipA2 = ret3[0].ipId;\nipB2 = ret3[1].ipId;\n// 5. Register ipA3 from ipA2 and ipB3 from ipB1 and ipB2\nconst { results: ret4 } = await client.ipAsset.batchMintAndRegisterIpAndMakeDerivative({\n    args: [\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipA2],\n                licenseTermsIds: [licenseId],\n            },\n        },\n        {\n            spgNftContract,\n            derivData: {\n                parentIpIds: [ipB1, ipB2],\n                licenseTermsIds: [licenseId1, licenseId1],\n            },\n        },\n    ],\n});\nipA3 = ret4[0].ipId;\n// 6. Pay royalty on behalf of ipA2 to ipA3\nawait client.royalty.payRoyaltyOnBehalf({\n    receiverIpId: ipA2,\n    payerIpId: ipA3,\n    token: common_1.WIP_TOKEN_ADDRESS,\n    amount: 100n,\n});\nconst balance = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nawait client.wipClient.withdraw({\n    amount: balance,\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a0a325b2-fd39-44f0-a648-ed2e5892ea62&quot;,&quot;parentUUID&quot;:&quot;c1341aa7-ddbb-41de-bfd8-3513006997e8&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should batch claim all revenue&quot;,&quot;fullTitle&quot;:&quot;Royalty Functions BatchClaimAllRevenue With WIP should batch claim all revenue&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:19519,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const anotherAddressWipBalanceBefore = await client.wipClient.balanceOf(anotherAddress);\nconst result = await client.royalty.batchClaimAllRevenue({\n    ancestorIps: [\n        {\n            ipId: ipA,\n            claimer: util_1.TEST_WALLET_ADDRESS,\n            childIpIds: [ipA1, ipA2],\n            royaltyPolicies: [generated_1.royaltyPolicyLapAddress[util_1.aeneid], generated_1.royaltyPolicyLapAddress[util_1.aeneid]],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n        },\n        {\n            ipId: ipA,\n            claimer: anotherAddress,\n            childIpIds: [],\n            royaltyPolicies: [],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS],\n        },\n        {\n            ipId: ipB,\n            claimer: ipB,\n            childIpIds: [ipB1, ipB2],\n            royaltyPolicies: [generated_1.royaltyPolicyLrpAddress[util_1.aeneid], generated_1.royaltyPolicyLrpAddress[util_1.aeneid]],\n            currencyTokens: [common_1.WIP_TOKEN_ADDRESS, common_1.WIP_TOKEN_ADDRESS],\n        },\n    ],\n});\nconst anotherAddressWipBalanceAfter = await client.wipClient.balanceOf(anotherAddress);\nconst walletWipBalanceAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(result.txHashes).to.be.an(\&quot;array\&quot;);\n(0, chai_1.expect)(result.claimedTokens[0].amount).to.equal(65n);\n(0, chai_1.expect)(result.claimedTokens[1].amount).to.equal(65n);\n(0, chai_1.expect)(result.claimedTokens[2].amount).to.equal(330n);\n(0, chai_1.expect)(walletWipBalanceAfter).to.equal(0n);\n(0, chai_1.expect)(anotherAddressWipBalanceAfter).to.equal(anotherAddressWipBalanceBefore + 65n);\n// Note: The final wallet balance cannot be precisely calculated because:\n// The test involves multiple transactions (claimAllRevenue, token transfers, etc.)\n// batchClaimAllRevenue only returns receipts for claimAllRevenue calls\n// Additional gas costs and token transfers occur outside the returned receipts&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fa50bcad-8ff0-49cb-acae-e930693e25e6&quot;,&quot;parentUUID&quot;:&quot;c1341aa7-ddbb-41de-bfd8-3513006997e8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;fa50bcad-8ff0-49cb-acae-e930693e25e6&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:19519,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;245efda3-ec7c-47f6-9f71-0a202a84d7f8&quot;,&quot;title&quot;:&quot;WIP Functions&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;WIP Functions\&quot;&quot;,&quot;fullTitle&quot;:&quot;WIP Functions \&quot;before all\&quot; hook in \&quot;WIP Functions\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = (0, util_1.getStoryClient)();&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9249d9b5-fd12-4419-84ed-5ebafca85e9a&quot;,&quot;parentUUID&quot;:&quot;245efda3-ec7c-47f6-9f71-0a202a84d7f8&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;e69aa680-39dd-4d6c-a603-03108147e1c5&quot;,&quot;title&quot;:&quot;deposit&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should deposit 0.01 WIP&quot;,&quot;fullTitle&quot;:&quot;WIP Functions deposit should deposit 0.01 WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5280,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const ipAmt = (0, viem_1.parseEther)(\&quot;0.01\&quot;);\nconst balanceBefore = await client.getWalletBalance();\nconst wipBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst rsp = await client.wipClient.deposit({\n    amount: ipAmt,\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\nconst balanceAfter = await client.getWalletBalance();\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.equal(wipBefore + ipAmt);\nconst gasCost = rsp.receipt.gasUsed * rsp.receipt.effectiveGasPrice;\n(0, chai_1.expect)(balanceAfter).to.equal(balanceBefore - ipAmt - gasCost);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;412ccd2c-8e28-4ecb-b588-500f35c4369e&quot;,&quot;parentUUID&quot;:&quot;e69aa680-39dd-4d6c-a603-03108147e1c5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;412ccd2c-8e28-4ecb-b588-500f35c4369e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:5280,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;07588419-9f60-42b2-a57b-0b5c84a52b51&quot;,&quot;title&quot;:&quot;transfer&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should transfer WIP&quot;,&quot;fullTitle&quot;:&quot;WIP Functions transfer should transfer WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4933,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const rsp = await client.wipClient.transfer({\n    to: util_1.TEST_WALLET_ADDRESS,\n    amount: (0, viem_1.parseEther)(\&quot;0.01\&quot;),\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\n//Due to approve cannot approve msy.sender, so skip transferFrom test&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;367f6fc0-5473-4dda-a848-46fa514c236e&quot;,&quot;parentUUID&quot;:&quot;07588419-9f60-42b2-a57b-0b5c84a52b51&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;367f6fc0-5473-4dda-a848-46fa514c236e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4933,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000},{&quot;uuid&quot;:&quot;88cf6a9d-b3dd-4d00-be12-1996cbd08799&quot;,&quot;title&quot;:&quot;withdraw&quot;,&quot;fullFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/test/integration/wip.test.ts&quot;,&quot;file&quot;:&quot;/test/integration/wip.test.ts&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should withdrawal WIP&quot;,&quot;fullTitle&quot;:&quot;WIP Functions withdraw should withdrawal WIP&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5263,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const balanceBefore = await client.getWalletBalance();\nconst wipBefore = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\nconst rsp = await client.wipClient.withdraw({\n    amount: wipBefore,\n});\n(0, chai_1.expect)(rsp.txHash).to.be.a(\&quot;string\&quot;);\nconst wipAfter = await client.wipClient.balanceOf(util_1.TEST_WALLET_ADDRESS);\n(0, chai_1.expect)(wipAfter).to.equal(0n);\nconst balanceAfter = await client.getWalletBalance();\nconst gasCost = rsp.receipt.gasUsed * rsp.receipt.effectiveGasPrice;\n(0, chai_1.expect)(balanceAfter).to.equal(balanceBefore + wipBefore - gasCost);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2307aa84-824b-4d07-8370-db791a67282c&quot;,&quot;parentUUID&quot;:&quot;88cf6a9d-b3dd-4d00-be12-1996cbd08799&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;2307aa84-824b-4d07-8370-db791a67282c&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:5263,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:300000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:300000}],&quot;meta&quot;:{&quot;mocha&quot;:{&quot;version&quot;:&quot;10.8.2&quot;},&quot;mochawesome&quot;:{&quot;options&quot;:{&quot;quiet&quot;:false,&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;saveHtml&quot;:true,&quot;saveJson&quot;:true,&quot;consoleReporter&quot;:&quot;spec&quot;,&quot;useInlineDiffs&quot;:false,&quot;code&quot;:true},&quot;version&quot;:&quot;7.1.4&quot;},&quot;marge&quot;:{&quot;version&quot;:&quot;6.3.0&quot;}}}" data-config="{&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;reportDir&quot;:&quot;mochawesome-report&quot;,&quot;reportTitle&quot;:&quot;core-sdk&quot;,&quot;reportPageTitle&quot;:&quot;Mochawesome Report&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;cdn&quot;:false,&quot;charts&quot;:false,&quot;enableCharts&quot;:false,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;showPassed&quot;:true,&quot;showFailed&quot;:true,&quot;showPending&quot;:true,&quot;showSkipped&quot;:false,&quot;showHooks&quot;:&quot;failed&quot;,&quot;saveJson&quot;:true,&quot;saveHtml&quot;:true,&quot;dev&quot;:false,&quot;assetsDir&quot;:&quot;mochawesome-report/assets&quot;,&quot;jsonFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/mochawesome-report/mochawesome.json&quot;,&quot;htmlFile&quot;:&quot;/home/runner/work/sdk/sdk/packages/core-sdk/mochawesome-report/mochawesome.html&quot;}"><div id="report"></div><script src="assets/app.js"></script></body></html>